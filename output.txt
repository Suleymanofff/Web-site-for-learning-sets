Файл: C:\dev\projects\html\Курсовая работа\garunGPT\api_server.py
from flask import Flask, request, jsonify
import joblib
import os

app = Flask(__name__)

MODEL_DIR  = "garunGPT"
VEC_PATH   = os.path.join(MODEL_DIR, "tfidf_vectorizer.joblib")
MODEL_PATH = os.path.join(MODEL_DIR, "difficulty_model.joblib")

# Загрузка артефактов один раз при старте
vectorizer = joblib.load(VEC_PATH)
model      = joblib.load(MODEL_PATH)

@app.route("/predict", methods=["POST"])
def predict():
    data = request.get_json()
    if not data or "question_text" not in data:
        return jsonify({"error": "Missing 'question_text'"}), 400

    text = data["question_text"]
    vec  = vectorizer.transform([text])
    pred = model.predict(vec)[0]
    return jsonify({"difficulty": pred})

@app.route("/", methods=["GET"])
def root():
    return "garunGPT API Server is running."

if __name__ == "__main__":
    app.run(debug=True, port=5000)

Файл: C:\dev\projects\html\Курсовая работа\garunGPT\difficulty_service.py
import os
import sys
from joblib import load

# Глобальные переменные, инициализируемые при старте
global_vectorizer = None
global_model      = None

def load_model(model_dir: str = "garunGPT"):
    global global_vectorizer, global_model

    vec_path   = os.path.join(model_dir, "tfidf_vectorizer.joblib")
    model_path = os.path.join(model_dir, "difficulty_model.joblib")

    if not os.path.exists(vec_path) or not os.path.exists(model_path):
        print(f"Ошибка: не найден(ы) файл(ы) модели в {model_dir}", file=sys.stderr)
        sys.exit(1)

    global_vectorizer = load(vec_path)
    global_model      = load(model_path)

    print(f"[difficulty_service] Loaded vectorizer from {vec_path}")
    print(f"[difficulty_service] Loaded model      from {model_path}")

def predict_difficulty(text: str) -> str:
    if global_vectorizer is None or global_model is None:
        raise RuntimeError("Модель не загружена. Вызовите сначала load_model().")

    X = global_vectorizer.transform([text])
    pred = global_model.predict(X)
    return pred[0]

if __name__ == "__main__":
    load_model()
    print("Введите текст вопроса для предсказания сложности (или 'exit'):")
    while True:
        q = input("> ")
        if q.lower() == "exit":
            break
        print("Predicted difficulty:", predict_difficulty(q))

Файл: C:\dev\projects\html\Курсовая работа\garunGPT\export_questions.py
import csv
import os
import psycopg2
from psycopg2.extras import DictCursor


DB_PARAMS = {
    'dbname':   os.getenv('DB_NAME', 'KursachDB'),
    'user':     os.getenv('DB_USER', 'garun'),
    'password': os.getenv('DB_PASS', 'origami'),
    'host':     os.getenv('DB_HOST', 'localhost'),
    'port':     os.getenv('DB_PORT', 5432),
}

QUERY = """
SELECT
  id,
  question_text,
  difficulty
FROM questions
ORDER BY id;
"""

def export_questions(csv_path: str):
    conn = psycopg2.connect(**DB_PARAMS)
    cur = conn.cursor(cursor_factory=DictCursor)
    cur.execute(QUERY)
    rows = cur.fetchall()
    with open(csv_path, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=['id', 'question_text', 'difficulty'])
        writer.writeheader()
        for row in rows:
            writer.writerow({
                'id': row['id'],
                'question_text': row['question_text'],
                'difficulty': row['difficulty']
            })
    cur.close()
    conn.close()
    print(f"Экспортировано {len(rows)} вопросов в {csv_path}")

if __name__ == '__main__':
    export_questions('garunGPT/questions_for_labeling.csv')

Файл: C:\dev\projects\html\Курсовая работа\garunGPT\test_client.py
import requests

url = "http://127.0.0.1:5000/predict"
payload = {
    "question_text": "Выберите все операции, которые приводят к пустому множеству:"
}
response = requests.post(url, json=payload)

print("Ответ от сервера:")
print(payload)
print(response.json())

Файл: C:\dev\projects\html\Курсовая работа\garunGPT\train_difficulty_classifier.py
import os
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
import joblib

DATA_PATH = os.path.join("garunGPT", "questions_for_labeling.csv")
MODEL_DIR = "garunGPT"

def main():
    df = pd.read_csv(DATA_PATH, encoding="utf-8")
    X = df["question_text"].astype(str)
    y = df["difficulty"].astype(str).str.lower().str.strip()

    print("Классы и количество примеров:")
    print(y.value_counts())

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, stratify=y
    )

    vectorizer = TfidfVectorizer(ngram_range=(1, 2), max_features=5000)
    X_train_vec = vectorizer.fit_transform(X_train)
    X_test_vec  = vectorizer.transform(X_test)

    clf = LogisticRegression(multi_class="multinomial", solver="lbfgs", max_iter=1000)
    clf.fit(X_train_vec, y_train)

    y_pred = clf.predict(X_test_vec)
    print("=== Оценка ===")
    print("Accuracy:", accuracy_score(y_test, y_pred))
    print(classification_report(y_test, y_pred, digits=4))

    os.makedirs(MODEL_DIR, exist_ok=True)
    # Сохраняем через joblib с расширением .joblib
    joblib.dump(vectorizer, os.path.join(MODEL_DIR, "tfidf_vectorizer.joblib"))
    joblib.dump(clf,        os.path.join(MODEL_DIR, "difficulty_model.joblib"))
    print("Векторизатор сохранён в garunGPT/tfidf_vectorizer.joblib")
    print("Модель сохранена в garunGPT/difficulty_model.joblib")

if __name__ == "__main__":
    main()

Файл: C:\dev\projects\html\Курсовая работа\node_modules\ipaddr.js

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\adminCourseSearch.js
// Поиск курсов по названию и описанию с подсветкой и подсказками

function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initAdminCourseSearch() {
	const input = document.getElementById('admin-course-search')
	const sugg = document.getElementById('admin-course-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn = wrapper.querySelector('.clear-search')

	const tbody = document.getElementById('coursesBody')
	const rows = Array.from(tbody.querySelectorAll('tr'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowData(row) {
		const title =
			row.querySelector('input.edit-text')?.value.trim().toLowerCase() || ''
		const desc =
			row.querySelector('input.edit-desc')?.value.trim().toLowerCase() || ''
		return { title, description: desc }
	}

	function isFuzzy(text, q) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows

		// 1) точное совпадение по title
		let m = rows.filter(r => getRowData(r).title === query)
		if (m.length) return m

		// 2) подстрока в title или description
		m = rows.filter(r => {
			const d = getRowData(r)
			return d.title.includes(query) || d.description.includes(query)
		})
		if (m.length) return m

		// 3) нечеткий
		return rows.filter(r =>
			isFuzzy(getRowData(r).title + ' ' + getRowData(r).description, query)
		)
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		return (
			text.slice(0, idx) +
			'<mark>' +
			text.slice(idx, idx + query.length) +
			'</mark>' +
			text.slice(idx + query.length)
		)
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			clearSearch()
			return
		}

		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((r, i) => {
			const rawTitle = r.querySelector('input.edit-text')?.value || ''
			const rawDesc = r.querySelector('input.edit-desc')?.value || ''
			const display = `${rawTitle} — ${rawDesc}`
			const li = document.createElement('li')
			li.id = `course-sugg-${i}`
			li.role = 'option'
			li.innerHTML = highlightText(display, q.toLowerCase())
			li.addEventListener('click', () => selectSuggestion(i, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(res) {
		rows.forEach(r => (r.style.display = 'none'))
		res.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		const title = row.querySelector('input.edit-text')?.value || ''
		input.value = title
		renderResults(results)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const deb = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', deb)

	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()

		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterRows(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

// Запускаем после полной отрисовки таблицы курсов
document.addEventListener('adminCourses:loaded', initAdminCourseSearch)

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\adminGroupSearch.js
function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initAdminGroupSearch() {
	const input = document.getElementById('admin-group-search')
	const sugg = document.getElementById('admin-group-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn = wrapper.querySelector('.clear-search')

	const tbody = document.getElementById('groupsBody')
	const rows = Array.from(tbody.querySelectorAll('tr'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowData(row) {
		const name =
			row.querySelector('input.group-name')?.value.trim().toLowerCase() || ''
		return name
	}

	function isFuzzy(text, q) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows

		// точное совпадение
		let m = rows.filter(r => getRowData(r) === query)
		if (m.length) return m

		// подстрока
		m = rows.filter(r => getRowData(r).includes(query))
		if (m.length) return m

		// нечёткий
		return rows.filter(r => isFuzzy(getRowData(r), query))
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		return (
			text.slice(0, idx) +
			'<mark>' +
			text.slice(idx, idx + query.length) +
			'</mark>' +
			text.slice(idx + query.length)
		)
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			clearSearch()
			return
		}

		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((row, i) => {
			const raw = row.querySelector('input.group-name')?.value || ''
			const li = document.createElement('li')
			li.id = `group-sugg-${i}`
			li.role = 'option'
			li.innerHTML = highlightText(raw, q.toLowerCase())
			li.addEventListener('click', () => selectSuggestion(i, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(res) {
		rows.forEach(r => (r.style.display = 'none'))
		res.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		const name = row.querySelector('input.group-name')?.value || ''
		input.value = name
		renderResults(results)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const deb = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', deb)

	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()

		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterRows(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

// Запуск после рендера групп
document.addEventListener('adminGroups:loaded', initAdminGroupSearch)

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\adminUserSearch.js
function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initAdminUserSearch() {
	const input = document.getElementById('admin-user-search')
	const sugg = document.getElementById('admin-user-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn = wrapper.querySelector('.clear-search')

	// все строки таблицы пользователей
	const tbody = document.getElementById('usersBody')
	const rows = Array.from(tbody.querySelectorAll('tr'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowData(row) {
		return {
			email: row.cells[0].innerText.trim().toLowerCase(),
			name: row.cells[1].innerText.trim().toLowerCase(),
		}
	}

	function isFuzzy(text, q) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows

		// 1) точное совпадение email или ФИО
		let matches = rows.filter(r => {
			const d = getRowData(r)
			return d.email === query || d.name === query
		})
		if (matches.length) return matches

		// 2) подстрока
		matches = rows.filter(r => {
			const d = getRowData(r)
			return d.email.includes(query) || d.name.includes(query)
		})
		if (matches.length) return matches

		// 3) нечеткий поиск
		return rows.filter(r => {
			const d = getRowData(r)
			return isFuzzy(d.email + ' ' + d.name, query)
		})
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		return `${text.slice(0, idx)}<mark>${text.slice(
			idx,
			idx + query.length
		)}</mark>${text.slice(idx + query.length)}`
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			clearSearch()
			return
		}

		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((row, i) => {
			const raw = `${row.cells[0].innerText} — ${row.cells[1].innerText}`
			const li = document.createElement('li')
			li.id = `user-sugg-${i}`
			li.role = 'option'
			li.innerHTML = highlightText(raw, q.toLowerCase())
			li.addEventListener('click', () => selectSuggestion(i, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(res) {
		rows.forEach(r => (r.style.display = 'none'))
		res.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		// Собираем оригинальный raw (email — name)
		const raw = `${row.cells[0].innerText} — ${row.cells[1].innerText}`
		// Берём только ту часть до " — "
		const key = raw.split(' — ')[0]
		// Подставляем в input только email (или ключевую часть)
		input.value = key
		// Применяем фильтр по ключу, чтобы оставить одну строку
		const filtered = filterRows(key)
		renderResults(filtered)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const debounced = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', debounced)

	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()

		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterRows(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

document.addEventListener('adminUsers:loaded', initAdminUserSearch)

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\courses.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Управление курсами — Админ‑панель</title>
		<script src="/static/js/theme-init.js"></script>
		<link rel="stylesheet" href="/static/adminPanel/style.css" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<script src="/static/adminPanel/script.js" defer></script>
		<script src="/static/adminPanel/adminCourseSearch.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="index.html">Панель админа</a>
				<a href="users.html">Пользователи</a>
				<a href="courses.html" class="active">Курсы</a>
				<a href="groups.html">Группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="user" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Управление курсами</h1>

			<div class="search-wrapper">
				<input
					id="admin-course-search"
					type="text"
					placeholder="Поиск курса…"
					aria-autocomplete="list"
					aria-controls="admin-course-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="admin-course-suggestions" role="listbox"></ul>
			</div>

			<form id="newCourseForm" class="course-form">
				<input name="title" placeholder="Название курса" required />
				<input name="description" placeholder="Описание курса" required />
				<select name="teacher_id" required>
					<option value="">— выберите преподавателя —</option>
					<!-- JS добавит остальные -->
				</select>
				<button type="submit"><i class="fas fa-plus"></i> Добавить курс</button>
			</form>

			<div class="table-wrapper">
				<table id="coursesTable">
					<thead>
						<tr>
							<th>Название</th>
							<th>Описание</th>
							<th>Преподаватель</th>
							<th>Дата создания</th>
							<th>Действия</th>
						</tr>
					</thead>
					<tbody id="coursesBody"></tbody>
				</table>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\groups.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Управление группами — Админ-панель</title>
		<script src="/static/js/theme-init.js"></script>
		<link rel="stylesheet" href="/static/adminPanel/style.css" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<script src="/static/adminPanel/script.js" defer></script>
		<script src="/static/adminPanel/adminGroupSearch.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="index.html" class="active">Панель админа</a>
				<a href="users.html">Пользователи</a>
				<a href="courses.html">Курсы</a>
				<a href="groups.html" class="active">Группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="user" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Управление группами</h1>

			<div class="search-wrapper">
				<input
					id="admin-group-search"
					type="text"
					placeholder="Поиск группы…"
					aria-autocomplete="list"
					aria-controls="admin-group-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="admin-group-suggestions" role="listbox"></ul>
			</div>

			<!-- Форма создания группы inline наверху -->
			<form id="newGroupForm" class="inline-form">
				<input type="text" name="name" placeholder="Название группы" required />
				<select name="teacher" id="newGroupTeacher">
					<!-- сюда JS вставит опции -->
				</select>
				<button type="submit" class="add-btn">
					<i class="fas fa-plus"></i> Создать
				</button>
			</form>

			<!-- Таблица существующих групп с инлайн-редактированием -->
			<div class="table-wrapper">
				<table id="groupsTable">
					<thead>
						<tr>
							<th>ID</th>
							<th>Название</th>
							<th>Преподаватель</th>
							<th>Действия</th>
						</tr>
					</thead>
					<tbody id="groupsBody">
						<!-- строки заполняются initGroups() -->
					</tbody>
				</table>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Админ‑панель — Set Learn</title>

		<!-- 1. Инициализация темы -->
		<script src="/static/js/theme-init.js"></script>
		<!-- 2. Общие стили (импорт основной style.css) и иконки -->
		<link rel="stylesheet" href="/static/adminPanel/style.css" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<!-- 3. Скрипт админ‑панели -->
		<script src="/static/adminPanel/script.js" defer></script>
	</head>
	<body>
		<!-- Навигационная панель -->
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="index.html" class="active">Панель админа</a>
				<a href="users.html">Пользователи</a>
				<a href="courses.html">Курсы</a>
				<a href="groups.html">Группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="user" />
				</div>
			</div>
		</header>

		<!-- Дашборд с плитками -->
		<main class="page-content">
			<h1>Админ‑панель</h1>
			<div class="tiles">
				<a href="users.html" class="card">
					<i class="fas fa-user"></i>
					<span>Управление пользователями</span>
				</a>
				<a href="courses.html" class="card">
					<i class="fas fa-book"></i>
					<span>Управление курсами</span>
				</a>
				<a href="groups.html" class="card">
					<i class="fas fa-users"></i>
					<span>Управление группами</span>
				</a>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\script.js
// -----------------------
// 1. Навигация
// -----------------------
function navigate(url) {
	window.location.href = url
}

// -----------------------
// 2. Загрузка аватарки
// -----------------------
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'include' })
		if (!res.ok) return
		const u = await res.json()
		if (u.avatar_path) {
			const img = document.querySelector('.user-icon img')
			if (img) img.src = u.avatar_path
		}
	} catch (err) {
		console.error(err)
	}
}

// -----------------------
// 3. Тема
// -----------------------
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	btn.innerHTML = ''
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

// Возвращает строку вида "в сети" или "был(а) сегодня в HH:MM", "был(а) вчера в HH:MM" или "был(а) DD MMM YYYY в HH:MM"
function formatActiveStatus(isActive, lastLogin) {
	if (isActive) return 'в сети'

	const dt = new Date(lastLogin)
	const now = new Date()
	const two = n => String(n).padStart(2, '0')
	const hhmm = `${two(dt.getHours())}:${two(dt.getMinutes())}`

	// сегодня?
	if (dt.toDateString() === now.toDateString()) {
		return `был(а) сегодня в ${hhmm}`
	}
	// вчера?
	const yesterday = new Date(now)
	yesterday.setDate(now.getDate() - 1)
	if (dt.toDateString() === yesterday.toDateString()) {
		return `был(а) вчера в ${hhmm}`
	}
	// раньше
	const monthNames = [
		'янв.',
		'фев.',
		'мар.',
		'апр.',
		'май',
		'июн.',
		'июл.',
		'авг.',
		'сен.',
		'окт.',
		'ноя.',
		'дек.',
	]
	const day = two(dt.getDate())
	const month = monthNames[dt.getMonth()]
	const year = dt.getFullYear()
	return `был(а) ${day} ${month} ${year} в ${hhmm}`
}

// -----------------------
// Управление пользователями
// -----------------------
async function initUsers() {
	const tbody = document.getElementById('usersBody')

	// 1. Забираем одновременно группы и пользователей
	let groups, users
	try {
		const [gRes, uRes] = await Promise.all([
			fetch('/api/admin/groups', { credentials: 'include' }),
			fetch('/api/admin/users', { credentials: 'include' }),
		])
		if (!gRes.ok) throw new Error('Не удалось загрузить группы')
		if (!uRes.ok) throw new Error('Не удалось загрузить пользователей')
		groups = await gRes.json()
		users = await uRes.json()
	} catch (err) {
		return alert(err.message)
	}

	// 2. Формируем HTML-опции для селекта групп
	const groupOptions = [
		`<option value="">Без группы</option>`,
		...groups.map(g => `<option value="${g.id}">${g.name}</option>`),
	].join('')

	// 3. Рендерим таблицу
	tbody.innerHTML = ''
	users.forEach(u => {
		const tr = document.createElement('tr')
		const isStudent = u.role === 'student'

		tr.innerHTML = `
		<td>${u.email}</td>
		<td>${u.full_name}</td>
		<td>
		  <select class="role-select" data-id="${u.id}">
			<option value="student"${
				u.role === 'student' ? ' selected' : ''
			}>student</option>
			<option value="teacher"${
				u.role === 'teacher' ? ' selected' : ''
			}>teacher</option>
			<option value="admin"${u.role === 'admin' ? ' selected' : ''}>admin</option>
		  </select>
		</td>
		<td>${formatActiveStatus(u.is_active, u.last_login)}</td>
		<td>
		  ${
				isStudent
					? `<select class="group-select" data-user-id="${u.id}">${groupOptions}</select>`
					: `<span class="muted">—</span>`
			}
		</td>
		<td class="action-cell">
		  <button class="save-btn" data-id="${u.id}">Сохранить</button>
		  <button class="del-btn"  data-id="${u.id}">Удалить</button>
		</td>
	  `
		tbody.appendChild(tr)

		// выставляем текущую группу только для студентов
		if (isStudent) {
			const gs = tr.querySelector('select.group-select')
			gs.value = u.group_id != null ? u.group_id : ''
		}
	})

	// 4. Сигнализируем модулю поиска, что таблица готова
	document.dispatchEvent(new CustomEvent('adminUsers:loaded'))

	// 5. Обработка кликов «Сохранить» / «Удалить»
	tbody.onclick = async e => {
		const btn = e.target.closest('button')
		if (!btn) return
		const tr = btn.closest('tr')
		const id = +btn.dataset.id
		if (!tr || !id) return

		// — Сохранить —
		if (btn.classList.contains('save-btn')) {
			const roleSelect = tr.querySelector('select.role-select')
			const groupSelect = tr.querySelector('select.group-select')
			const newRole = roleSelect.value
			const newGroup =
				groupSelect && groupSelect.value ? +groupSelect.value : null
			try {
				// обновляем роль
				const r1 = await fetch('/api/admin/users', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id, role: newRole }),
				})
				if (!r1.ok) {
					const t = await r1.text().catch(() => '')
					throw new Error(t || 'Не удалось обновить роль')
				}
				// обновляем группу для студентов
				if (newRole === 'student' && groupSelect) {
					const r2 = await fetch('/api/admin/student-groups', {
						method: 'PUT',
						credentials: 'include',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ student_id: id, group_id: newGroup }),
					})
					if (!r2.ok) {
						const t = await r2.text().catch(() => '')
						throw new Error(t || 'Не удалось обновить группу')
					}
					groupSelect.value = newGroup != null ? newGroup : ''
				}
				alert('Данные успешно сохранены')
			} catch (err) {
				console.error(err)
				alert(err.message)
			}
			return
		}

		// — Удалить —
		if (btn.classList.contains('del-btn')) {
			if (!confirm('Удалить пользователя?')) return
			try {
				const res = await fetch('/api/admin/users', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id }),
				})
				if (!res.ok) {
					const t = await res.text().catch(() => '')
					throw new Error(t || 'Не удалось удалить пользователя')
				}
				tr.remove()
			} catch (err) {
				console.error(err)
				alert('Ошибка удаления: ' + err.message)
			}
		}
	}
}

// Регистрируем поиск один раз, вне initUsers
// Запуск отрисовки списка
document.addEventListener('DOMContentLoaded', initUsers)

// -----------------------
// Управление курсами
// -----------------------
async function initCourses() {
	const tbody = document.getElementById('coursesBody')
	const form = document.getElementById('newCourseForm')

	// 1. Загружаем преподавателей (если ещё нет)
	if (!teachersCache.length) {
		await loadTeachers()
	}

	// 2. Заполняем селект в форме создания курса
	const teacherSelectInForm = form.querySelector('select[name="teacher_id"]')
	teacherSelectInForm.innerHTML = [
		`<option value="">-- выберите преподавателя --</option>`,
		...teachersCache.map(
			t => `<option value="${t.id}">${t.full_name}</option>`
		),
	].join('')

	// 3. Загрузка и рендер курсов
	try {
		const r = await fetch('/api/admin/courses', { credentials: 'include' })
		if (!r.ok) throw new Error('Курсы не загружены: ' + r.statusText)
		const arr = await r.json()

		tbody.innerHTML = ''
		arr.forEach(c => {
			const teacherOptions = [
				`<option value="">—</option>`,
				...teachersCache.map(
					t =>
						`<option value="${t.id}"${
							t.id === c.teacher_id ? ' selected' : ''
						}>${t.full_name}</option>`
				),
			].join('')

			const tr = document.createElement('tr')
			tr.innerHTML = `
		  <td><input class="edit-text" data-id="${c.id}" value="${c.title}"></td>
		  <td><input class="edit-desc" data-id="${c.id}" value="${c.description}"></td>
		  <td>
			<select class="edit-teacher" data-id="${c.id}">${teacherOptions}</select>
		  </td>
		  <td>${new Date(c.created_at).toLocaleDateString()}</td>
		  <td class="action-cell">
			<button class="save-course" data-id="${c.id}">Сохранить</button>
			<button class="del-course"  data-id="${c.id}">Удалить</button>
		  </td>`
			tbody.appendChild(tr)
		})

		// Сигнал о том, что курсы отрисованы
		document.dispatchEvent(new CustomEvent('adminCourses:loaded'))
	} catch (e) {
		console.error(e)
	}

	// 4. Обработчик создания
	form.addEventListener('submit', async e => {
		e.preventDefault()
		const fd = new FormData(form)
		const data = {
			title: fd.get('title'),
			description: fd.get('description'),
			teacher_id: fd.get('teacher_id') ? +fd.get('teacher_id') : null,
		}
		try {
			const res = await fetch('/api/admin/courses', {
				method: 'POST',
				credentials: 'include',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(data),
			})
			if (!res.ok) throw new Error(await res.text())
			const { id } = await res.json()
			alert('Курс создан, ID=' + id)
			await initCourses()
		} catch (err) {
			alert('Ошибка создания курса: ' + err.message)
		}
	})

	// 5. Делегирование кнопок
	tbody.addEventListener('click', async e => {
		const btn = e.target.closest('button')
		if (!btn) return
		const id = +btn.dataset.id
		if (!id) return

		if (btn.classList.contains('save-course')) {
			const inputs = document.querySelectorAll(
				`input.edit-text[data-id="${id}"]`
			)
			const title = inputs[0].value.trim()
			const desc = inputs[0].value.trim()
			const sel = document.querySelector(`select.edit-teacher[data-id="${id}"]`)
			const tid = sel.value ? +sel.value : null
			try {
				const res = await fetch('/api/admin/courses', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						id,
						title,
						description: desc,
						teacher_id: tid,
					}),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Курс обновлён')
			} catch (err) {
				alert('Ошибка: ' + err.message)
			}
		}

		if (btn.classList.contains('del-course')) {
			if (!confirm('Удалить курс?')) return
			try {
				const res = await fetch('/api/admin/courses', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id }),
				})
				if (!res.ok) throw new Error(await res.text())
				btn.closest('tr').remove()
				alert('Курс удалён')
			} catch (err) {
				alert('Ошибка: ' + err.message)
			}
		}
	})
}

// -----------------------
// Управление группами
// -----------------------

// -----------------------
// 1. Кэш преподавателей
// -----------------------
let teachersCache = []

// -----------------------
// 2. Загрузка преподавателей
// -----------------------
async function loadTeachers() {
	const res = await fetch('/api/admin/users', { credentials: 'include' })
	if (!res.ok) {
		alert('Не удалось загрузить список пользователей')
		return
	}
	const users = await res.json()
	// Оставляем только с ролью teacher
	teachersCache = users.filter(u => u.role === 'teacher')
}

// -----------------------
// 3. Инициализация формы создания
// -----------------------
function initCreateForm() {
	// (оставляем без изменений)
	const form = document.getElementById('newGroupForm')
	const select = form.querySelector('#newGroupTeacher')

	select.innerHTML = [
		`<option value="">Без преподавателя</option>`,
		...teachersCache.map(
			t => `<option value="${t.id}">${t.full_name}</option>`
		),
	].join('')

	form.addEventListener('submit', async e => {
		e.preventDefault()
		const name = form.name.value.trim()
		const teacherId = form.teacher.value || null

		if (!name) {
			alert('Введите название группы')
			return
		}

		try {
			const res = await fetch('/api/admin/groups', {
				method: 'POST',
				credentials: 'include',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					name,
					teacher_id: teacherId ? +teacherId : null,
				}),
			})
			if (!res.ok) throw new Error(await res.text())
			alert('Группа создана')
			form.reset()
			await renderGroupsTable()
		} catch (err) {
			alert('Ошибка создания группы: ' + err.message)
		}
	})
}

// -----------------------
// 4. Рендер таблицы групп
// -----------------------
async function renderGroupsTable() {
	// (оставляем без изменений)
	const res = await fetch('/api/admin/groups', { credentials: 'include' })
	if (!res.ok) {
		alert('Ошибка загрузки групп')
		return
	}
	const groups = await res.json()

	const tbody = document.getElementById('groupsBody')
	tbody.innerHTML = ''

	groups.forEach(g => {
		const teacherOptions = [
			`<option value="">—</option>`,
			...teachersCache.map(
				t =>
					`<option value="${t.id}"${t.id === g.teacher_id ? ' selected' : ''}>${
						t.full_name
					}</option>`
			),
		].join('')

		const tr = document.createElement('tr')
		tr.dataset.id = g.id
		tr.innerHTML = `
      <td>${g.id}</td>
      <td><input type="text" class="group-name" value="${g.name}" style="width:100%"></td>
      <td><select class="group-teacher" style="width:100%">${teacherOptions}</select></td>
      <td class="action-cell">
        <button class="save-group" title="Сохранить">Сохранить</button>
        <button class="del-group"  title="Удалить">Удалить</button>
      </td>
    `
		tbody.appendChild(tr)
	})
	document.dispatchEvent(new CustomEvent('adminGroups:loaded'))
}

// -----------------------
// 5. Делегирование действий
// -----------------------
function initTableActions() {
	// (оставляем без изменений)
	document.getElementById('groupsBody').addEventListener('click', async e => {
		const btn = e.target.closest('button')
		const tr = e.target.closest('tr')
		if (!btn || !tr) return
		const id = +tr.dataset.id

		if (btn.classList.contains('save-group')) {
			const name = tr.querySelector('.group-name').value.trim()
			const teacherId = tr.querySelector('.group-teacher').value || null
			if (!name) {
				alert('Название не может быть пустым')
				return
			}
			try {
				const res = await fetch('/api/admin/groups', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						id,
						name,
						teacher_id: teacherId ? +teacherId : null,
					}),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Изменения сохранены')
				await renderGroupsTable()
			} catch (err) {
				alert('Ошибка сохранения: ' + err.message)
			}
		}

		if (btn.classList.contains('del-group')) {
			if (!confirm('Вы уверены, что хотите удалить эту группу?')) return
			try {
				const res = await fetch('/api/admin/groups', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id }),
				})
				if (!res.ok) throw new Error(await res.text())
				tr.remove()
			} catch (err) {
				alert('Ошибка удаления: ' + err.message)
			}
		}
	})
}

document.addEventListener('DOMContentLoaded', () => {
	// 4.1. Активная ссылка
	const path = window.location.pathname.split('/').pop()
	document.querySelectorAll('.nav-links a').forEach(link => {
		link.classList.toggle('active', link.getAttribute('href') === path)
	})

	// 4.2. Тема
	const stored = localStorage.getItem('theme')
	const dark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (dark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)
	document.getElementById('theme-toggle').onclick = () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	}
	loadUserIcon()
	////////////////////////
	;(async () => {
		try {
			await loadTeachers()
			initCreateForm()
			await renderGroupsTable()
			initTableActions()
		} catch (err) {
			//alert(err.message)
		}
	})()

	// 4.3. Определяем текущую страницу и запускаем нужный модуль
	if (document.getElementById('usersBody')) initUsers()
	if (document.getElementById('coursesBody')) initCourses()
	if (document.getElementById('groupsBody')) renderGroupsTable()
})

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\style.css
/* === RESET & VARIABLES === */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}
:root {
	/* light theme */
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}
body {
	font-family: 'Inter', sans-serif;
	background: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background 0.5s ease, color 0.5s ease;
}

/* === NAVBAR === */
.navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	background: var(--card-bg);
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
}
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}
.nav-links {
	display: flex;
	gap: var(--sp-md);
}
.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	padding: var(--sp-xs) 0;
	transition: color var(--trans);
}
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	cursor: pointer;
	font-size: 1.25rem;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* === PAGE CONTENT === */
.page-content {
	max-width: 1400px;
	margin: var(--sp-lg) auto;
	padding: 0 var(--sp-md);
}
.page-content h1 {
	margin-bottom: var(--sp-md);
	color: var(--primary);
	transition: color var(--trans);
}
.page-content h2 {
	margin-bottom: var(--sp-sm);
}

/* === DASHBOARD TILES (index.html) === */
.tiles {
	display: flex;
	flex-wrap: wrap;
	gap: var(--sp-md);
	margin-top: var(--sp-lg);
}
.card {
	flex: 1 1 30%;
	background: var(--primary);
	color: var(--bg);
	text-decoration: none;
	border-radius: var(--radius);
	padding: var(--sp-lg) var(--sp-md);
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: var(--sp-sm);
	font-size: 1.1rem;
	transition: background var(--trans);
}
.card i {
	font-size: 2rem;
}
.card:hover {
	background: #3c3bd1;
}

/* === FORM GRID (new course) === */
.course-form {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)) auto;
	gap: var(--sp-sm);
	margin-top: var(--sp-md);
	align-items: end;
}
.course-form input,
.course-form select {
	padding: var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	color: var(--text);
	transition: border-color var(--trans);
}
.course-form input:focus,
.course-form select:focus {
	outline: none;
	border-color: var(--primary);
}
.course-form button {
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}
.course-form button:hover {
	opacity: 0.9;
}

/* === TABLE WRAPPER & TABLE STYLES === */
.table-wrapper {
	margin-top: var(--sp-md);
	overflow-x: auto;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}
.table-wrapper table {
	width: 100%;
	min-width: 700px;
	border-collapse: collapse;
	table-layout: auto;
}
.table-wrapper th,
.table-wrapper td {
	padding: var(--sp-sm) var(--sp-md);
	text-align: left;
	white-space: nowrap;
}
.table-wrapper thead {
	background: var(--primary);
}
.table-wrapper thead th {
	color: var(--bg);
	font-weight: 600;
}
.table-wrapper thead th:first-child {
	border-top-left-radius: var(--radius);
}
.table-wrapper thead th:last-child {
	border-top-right-radius: var(--radius);
}
.table-wrapper tbody tr:nth-child(odd) {
	background: var(--bg);
}
.table-wrapper tbody tr:nth-child(even) {
	background: var(--border);
}
.table-wrapper tbody tr:hover {
	background: rgba(79, 70, 229, 0.1);
}
.table-wrapper tbody tr:last-child td:first-child {
	border-bottom-left-radius: var(--radius);
}
.table-wrapper tbody tr:last-child td:last-child {
	border-bottom-right-radius: var(--radius);
}

/* === EDITABLE FIELDS === */
input.edit-text,
input.edit-desc,
input.edit-teacher {
	width: 100%;
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	color: var(--text);
	transition: border-color var(--trans);
}
input.edit-text:focus,
input.edit-desc:focus,
input.edit-teacher:focus {
	outline: none;
	border-color: var(--primary);
	box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
}

/* === CRUD BUTTONS === */

.action-cell {
	display: flex;
	flex-direction: column; /* укладываем элементы сверху вниз */
	align-items: stretch; /* растягиваем кнопки по ширине ячейки */
	gap: 4px; /* небольшое расстояние между кнопками */
}

/* Опционально: чтобы кнопки выглядели чуть крупнее */
.action-cell .btn {
	padding: 6px 12px;
	font-size: 14px;
}

button.save-course,
button.save-btn,
.table-wrapper button.save-group {
	background: transparent;
	color: green;
	border: 2px solid green;
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}
button.save-btn:hover,
button.save-course:hover,
.table-wrapper button.save-group:hover {
	background-color: green;
	color: white;
}
button.del-btn,
button.del-course,
.table-wrapper button.del-group {
	background: transparent;
	border: 2px solid rgb(173, 4, 4);
	color: rgb(173, 4, 4);
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}
button.del-btn:hover,
button.del-course:hover,
.table-wrapper button.del-group:hover {
	background-color: rgb(173, 4, 4);
	color: white;
}

/* === SELECT (roles) === */
.table-wrapper select {
	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
	padding: var(--sp-xs) var(--sp-lg) var(--sp-xs) var(--sp-sm);
	font-size: 0.95rem;
	line-height: 1.3;
	background: var(--card-bg);
	color: var(--text);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	cursor: pointer;
	transition: border-color var(--trans), box-shadow var(--trans);
	background-image: url("data:image/svg+xml,%3Csvg width='10' height='6'%3E%3Cpath d='M0 0l5 6l5-6' stroke='%23999' stroke-width='1.2'/%3E%3C/svg%3E");
	background-repeat: no-repeat;
	background-position: right var(--sp-sm) center;
	background-size: 0.6em;
}
.table-wrapper select:focus {
	outline: none;
	border-color: var(--primary);
	box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
}

/* === MOBILE ADJUSTMENTS === */
@media (max-width: 600px) {
	.tiles {
		flex-direction: column;
	}
	.table-wrapper,
	.course-form {
		overflow-x: auto;
	}
	.nav-links {
		flex-direction: column;
		gap: var(--sp-xs);
	}
}

.muted {
	color: #aaa;
	font-style: italic;
	text-align: center;
	display: block; /* Чтобы text-align работал внутри <td> */
}

/* Форма создания группы */
.inline-form {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: var(--sp-md);
	margin-bottom: var(--sp-md);
}

.inline-form input[type='text'],
.inline-form select {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid #ccc;
	border-radius: var(--radius);
	font-size: 1rem;
	font-family: inherit;
	outline: none;
	transition: border-color var(--trans);
}

.inline-form input[type='text']:focus,
.inline-form select:focus {
	border-color: var(--primary);
}

.inline-form button[type='submit'] {
	display: flex;
	align-items: center;
	gap: 0.5ch;
	padding: var(--sp-xs) var(--sp-md);
	background: var(--primary);
	color: #fff;
	border: none;
	border-radius: var(--radius);
	font-size: 1rem;
	cursor: pointer;
	transition: background var(--trans);
}

.inline-form button[type='submit']:hover {
	background: rgba(79, 70, 229, 0.8);
}

/* Инлайн-редактирование в таблице */
.table-wrapper input.group-name,
.table-wrapper select.group-teacher {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid #ddd;
	border-radius: var(--radius);
	font-size: 0.95rem;
	width: 100%;
	box-sizing: border-box;
	outline: none;
	transition: border-color var(--trans);
}

.table-wrapper input.group-name:focus,
.table-wrapper select.group-teacher:focus {
	border-color: var(--primary);
}

/* Если нужно, добавить отступы для иконок */
.table-wrapper button i {
	pointer-events: none;
}

button {
	background: transparent; /* без заливки */
	border: 2px solid currentColor; /* рамка цветом текста */
	border-radius: var(--radius); /* скруглённые углы */
	padding: var(--sp-xs) var(--sp-sm);
	cursor: pointer;
	font-size: 1rem;
	transition: background var(--trans), color var(--trans);
}

/* Для кнопок формы создания */
.inline-form button[type='submit'] {
	color: var(--bg);
}

/* Hover: слегка заливать фоном */
button:hover {
	background: opacity(0.8);
	color: #fff;
}

.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 1rem auto;
}

#admin-user-search,
#admin-group-search {
	width: 100%;
	padding: 0.5rem 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}

.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75rem;
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	color: #666;
	display: none;
}

#admin-user-suggestions,
#admin-group-suggestions {
	position: absolute;
	top: calc(100% + 2px);
	left: 0;
	right: 0;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	margin: 0;
	padding: 0;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
	z-index: 10;
}

#admin-user-suggestions li,
#admin-group-suggestions li {
	padding: 0.5rem 1rem;
	cursor: pointer;
}

#admin-user-suggestions li:hover,
#admin-user-suggestions li.active,
#admin-group-suggestions li:hover,
#admin-group-suggestions li.active {
	background: rgba(79, 70, 229, 0.1);
}

#admin-user-suggestions li mark,
#admin-group-suggestions li mark {
	background-color: yellow;
	padding: 0;
	border-radius: 2px;
}

#admin-course-search,
#admin-group-search {
	width: 100%;
	padding: 0.5rem 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}

#admin-course-suggestions,
#admin-group-suggestions {
	position: absolute;
	top: calc(100% + 2px);
	left: 0;
	right: 0;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	padding: 0;
	margin: 0;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
	z-index: 10;
}
#admin-course-suggestions li,
#admin-group-suggestions li {
	padding: 0.5rem 1rem;
	cursor: pointer;
}
#admin-course-suggestions li:hover,
#admin-course-suggestions li.active,
#admin-group-suggestions li:hover,
#admin-group-suggestions li.active {
	background: rgba(79, 70, 229, 0.1);
}
#admin-course-suggestions li mark,
#admin-group-suggestions li mark {
	background-color: yellow;
	padding: 0;
	border-radius: 2px;
}

Файл: C:\dev\projects\html\Курсовая работа\static\adminPanel\users.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Управление пользователями — Админ‑панель</title>
		<script src="/static/js/theme-init.js"></script>
		<link rel="stylesheet" href="/static/adminPanel/style.css" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<script src="/static/adminPanel/script.js" defer></script>
		<script src="/static/adminPanel/adminUserSearch.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="index.html">Панель админа</a>
				<a href="users.html" class="active">Пользователи</a>
				<a href="courses.html">Курсы</a>
				<a href="groups.html">Группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="user" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Управление пользователями</h1>
			<div class="search-wrapper">
				<input
					id="admin-user-search"
					type="text"
					placeholder="Поиск пользователя…"
					aria-autocomplete="list"
					aria-controls="admin-user-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="admin-user-suggestions" role="listbox"></ul>
			</div>

			<div class="table-wrapper">
				<table id="usersTable">
					<thead>
						<tr>
							<th>Email</th>
							<th>ФИО</th>
							<th>Роль</th>
							<th>Активен</th>
							<!-- <th>Последний вход</th> -->
							<th>Группа</th>
							<th>Действия</th>
						</tr>
					</thead>
					<tbody id="usersBody"></tbody>
				</table>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\coursePage\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Курс — Set Learn</title>

		<!-- Инициализация темы -->
		<script src="/static/js/theme-init.js"></script>
		<link rel="stylesheet" href="style.css" />
		<script src="script.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="/static/courses/">Курсы</a>
				<a href="/static/coursePage/" class="active">курс</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
					>Панель админа</a
				>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefaultImg" />
				</div>
			</div>
		</header>

		<main class="page-container">
			<h1 id="course-title">Загрузка...</h1>
			<section id="theory-section">
				<h2>Теория</h2>
				<div class="cards-list" id="theory-list">Загрузка теории...</div>
			</section>
			<section id="tests-section">
				<h2>Тесты</h2>
				<div class="cards-list" id="tests-list">Загрузка тестов...</div>
			</section>
		</main>

		<!-- Начало попытки -->
		<div id="startAttemptModal" class="modal-overlay" style="display: none">
			<div class="modal-content">
				<h3 id="startAttemptTitle">У вас есть X попытки</h3>
				<div class="modal-footer">
					<button id="btnStartAttempt">Начать</button>
					<button id="btnCancelStart">Отмена</button>
				</div>
			</div>
		</div>

		<!-- Результат попытки -->
		<div id="finishAttemptModal" class="modal-overlay" style="display: none">
			<div class="modal-content">
				<h3 id="finishAttemptTitle">Вы набрали N баллов</h3>
				<p id="finishAttemptMsg"></p>
				<div class="modal-footer">
					<button id="btnConfirmFinish">Завершить</button>
					<button id="btnRetryAttempt">Пройти заново</button>
				</div>
			</div>
		</div>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\coursePage\script.js
function navigate(url) {
	window.location.href = url
}

function getCourseId() {
	const params = new URLSearchParams(window.location.search)
	return params.get('course') || params.get('id')
}

function getToken() {
	const match = document.cookie.match(/token=([^;]+)/)
	return match ? match[1] : ''
}

// ✅ Безопасное добавление заголовка Authorization
function authHeaders() {
	const token = getToken()
	return token ? { Authorization: `Bearer ${token}` } : {}
}

async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', {
			credentials: 'same-origin',
			headers: authHeaders(),
		})
		if (!res.ok) return null
		const user = await res.json()
		if (user.avatar_path) {
			document.querySelector('.user-icon img').src = user.avatar_path
		}
		if (user.role === 'admin') {
			document.getElementById('nav-admin').style.display = 'inline-block'
		}
		if (user.role === 'teacher') {
			document.getElementById('nav-teacher').style.display = 'inline-block'
		}
		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = ''
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

function initThemeToggle() {
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)
	const toggle = document.getElementById('theme-toggle')
	if (toggle) {
		toggle.addEventListener('click', () => {
			const next =
				document.documentElement.getAttribute('data-theme') === 'dark'
					? 'light'
					: 'dark'
			document.documentElement.setAttribute('data-theme', next)
			localStorage.setItem('theme', next)
			updateToggleIcon(next)
		})
	}
}

async function fetchCourses() {
	const res = await fetch('/api/courses', { credentials: 'same-origin' })
	if (!res.ok) throw new Error(`Ошибка ${res.status}`)
	return await res.json()
}

async function fetchLatestAttempt(testId) {
	const res = await fetch(`/api/tests/${testId}/attempts/latest`, {
		credentials: 'same-origin',
		headers: authHeaders(),
	})
	console.log(`fetchLatestAttempt(${testId}) → status`, res.status)

	if (res.status === 204) {
		console.log(`  → нет завершённых попыток`)
		return null
	}
	if (!res.ok) {
		console.warn(`  → ошибка запроса: ${res.status}`)
		return null
	}

	// Если 200 OK — читаем тело
	const data = await res.json()
	console.log(`  → тело ответа:`, data)

	// Маппим snake_case → camelCase
	const latest = {
		score: data.score,
		attemptNumber: data.attempt_number ?? data.attemptNumber,
	}
	console.log(`  → mapped latest:`, latest)
	return latest
}

async function loadCoursePage() {
	const courseId = getCourseId()
	if (!courseId) return

	const titleElem = document.getElementById('course-title')
	titleElem.textContent = 'Загрузка курса…'

	try {
		const courses = await fetchCourses() // грузим все курсы
		const course = courses.find(c => String(c.id) === String(courseId)) // ищем нужный
		if (course) {
			titleElem.textContent = course.title
		} else {
			titleElem.textContent = 'Курс #' + courseId
		}
	} catch (err) {
		console.error('Ошибка загрузки курсов:', err)
		titleElem.textContent = 'Курс #' + courseId
	}

	await loadTheory(courseId)
	await loadTests(courseId)
}

let currentAttempt = null // { attemptId, attemptNumber, startedAt, answers:{ [q]:true/false } }
const MAX_ATTEMPTS = 2

async function loadTheory(courseId) {
	const container = document.getElementById('theory-list')
	container.textContent = 'Загрузка теории...'

	try {
		const res = await fetch(`/api/courses/${courseId}/theory`, {
			credentials: 'same-origin',
			headers: authHeaders(),
		})
		if (!res.ok) throw new Error(`Status ${res.status}`)

		const data = await res.json()
		container.innerHTML = ''

		data.forEach(item => {
			const div = document.createElement('div')
			div.className = 'card'

			// 1. Удаляем HTML-теги и преобразуем HTML-сущности
			const tempDiv = document.createElement('div')
			tempDiv.innerHTML = item.content
			let textContent = tempDiv.textContent || tempDiv.innerText || ''

			// 2. Очистка и обрезка текста
			textContent = textContent
				.replace(/\s+/g, ' ') // Заменяем множественные пробелы
				.trim()

			// 3. Умная обрезка до 40 символов
			const preview =
				textContent.length > 40
					? textContent.substring(0, 40).split(' ').slice(0, -1).join(' ') +
					  '...'
					: textContent

			div.innerHTML = `
                <h3>${item.title}</h3>
                ${textContent ? `<p>${preview}</p>` : ''}
                <button onclick="navigate('/static/theory/index.html?topic=${
									item.id
								}')">
                    Читать
                </button>
            `
			container.appendChild(div)
		})
	} catch (err) {
		console.error('loadTheory error:', err)
		container.textContent = 'Ошибка при загрузке теории'
	}
}

async function loadTests(courseId) {
	const container = document.getElementById('tests-list')
	container.textContent = 'Загрузка тестов…'

	try {
		const res = await fetch(`/api/courses/${courseId}/tests`, {
			credentials: 'same-origin',
			headers: authHeaders(),
		})
		if (!res.ok) throw new Error(`Status ${res.status}`)
		const tests = await res.json()

		container.innerHTML = ''
		if (!tests.length) {
			container.textContent = 'Тестов пока нет.'
			return
		}

		for (const test of tests) {
			// 1) Сколько попыток сделано
			let done = await getAttemptsDone(test.id)
			// 2) Последняя завершённая попытка (или null)
			const latest = await fetchLatestAttempt(test.id)
			const remaining = MAX_ATTEMPTS - (latest?.attemptNumber || 0)

			// 3) Рендер карточки
			const card = document.createElement('div')
			card.className = 'card test-card'

			const title = document.createElement('h3')
			title.textContent = test.title
			card.appendChild(title)

			if (test.description) {
				const desc = document.createElement('p')
				desc.textContent = test.description
				card.appendChild(desc)
			}

			const infoCount = document.createElement('div')
			infoCount.className = 'info'
			infoCount.textContent = `Вопросов: ${test.question_count}`
			card.appendChild(infoCount)

			if (test.created_at) {
				const infoDate = document.createElement('div')
				infoDate.className = 'info'
				infoDate.textContent = `Создано: ${new Date(
					test.created_at
				).toLocaleDateString()}`
				card.appendChild(infoDate)
			}

			console.log(`Test ${test.id}: done=${done}, latest=`, latest)

			// 4) Кнопка «Пройти тест»
			const btn = document.createElement('button')
			btn.textContent = 'Пройти тест'
			btn.setAttribute('data-test-id', test.id)

			if (remaining <= 0) {
				btn.classList.add('muted')
				btn.addEventListener('click', () => onClickStart(test.id, remaining))
			} else {
				btn.addEventListener('click', () => onClickStart(test.id, remaining))
			}
			card.appendChild(btn)

			// 5) Если есть результаты — плашка с баллами
			if (latest) {
				const status = document.createElement('div')
				status.className = 'status'
				status.textContent = `Пройден: ${latest.score} баллов`
				card.appendChild(status)
			}

			container.appendChild(card)
		}
	} catch (err) {
		console.error('❌ Ошибка при загрузке тестов:', err)
		container.textContent = 'Ошибка при загрузке тестов'
	}
}

async function onClickStart(testId) {
	// получаем сколько осталось
	const latest = await fetchLatestAttempt(testId)
	const remaining = MAX_ATTEMPTS - (latest?.attemptNumber || 0)

	const titleEl = document.getElementById('startAttemptTitle')
	const btnStart = document.getElementById('btnStartAttempt')

	if (remaining <= 0) {
		// исчерпаны попытки
		titleEl.textContent = `Вы истратили обе попытки`
		btnStart.disabled = true
		btnStart.classList.add('muted')
	} else {
		// остались попытки
		titleEl.textContent = `У вас есть ${remaining} попытк${
			remaining === 1 ? 'а' : 'и'
		}`
		btnStart.disabled = false
		btnStart.classList.remove('muted')

		btnStart.onclick = async () => {
			closeModal('startAttemptModal')
			const { attemptId, attemptNumber } = await createAttempt(testId)
			currentAttempt = {
				attemptId,
				attemptNumber,
				startedAt: Date.now(),
				answers: {},
				courseId: getCourseId(),
				testId,
			}
			saveState()
			navigate(
				`/static/questions/index.html?test=${testId}&course=${getCourseId()}`
			)
		}
	}

	// Показываем модалку всегда
	showModal('startAttemptModal')

	// Привязываем отмену
	document.getElementById('btnCancelStart').onclick = () =>
		closeModal('startAttemptModal')
}

// ----- API: Работа с попытками -----
async function getAttemptsDone(testId) {
	const res = await fetch(`/api/tests/${testId}/attempts/count`, {
		credentials: 'include', // ← ключевой момент
	})
	if (!res.ok) throw new Error(`Ошибка ${res.status}`)
	return (await res.json()).attemptsDone
}

async function createAttempt(testId) {
	const res = await fetch(`/api/tests/${testId}/attempts`, {
		method: 'POST',
		credentials: 'include',
	})
	if (!res.ok) throw new Error(`Не удалось создать попытку: ${res.status}`)
	return await res.json()
}

async function finishAttempt(attemptId, score, correct, wrong) {
	const res = await fetch(`/api/attempts/${attemptId}/finish`, {
		method: 'PATCH',
		credentials: 'include', // ← обязательно
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({
			score,
			correct_answers: correct,
			wrong_answers: wrong,
		}),
	})
	if (!res.ok) throw new Error(`Не удалось завершить попытку: ${res.status}`)
	return await res.json()
}

function saveState() {
	localStorage.setItem('currentAttempt', JSON.stringify(currentAttempt))
}
function loadState() {
	const raw = localStorage.getItem('currentAttempt')
	currentAttempt = raw ? JSON.parse(raw) : null
}
function clearState() {
	localStorage.removeItem('currentAttempt')
	currentAttempt = null
}

function showModal(id) {
	const overlay = document.getElementById(id)
	overlay.style.display = 'flex'

	// Закрытие по клику вне .modal-content
	overlay.onclick = e => {
		if (e.target === overlay) closeModal(id)
	}
}
function closeModal(id) {
	document.getElementById(id).style.display = 'none'
}

document.addEventListener('DOMContentLoaded', () => {
	initThemeToggle()
	loadUserIcon()
	loadCoursePage()
})

Файл: C:\dev\projects\html\Курсовая работа\static\coursePage\style.css
/* RESET & VARIABLES */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}

:root {
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

body {
	font-family: 'Inter', sans-serif;
	line-height: 1.6;
	background: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background 0.5s ease, color 0.5s ease;
}

/* NAVBAR */
.navbar {
	display: flex; /* флекс-контейнер */
	justify-content: space-between;
	align-items: center;
	background-color: var(--card-bg); /* фон навбара */
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0; /* всегда сверху */
	z-index: 100;
	transition: background-color 0.5s ease;
}

/* Логотип */
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}

/* Ссылки меню */
.nav-links {
	display: flex;
	gap: var(--sp-md);
}

.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	padding: var(--sp-xxs) 0;
	transition: color var(--trans);
}

/* Активная ссылка и при наведении */
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background-color: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	cursor: pointer;
	font-size: 1.25rem;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* Содержимое страницы кроме navbar */
.page-container {
	max-width: 960px;
	margin: 0 auto;
	padding: var(--sp-md);
}

/* Заголовок */
#course-title {
	text-align: center;
	margin: var(--sp-lg) 0;
	font-size: 2rem;
	font-weight: 600;
}

/* Локальный для coursePage */
.cards-list {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
	gap: var(--sp-md);
	margin-bottom: var(--sp-lg);
}
.card {
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	transition: transform var(--trans);
}
.card:hover {
	transform: translateY(-3px);
}
.card h3 {
	margin-bottom: var(--sp-sm);
	font-size: 1.1rem;
	color: var(--text);
}
.card p {
	flex-grow: 1;
	color: var(--text-muted);
	margin-bottom: var(--sp-sm);
}
.card button {
	align-self: flex-end;
	padding: var(--sp-xs) var(--sp-md);
	background: var(--primary);
	color: #fff;
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: filter var(--trans);
}
.card button:hover {
	filter: brightness(0.9);
}

.card button.muted {
	opacity: 0.5;
	cursor: not-allowed;
	border: 2px solid var(--text-muted);
	border-color: var(--text-muted);
	color: var(--text-muted);
	background: none;
}

/* Дополнительный отступ для тест‑карточек */
.test-card {
	display: flex;
	flex-direction: column;
}
.card.info {
	font-size: 0.9rem;
	color: var(--text-muted);
	margin-bottom: var(--sp-sm);
}

.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1000;
}
.modal-content {
	background: var(--bg);
	color: var(--text);
	padding: 1.5rem;
	border-radius: 0.5rem;
	max-width: 90%;
	width: 400px;
}
.modal-footer {
	margin-top: 1rem;
	text-align: right;
}
.modal-footer button {
	margin-left: 0.5rem;
	padding: 0.5rem 1rem;
}

#btnStartAttempt {
	background: transparent;
	color: green;
	border: 2px solid green;
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
	text-align: center;
	display: inline-block;
}

#btnStartAttempt.muted {
	opacity: 0.5;
	cursor: not-allowed;
	pointer-events: none; /* отключает ховер и клики */
	border: 2px solid var(--text-muted);
	border-color: var(--text-muted);
	color: var(--text-muted);
	background: none;
}

#btnStartAttempt:hover {
	background-color: green;
	color: white;
}

#btnCancelStart {
	background: transparent;
	border: 2px solid rgb(173, 4, 4);
	color: rgb(173, 4, 4);
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
	text-align: center;
	display: inline-block;
}

#btnCancelStart:hover {
	background-color: rgb(173, 4, 4);
	color: white;
}

.status {
	margin-top: 0.75rem;
	padding: 0.4rem 0.8rem;
	background-color: #e6f4ea;
	color: #237b4b;
	font-weight: 500;
	font-size: 0.95rem;
	border: 1px solid #b3dec7;
	border-radius: 6px;
	display: inline-block;
}

Файл: C:\dev\projects\html\Курсовая работа\static\courses\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Курсы — Set Learn</title>

		<!-- 1. Инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<!-- Общие стили и скрипт с поддержкой темы -->
		<link rel="stylesheet" href="style.css" />
		<script src="script.js" defer></script>
	</head>
	<body>
		<!-- Навигационная панель -->
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="/static/courses/" class="active">Курсы</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
					>Панель админа</a
				>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefaultImg" />
				</div>
			</div>
		</header>

		<!-- Основной контент страницы Курсы -->

		<!-- поисковик -->
		<div class="search-wrapper">
			<input
				id="course-search"
				type="text"
				placeholder="Поиск курса…"
				aria-autocomplete="list"
				aria-controls="suggestions"
			/>
			<ul id="suggestions" role="listbox"></ul>
		</div>

		<main class="page-content">
			<h1></h1>
			<div class="courses-list">Загрузка курсов...</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\courses\script.js
/* -----------------------
   1. Функция навигации
------------------------ */
function navigate(url) {
	// Перенаправляет браузер на указанный URL
	window.location.href = url
}

/* -----------------------
   2. Подгрузка аватарки в навбар
   (теперь возвращает объект user)
------------------------ */
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null // не залогинен или другая ошибка
		const user = await res.json()

		if (user.avatar_path) {
			const navImg = document.querySelector('.user-icon img')
			if (navImg) navImg.src = user.avatar_path
		}

		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

/* -----------------------
   3. Обновление иконки темы
------------------------ */
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return

	// Очищаем содержимое кнопки
	btn.innerHTML = ''

	// Создаём элемент изображения
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'

	// Устанавливаем путь к изображению в зависимости от темы
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'

	// Добавляем изображение в кнопку
	btn.appendChild(icon)
}

function filterCourses(courses, query) {
	const q = query.trim().toLowerCase()
	if (!q) return []

	// 1. Фразовое совпадение: заголовок === запрос
	const exact = courses.filter(c => c.title.toLowerCase() === q)
	if (exact.length) {
		return exact
	}

	// 2. Фильтрация по includes (любая подстрока)
	const bySubstring = courses.filter(
		c =>
			c.title.toLowerCase().includes(q) ||
			(c.description || '').toLowerCase().includes(q) ||
			(c.tags || []).join(' ').toLowerCase().includes(q)
	)
	if (bySubstring.length) {
		return bySubstring
	}

	// 3. Нечёткий (fuzzy) поиск

	function fuzzyMatch(text) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}
	return courses.filter(
		c =>
			fuzzyMatch(c.title.toLowerCase()) ||
			fuzzyMatch((c.description || '').toLowerCase())
	)

	// 4. Если ничего не нашло
	return []
}

/* -----------------------
   Утилита Debounce
------------------------ */
function debounce(fn, delay = 300) {
	let timer
	return function (...args) {
		clearTimeout(timer)
		timer = setTimeout(() => fn.apply(this, args), delay)
	}
}

/* -----------------------
   Загрузка и поиск курсов с сервером и ARIA
------------------------ */
async function loadCourses() {
	const container = document.querySelector('.courses-list')
	const searchInput = document.getElementById('course-search')
	const suggestions = document.getElementById('suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	let currentIdx = -1
	let expanded = false
	const VISIBLE_COUNT = 4
	let allCourses = []
	let filteredCourses = []

	// ——— кнопка очистки поиска ———
	const clearBtn = document.createElement('button')
	clearBtn.type = 'button'
	clearBtn.className = 'clear-search'
	clearBtn.textContent = '×'
	searchInput.insertAdjacentElement('afterend', clearBtn)
	clearBtn.addEventListener('click', () => {
		searchInput.value = ''
		suggestions.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		resetSearch()
	})

	// ——— рендер одной карточки курса ———
	function renderCard(course) {
		const card = document.createElement('div')
		card.className = 'course-card'
		card.innerHTML = `
		<h2>${course.title}</h2>
		<p>${course.description}</p>
		<div class="info">Тестов: ${course.test_count}</div>
		<button onclick="navigate('/static/coursePage/index.html?course=${course.id}')">
		  Открыть
		</button>
	  `
		container.appendChild(card)
	}

	// ——— рендер списка и подстройка кнопки ———
	function renderCourses() {
		container.innerHTML = ''
		const list = expanded
			? filteredCourses
			: filteredCourses.slice(0, VISIBLE_COUNT)
		list.forEach(renderCard)

		const btn = document.getElementById('toggle-courses')
		if (filteredCourses.length > VISIBLE_COUNT) {
			btn.style.display = 'block'
			btn.textContent = expanded ? 'Свернуть' : 'Показать больше'
		} else {
			btn.style.display = 'none'
		}
	}

	// ——— загрузка всех курсов ———
	async function fetchCourses() {
		const res = await fetch('/api/courses', { credentials: 'same-origin' })
		if (!res.ok) throw new Error(`Ошибка ${res.status}`)
		return await res.json()
	}

	// ——— сброс поиска ———
	function resetSearch() {
		filteredCourses = allCourses
		expanded = false
		renderCourses()
	}

	// ——— локальный поиск ———
	function applySearch(text) {
		const q = text.trim()
		if (!q) return resetSearch()

		const results = filterCourses(allCourses, q)
		if (results.length) {
			filteredCourses = results
			expanded = true
			renderCourses()
		} else {
			container.innerHTML = '<p>К сожалению такого курса нет.</p>'
			document.getElementById('toggle-courses').style.display = 'none'
		}
	}

	// ——— подсказки ———
	function updateSuggestions(text) {
		suggestions.innerHTML = ''
		if (!text) {
			wrapper.setAttribute('aria-expanded', 'false')
			return
		}
		const matches = filterCourses(allCourses, text).slice(0, 10)
		matches.forEach((course, i) => {
			const li = document.createElement('li')
			li.setAttribute('role', 'option')
			li.id = `suggestion-${i}`
			const re = new RegExp(`(${text})`, 'i')
			li.innerHTML = course.title.replace(re, '<mark>$1</mark>')
			suggestions.appendChild(li)
		})
		currentIdx = -1
		wrapper.setAttribute('aria-expanded', 'true')
	}

	function highlight(items) {
		items.forEach((li, idx) => {
			li.classList.toggle('active', idx === currentIdx)
			li.setAttribute('aria-selected', idx === currentIdx)
			if (idx === currentIdx) {
				searchInput.setAttribute('aria-activedescendant', li.id)
			}
		})
	}

	const debouncedSuggest = debounce(text => updateSuggestions(text), 300)

	// ——— обработчики клавиш ———
	searchInput.addEventListener('keydown', e => {
		const items = suggestions.querySelectorAll('li')
		if (e.key === 'ArrowDown') {
			e.preventDefault()
			if (!items.length) return
			currentIdx = Math.min(currentIdx + 1, items.length - 1)
			highlight(items)
		} else if (e.key === 'ArrowUp') {
			e.preventDefault()
			if (!items.length) return
			currentIdx = Math.max(currentIdx - 1, 0)
			highlight(items)
		} else if (e.key === 'Escape') {
			suggestions.innerHTML = ''
			currentIdx = -1
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Enter') {
			e.preventDefault()
			if (currentIdx >= 0 && items[currentIdx]) {
				const title = items[currentIdx].textContent
				searchInput.value = title
				suggestions.innerHTML = ''
				applySearch(title)
			} else if (!searchInput.value.trim()) {
				resetSearch()
			} else {
				applySearch(searchInput.value.trim())
			}
		}
	})

	suggestions.addEventListener('click', e => {
		if (e.target.tagName === 'LI') {
			const title = e.target.textContent
			searchInput.value = title
			suggestions.innerHTML = ''
			applySearch(title)
		}
	})

	searchInput.addEventListener('input', e => {
		const t = e.target.value.trim()
		if (!t) {
			suggestions.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			return
		}
		debouncedSuggest(t)
	})

	document.addEventListener('click', e => {
		if (!searchInput.contains(e.target) && !suggestions.contains(e.target)) {
			suggestions.innerHTML = ''
			currentIdx = -1
			wrapper.setAttribute('aria-expanded', 'false')
		}
	})

	// ——— кнопка "Показать больше" ———
	const toggleBtn = document.createElement('button')
	toggleBtn.id = 'toggle-courses'
	toggleBtn.className = 'toggle-courses-btn'
	toggleBtn.textContent = 'Показать больше'
	toggleBtn.addEventListener('click', () => {
		expanded = !expanded
		renderCourses()
	})
	// встраиваем кнопку сразу **после** контейнера с карточками
	container.insertAdjacentElement('afterend', toggleBtn)

	// ——— стартуем загрузку ———
	try {
		allCourses = await fetchCourses()
		filteredCourses = allCourses
		renderCourses()
	} catch (err) {
		container.innerHTML = `<p>Ошибка загрузки: ${err.message}</p>`
	}
}

document.addEventListener('DOMContentLoaded', () => {
	/* -----------------------
     4. Подсветка активной ссылки
  ------------------------ */
	const path = window.location.pathname
	document.querySelectorAll('.nav-links a').forEach(link => {
		link.classList.toggle('active', path.startsWith(link.getAttribute('href')))
	})

	/* -----------------------
     5. Инициализация темы
  ------------------------ */
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)

	/* -----------------------
     6. Переключатель темы
  ------------------------ */
	const toggle = document.getElementById('theme-toggle')
	if (toggle) {
		toggle.addEventListener('click', () => {
			const next =
				document.documentElement.getAttribute('data-theme') === 'dark'
					? 'light'
					: 'dark'
			document.documentElement.setAttribute('data-theme', next)
			localStorage.setItem('theme', next)
			updateToggleIcon(next)
		})
	}

	/* -----------------------
     7. Подгрузка аватарки и показа скрытой ссылки‑ссылки
  ------------------------ */
	loadUserIcon().then(user => {
		if (!user) return
		if (user.role === 'admin') {
			const adminTile = document.getElementById('nav-admin')
			if (adminTile) adminTile.style.display = 'flex'
		}
		if (user.role === 'teacher') {
			// 1) в навигации
			const navTeacher = document.getElementById('nav-teacher')
			if (navTeacher) navTeacher.style.display = 'inline-block'
			// 2) на главной странице-плитках
			const teacherTile = document.getElementById('go-to-teacher')
			if (teacherTile) teacherTile.style.display = 'flex'
		}
	})

	// загрузка курсов
	loadCourses()
})

Файл: C:\dev\projects\html\Курсовая работа\static\courses\style.css
/* RESET & VARIABLES */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}

:root {
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

body {
	font-family: 'Inter', sans-serif;
	line-height: 1.6;
	background: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background 0.5s ease, color 0.5s ease;
}

/* NAVBAR */
.navbar {
	display: flex; /* флекс-контейнер */
	justify-content: space-between;
	align-items: center;
	background-color: var(--card-bg); /* фон навбара */
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0; /* всегда сверху */
	z-index: 100;
	transition: background-color 0.5s ease;
}

.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}

/* Ссылки меню */
.nav-links {
	display: flex;
	gap: var(--sp-md);
}

.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	padding: var(--sp-xxs) 0;
	transition: color var(--trans);
}

/* Активная ссылка и при наведении */
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background-color: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	cursor: pointer;
	font-size: 1.25rem;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* PAGE CONTENT */
.page-content {
	max-width: 1200px;
	margin: var(--sp-lg) auto;
	padding: 0 var(--sp-md);
}
.page-content h1 {
	margin-bottom: var(--sp-md);
	color: var(--primary);
	transition: color 0.5s ease;
}

/* Курсы-карточки */
.courses-list {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
	gap: var(--sp-md);
}
.course-card {
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	transition: transform var(--trans);
}
.course-card:hover {
	transform: translateY(-4px);
}
.course-card h2 {
	font-size: 1.25rem;
	margin-bottom: var(--sp-sm);
}
.course-card p {
	flex-grow: 1;
	margin-bottom: var(--sp-sm);
	color: var(--text-muted);
}
.course-card .info {
	font-size: 0.9rem;
	margin-bottom: var(--sp-md);
	color: var(--text-muted);
}
.course-card button {
	padding: var(--sp-xs) var(--sp-md);
	background: var(--primary);
	color: #fff;
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	align-self: flex-end;
	transition: background var(--trans);
}
.course-card button:hover {
	/* background: darken(var(--primary), 10%); */
	filter: brightness(0.9);
}

/* Responsive */
@media (max-width: 600px) {
	.navbar {
		flex-direction: column;
		gap: var(--sp-xs);
	}
	.nav-links {
		flex-wrap: wrap;
		justify-content: center;
	}
	.page-content {
		padding: var(--sp-md);
	}
}

/* Адаптив: на узких экранах постепенно уменьшаем число колонок */
@media (max-width: 1200px) {
	.courses-list {
		grid-template-columns: repeat(3, 1fr);
	}
}
@media (max-width: 900px) {
	.courses-list {
		grid-template-columns: repeat(2, 1fr);
	}
}
@media (max-width: 600px) {
	.courses-list {
		grid-template-columns: 1fr;
	}
}

/* Основной стиль кнопки */
#toggle-courses {
	display: block; /* чтобы кнопка была по центру строки */
	margin: 1rem auto; /* отступ сверху/снизу + центрирование */
	padding: var(--sp-sm) var(--sp-md);
	background-color: var(--primary);
	color: #fff;
	border: none;
	border-radius: var(--radius);
	font-size: 1rem;
	font-weight: 500;
	text-align: center;
	cursor: pointer;
	transition: background-color var(--trans), transform var(--trans);
}

/* При наведении — чуть тёмнее фон */
#toggle-courses:hover {
	opacity: 0.8;
}

/* При фокусе — видимая рамка для accessibility */
#toggle-courses:focus {
	outline: 2px solid var(--primary-light);
	outline-offset: 2px;
}

/* При нажатии — лёгкое «вдавливание» */
#toggle-courses:active {
	transform: scale(0.97);
}

.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 0 auto;
}

/* поисковая строка */
#course-search {
	width: 100%;
	padding: 0.5rem 1rem;
	font-size: 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
	color: #1f2937;
}

#suggestions {
	position: absolute;
	top: 100%;
	left: 0;
	right: 0;
	background: white;
	border: 1px solid #ccc;
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	z-index: 10;
	list-style: none;
	margin: 0;
	padding: 0;
}

#suggestions li {
	padding: 8px 12px;
	cursor: pointer;
	color: #1f2937;
}
#suggestions li.active,
#suggestions li:hover {
	background-color: #f0f0ff;
}

.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75em; /* совпадает с правым padding */
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.2em;
	cursor: pointer;
	color: #666;
}

/* контейнер вокруг input должен быть position: relative */
.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 0 auto; /* по центру */
}

.search-wrapper input {
	width: 100%;
	padding: 0.5em 2.5em 0.5em 0.75em; /* справа место под крестик */
	box-sizing: border-box;
}

.clear-search:hover {
	color: #000;
}

Файл: C:\dev\projects\html\Курсовая работа\static\js\theme-init.js
let heartbeatId

// стартуем пинги каждые 10 сек после загрузки страницы
window.addEventListener('DOMContentLoaded', () => {
	const url = '/api/ping'
	heartbeatId = setInterval(() => {
		fetch(url, { method: 'POST', credentials: 'include' }).catch(() => {
			/* игнорируем ошибки */
		})
	}, 10_000)
})

// при закрытии вкладки/браузера очищаем таймер и шлём финальный пинг
window.addEventListener('unload', () => {
	clearInterval(heartbeatId)
	navigator.sendBeacon('/api/ping')
})
;(function () {
	// 1) Пробуем взять сохранённую тему
	var stored = localStorage.getItem('theme')
	// 2) Если нет, берём системную
	var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	var theme = stored || (prefersDark ? 'dark' : 'light')
	// 3) Сразу ставим атрибут на <html>
	document.documentElement.setAttribute('data-theme', theme)
})()

Файл: C:\dev\projects\html\Курсовая работа\static\leaderboard\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Пошаговая анимация — Set Learn</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<!-- Общие стили и скрипт с поддержкой светлой/тёмной темы -->
		<link rel="stylesheet" href="style.css" />
		<script src="script.js" defer></script>
	</head>
	<body>
		<!-- Навигация -->
		<header class="navbar">
			<!-- Логотип / название сайта -->
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<!-- Ссылки меню -->
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="/static/courses/">Курсы</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
				>
					Панель админа
				</a>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
				<a href="/static/leaderboard/" class="active">Лидерборд</a>
			</nav>
			<!-- Блок с дополнительными действиями -->
			<div class="actions">
				<!-- Кнопка переключения темы -->
				<button id="theme-toggle" aria-label="Переключить тему">
					<img src="/static/img/dark-theme.png" alt="dark-theme-toggle" />
				</button>
				<!-- Иконка пользователя -->
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefaultImg" />
				</div>
			</div>
		</header>

		<!-- Контент анимации -->
		<main class="page-content">
			<h1>Лидерборд</h1>
			<!-- Здесь разместите свой контейнер для анимации -->
			<div id="leaderboard-container">
				<!-- Ваша интерактивная анимация -->
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\leaderboard\script.js
/* -----------------------
   1. Функция навигации
------------------------ */
function navigate(url) {
	// Перенаправляет браузер на указанный URL
	window.location.href = url
}

/* -----------------------
   2. Подгрузка аватарки в навбар
   (возвращаем объект user!)  ←!
------------------------ */
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null // не залогинен или другая ошибка
		const user = await res.json()

		if (user.avatar_path) {
			const navImg = document.querySelector('.user-icon img')
			if (navImg) navImg.src = user.avatar_path
		}

		return user // ←! возвращаем для проверки роли
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null // ←! на ошибке тоже возвращаем null
	}
}

// Обновляет иконку темы
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	// Очищаем содержимое кнопки
	btn.innerHTML = ''

	// Создаём элемент изображения
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'

	// Устанавливаем путь к изображению в зависимости от темы
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'

	// Добавляем изображение в кнопку
	btn.appendChild(icon)
}

document.addEventListener('DOMContentLoaded', () => {
	// Подсветка активного пункта меню
	const path = window.location.pathname
	document.querySelectorAll('.nav-links a').forEach(link => {
		link.classList.toggle('active', path.startsWith(link.getAttribute('href')))
	})

	// Инициализация темы
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)

	// Обработчик переключения темы
	document.getElementById('theme-toggle').addEventListener('click', () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	})

	// --- показываем аватар и одновременно проверяем роль ---
	loadUserIcon().then(user => {
		if (!user) return
		if (user.role === 'admin') {
			const adminTile = document.getElementById('nav-admin')
			if (adminTile) adminTile.style.display = 'flex'
		}
		if (user.role === 'teacher') {
			// 1) в навигации
			const navTeacher = document.getElementById('nav-teacher')
			if (navTeacher) navTeacher.style.display = 'inline-block'
			// 2) на главной странице-плитках
			const teacherTile = document.getElementById('go-to-teacher')
			if (teacherTile) teacherTile.style.display = 'flex'
		}
	})

	// TODO: инициализация и запуск анимации в #animation-container
})

Файл: C:\dev\projects\html\Курсовая работа\static\leaderboard\style.css
/* RESET & VARIABLES */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}

:root {
	/* Светлая тема */
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;

	/* Отступы и радиус */
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	/* Тёмная тема */
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

body {
	font-family: 'Inter', sans-serif;
	line-height: 1.6;
	background-color: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background-color 0.5s ease, color 0.5s ease;
}

/* NAVBAR */
.navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	background-color: var(--card-bg);
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
	transition: background-color 0.5s ease;
}
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}
.nav-links {
	display: flex;
	gap: var(--sp-md);
}
.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	transition: color var(--trans);
}
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background-color: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* PAGE CONTENT */
.page-content {
	max-width: 800px;
	margin: var(--sp-md) auto;
	padding: 0 var(--sp-md);
}
.page-content h1 {
	margin-bottom: var(--sp-md);
	color: var(--primary);
	transition: color 0.5s ease;
}

/* Анимация-контейнер */
#leaderboard-container {
	background-color: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	transition: background-color 0.5s ease, border-color 0.5s ease;
	/* Задайте нужные размеры для вашей анимации */
	height: 400px;
}

/* RESPONSIVE */
@media (max-width: 600px) {
	.navbar {
		flex-direction: column;
		gap: var(--sp-xs);
	}
	.nav-links {
		flex-wrap: wrap;
		justify-content: center;
	}
	#animation-container {
		height: 300px;
	}
}

Файл: C:\dev\projects\html\Курсовая работа\static\loginPage\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Регистрация/Вход — Set Learn</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<!-- Стили и скрипт с поддержкой светлой/тёмной темы -->
		<link rel="stylesheet" href="style.css" />
		<!-- Font Awesome для иконок соцсетей -->
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<script src="script.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/welcomeMainPage/')">
				Set Learn
			</div>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему">
					<img src="/static/img/dark-theme.png" alt="dark-theme-toggle" />
				</button>
				<div class="user-icon" onclick="navigate('/profile')">
					<a href="#"><i class="fas fa-user"></i></a>
				</div>
			</div>
		</header>

		<div class="container" id="container">
			<!-- Регистрация -->
			<div class="form-container sign-up-container">
				<form id="registerForm">
					<h1>Создать аккаунт</h1>
					<!-- <div class="social-container">
						<a href="#" class="social"><i class="fab fa-facebook-f"></i></a>
						<a href="#" class="social"><i class="fab fa-google-plus-g"></i></a>
						<a href="#" class="social"><i class="fab fa-linkedin-in"></i></a>
					</div> -->
					<span>или используйте email для регистрации</span>
					<input type="text" name="name" placeholder="Имя" required />
					<input type="email" name="email" placeholder="Email" required />
					<input
						type="password"
						name="password"
						placeholder="Пароль"
						required
					/>
					<button type="submit">Зарегистрироваться</button>
				</form>
			</div>

			<!-- Вход -->
			<div class="form-container sign-in-container">
				<form id="loginForm">
					<h1>Войти</h1>
					<!-- <div class="social-container">
						<a href="#" class="social"><i class="fab fa-facebook-f"></i></a>
						<a href="#" class="social"><i class="fab fa-google-plus-g"></i></a>
						<a href="#" class="social"><i class="fab fa-linkedin-in"></i></a>
					</div> -->
					<span>или используйте ваш аккаунт</span>
					<input type="email" name="email" placeholder="Email" required />
					<input
						type="password"
						name="password"
						placeholder="Пароль"
						required
					/>
					<a href="#" class="forgot-password">Забыли пароль?</a>
					<button type="submit">Войти</button>
				</form>
			</div>

			<!-- Оверлей для переключения -->
			<div class="overlay-container">
				<div class="overlay">
					<div class="overlay-panel overlay-left">
						<h1>С возвращением!</h1>
						<p>Для входа используйте ваши данные</p>
						<button class="ghost" id="signIn">Войти</button>
					</div>
					<div class="overlay-panel overlay-right">
						<h1>Привет!</h1>
						<p>Зарегистрируйтесь для начала работы</p>
						<button class="ghost" id="signUp">Регистрация</button>
					</div>
				</div>
			</div>

			<!-- Мобильный переключатель -->
			<div class="mobile-switcher">
				<a href="#" id="mobileSwitchToSignIn">Уже есть аккаунт? Войти</a>
				<a href="#" id="mobileSwitchToSignUp"
					>Нет аккаунта? Зарегистрироваться</a
				>
			</div>
		</div>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\loginPage\script.js
// Навигация (если нужна)
function navigate(url) {
	window.location.href = url
}

/* -----------------------
   2. Подгрузка аватарки в навбар
------------------------ */
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return // не залогинен или другая ошибка
		const user = await res.json()

		if (user.avatar_path) {
			const navImg = document.querySelector('.user-icon img')
			if (navImg) navImg.src = user.avatar_path
		}
	} catch (err) {
		console.error('Error loading user icon:', err)
	}
}

// Обновление иконки темы
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	// Очищаем содержимое кнопки
	btn.innerHTML = ''

	// Создаём элемент изображения
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme' // Альтернативный текст для доступности

	// Устанавливаем путь к изображению в зависимости от темы
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'

	// Добавляем изображение в кнопку
	btn.appendChild(icon)
}

document.addEventListener('DOMContentLoaded', () => {
	// Инициализация темы
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)
	document.getElementById('theme-toggle').addEventListener('click', () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	})

	// Переключение панелей
	const container = document.getElementById('container')
	const signUpBtn = document.getElementById('signUp')
	const signInBtn = document.getElementById('signIn')
	const mobileIn = document.getElementById('mobileSwitchToSignIn')
	const mobileUp = document.getElementById('mobileSwitchToSignUp')

	function togglePanel(isSignUp) {
		container.classList.toggle('right-panel-active', isSignUp)
		updateMobileSwitcher()
	}
	function updateMobileSwitcher() {
		const active = container.classList.contains('right-panel-active')
		mobileIn.style.display = active ? 'inline-block' : 'none'
		mobileUp.style.display = active ? 'none' : 'inline-block'
	}
	signUpBtn.addEventListener('click', () => togglePanel(true))
	signInBtn.addEventListener('click', () => togglePanel(false))
	mobileIn.addEventListener('click', e => {
		e.preventDefault()
		togglePanel(false)
	})
	mobileUp.addEventListener('click', e => {
		e.preventDefault()
		togglePanel(true)
	})
	updateMobileSwitcher()

	// Формы регистрации
	document
		.getElementById('registerForm')
		.addEventListener('submit', async e => {
			e.preventDefault()
			const fd = new FormData(e.target)
			const data = {
				name: fd.get('name'),
				email: fd.get('email'),
				password: fd.get('password'),
			}
			try {
				const res = await fetch('/register', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(data),
				})
				if (res.ok) {
					alert('Успешно зарегистрированы')
					togglePanel(false)
				} else {
					alert('Ошибка: ' + (await res.text()))
				}
			} catch {
				alert('Ошибка подключения')
			}
		})

	// Форма входа: отправка с credentials и редирект по роли
	document.getElementById('loginForm').addEventListener('submit', async e => {
		e.preventDefault()
		const fd = new FormData(e.target)
		const data = {
			email: fd.get('email'),
			password: fd.get('password'),
		}
		try {
			const res = await fetch('/login', {
				method: 'POST',
				credentials: 'include', // важно: передать и получить JWT-куку
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(data),
			})
			if (!res.ok) {
				const text = await res.text()
				throw new Error(text || res.statusText)
			}
			const { role } = await res.json()
			// Редирект в зависимости от роли
			if (role === 'admin') {
				window.location.href = '/static/adminPanel/'
			} else if (role === 'teacher') {
				window.location.href = '/static/teacherPanel/html/'
			} else {
				window.location.href = '/static/mainPage/'
			}
		} catch (err) {
			alert('Ошибка входа: ' + err.message)
		}
	})

	loadUserIcon()
})

Файл: C:\dev\projects\html\Курсовая работа\static\loginPage\style.css
/* RESET & VARIABLES */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}
:root {
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #ff4b2b;
	--secondary: #ff416c;
	--text-muted: #6b7280;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 3rem;
	--radius: 0.5rem;
	--trans: 0.6s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #ff416c;
	--secondary: #ff4b2b;
	--text-muted: #a0aec0;
}

body {
	font-family: 'Inter', sans-serif;
	background: var(--bg);
	color: var(--text);
	height: 100vh;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: background 0.5s ease, color 0.5s ease;
}

/* NAVBAR */
.navbar {
	width: 100%;
	position: absolute;
	top: 0;
	display: flex;
	justify-content: space-between;
	align-items: center;
	background: var(--card-bg);
	padding: var(--sp-sm) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	transition: background 0.5s ease;
}
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}
.user-icon a {
	font-size: 1.5rem;
	color: var(--text-muted);
	transition: color var(--trans);
}
.user-icon a:hover {
	color: var(--primary);
}

/* CONTAINER */
.container {
	background: var(--card-bg);
	border-radius: var(--radius);
	box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
	position: relative;
	overflow: hidden;
	width: 1000px;
	max-width: 100%;
	min-height: 480px;
	transition: background 0.5s ease, color 0.5s ease;
}

/* FORM CONTAINERS */
.form-container {
	position: absolute;
	top: 0;
	height: 100%;
	transition: all 0.6s ease-in-out;
}
.sign-in-container {
	left: 0;
	width: 50%;
	z-index: 2;
}
.sign-up-container {
	left: 0;
	width: 50%;
	opacity: 0;
	z-index: 1;
}
.container.right-panel-active .sign-in-container {
	transform: translateX(100%);
}
.container.right-panel-active .sign-up-container {
	transform: translateX(100%);
	opacity: 1;
	z-index: 5;
	animation: show 0.6s;
}

@keyframes show {
	0%,
	49.99% {
		opacity: 0;
		z-index: 1;
	}
	50%,
	100% {
		opacity: 1;
		z-index: 5;
	}
}

/* OVERLAY */
.overlay-container {
	position: absolute;
	top: 0;
	left: 50%;
	width: 50%;
	height: 100%;
	overflow: hidden;
	transition: transform 0.6s ease-in-out;
	z-index: 100;
}
.container.right-panel-active .overlay-container {
	transform: translateX(-100%);
}
.overlay {
	background: linear-gradient(to right, var(--primary), var(--secondary));
	color: #fff;
	position: relative;
	left: -100%;
	height: 100%;
	width: 200%;
	transform: translateX(0);
	transition: transform 0.6s ease-in-out;
}
.container.right-panel-active .overlay {
	transform: translateX(50%);
}
.overlay-panel {
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	flex-direction: column;
	padding: 0 40px;
	text-align: center;
	top: 0;
	height: 100%;
	width: 50%;
	transition: transform 0.6s ease-in-out;
}
.overlay-left {
	transform: translateX(-20%);
}
.container.right-panel-active .overlay-left {
	transform: translateX(0);
}
.overlay-right {
	right: 0;
	transform: translateX(0);
}
.container.right-panel-active .overlay-right {
	transform: translateX(20%);
}

/* SOCIAL ICONS */
.social-container {
	margin: var(--sp-md) 0;
}
.social-container a {
	border: 1px solid var(--border);
	border-radius: 50%;
	display: inline-flex;
	justify-content: center;
	align-items: center;
	margin: 0 5px;
	height: 40px;
	width: 40px;
	color: var(--text);
	transition: color var(--trans), background var(--trans);
}
.social-container a:hover {
	background: var(--primary);
	color: #fff;
}

/* FORM ELEMENTS */
form {
	background: var(--card-bg);
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	text-align: center;
	height: 100%;
	padding: 0 var(--sp-md);
}
form h1 {
	margin-bottom: var(--sp-sm);
	color: var(--primary);
}
form input {
	background: var(--border);
	border: none;
	border-radius: var(--radius);
	padding: var(--sp-xs) var(--sp-sm);
	margin: 8px 0;
	width: 100%;
}
form span {
	font-size: 0.875rem;
}
form .forgot-password {
	font-size: 0.875rem;
	margin: var(--sp-xs) 0;
	color: var(--text-muted);
}

button {
	border-radius: var(--radius);
	border: none;
	padding: var(--sp-sm) var(--sp-lg);
	font-weight: bold;
	cursor: pointer;
	text-transform: uppercase;
	transition: transform 80ms ease-in;
}
button:active {
	transform: scale(0.95);
}
button.ghost {
	background: transparent;
	border: 1px solid #fff;
	color: #fff;
}

/* MOBILE SWITCHER */
.mobile-switcher {
	display: none;
	position: absolute;
	bottom: var(--sp-md);
	width: 100%;
	text-align: center;
	z-index: 1000;
}
.mobile-switcher a {
	font-size: 0.875rem;
	margin: 0 var(--sp-sm);
	color: var(--primary);
	text-decoration: none;
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	background: rgba(255, 255, 255, 0.9);
}
@media (max-width: 768px) {
	.container {
		width: 100%;
		height: 100vh;
		border-radius: 0;
		box-shadow: none;
	}
	.overlay-container {
		display: none;
	}
	.sign-in-container,
	.sign-up-container {
		width: 100%;
		left: 0;
	}
	.container.right-panel-active .sign-in-container {
		transform: translateX(100%);
	}
	.container.right-panel-active .sign-up-container {
		transform: translateX(0);
		opacity: 1;
		z-index: 5;
	}
	.mobile-switcher {
		display: block;
	}
}

Файл: C:\dev\projects\html\Курсовая работа\static\mainPage\index.html
<!-- mainPage -->
<!DOCTYPE html>
<html lang="ru">
	<head>
		<!-- Указываем кодировку и адаптивность -->
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<!-- Заголовок страницы в браузере -->
		<title>Главная — Set Learn</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<!-- Подключаем стили -->
		<link rel="stylesheet" href="style.css" />
		<!-- Подключаем скрипт (defer — дождётся загрузки DOM) -->
		<script src="script.js" defer></script>
	</head>
	<body>
		<!-- Навигационная панель -->
		<header class="navbar">
			<!-- Логотип / название сайта -->
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<!-- Ссылки меню -->
			<nav class="nav-links">
				<a href="/static/mainPage/" class="active">Главная</a>
				<a href="/static/courses/">Курсы</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
				>
					Панель админа
				</a>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
			</nav>
			<!-- Блок с дополнительными действиями -->
			<div class="actions">
				<!-- Кнопка переключения темы -->
				<button id="theme-toggle" aria-label="Переключить тему">
					<img src="/static/img/dark-theme.png" alt="dark-theme-toggle" />
				</button>
				<!-- Иконка пользователя -->
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefaultImg" />
				</div>
			</div>
		</header>

		<!-- Основной контент: сетка плиток -->
		<main class="container">
			<!-- Крупная плитка с анимацией -->
			<div
				class="tile big-tile"
				onclick="navigate('/static/stepByStepAnimation/')"
			>
				<h2>Пошаговая анимация</h2>
				<p>Интерактивная демонстрация ассоциативного свойства множеств</p>
			</div>
			<!-- Плитка с курсами -->
			<div class="tile courses-tile" onclick="navigate('/static/courses/')">
				<h2>Курсы</h2>
				<p>Курсы по темам, которые вы проходите на данный момент</p>
			</div>
			<!-- Плитка с тестами -->
			<!-- <div class="tile tests-tile" onclick="navigate('/static/questions/')">
				<h2>Тесты</h2>
				<p>Тесты, которые вам доступны на данный момент</p>
			</div> -->
			<!-- Плитка лидерборда -->
			<div
				class="tile leaderboard-tile"
				onclick="navigate('/static/leaderboard/')"
			>
				<h2>Таблица лидеров</h2>
			</div>
			<!-- Плитка с теорией -->
			<!-- <div class="tile theory-tile" onclick="navigate('/static/theory/')">
				<h2>Теория</h2>
			</div> -->
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\mainPage\script.js
// script.js

/* -----------------------
   0. Навигация
------------------------ */
function navigate(url) {
	window.location.href = url
}

/* -----------------------
   1. Обновление иконки темы
------------------------ */
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = ''
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

/* -----------------------
   2. Подгрузка аватарки в навбар
   и возврат объекта user
------------------------ */
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null // не залогинен или другая ошибка
		const user = await res.json()
		if (user.avatar_path) {
			const img = document.querySelector('.user-icon img')
			if (img) img.src = user.avatar_path
		}
		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

/* -----------------------
   3. Показ ссылок в навигации
   для админа и учителя
------------------------ */
async function showRoleLinksIfNeeded() {
	const user = await loadUserIcon()
	if (!user) return
	if (user.role === 'admin') {
		const a = document.getElementById('nav-admin')
		if (a) a.style.display = 'inline-block'
	}
	if (user.role === 'teacher') {
		const t = document.getElementById('nav-teacher')
		if (t) t.style.display = 'inline-block'
	}
}

document.addEventListener('DOMContentLoaded', () => {
	/* --------------------
       4. Активная ссылка
  --------------------- */
	const path = window.location.pathname
	document.querySelectorAll('.nav-links a').forEach(link => {
		link.classList.toggle('active', path.startsWith(link.getAttribute('href')))
	})

	/* --------------------
       5. Тема
  --------------------- */
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)

	const toggle = document.getElementById('theme-toggle')
	if (toggle) {
		toggle.addEventListener('click', () => {
			const next =
				document.documentElement.getAttribute('data-theme') === 'dark'
					? 'light'
					: 'dark'
			document.documentElement.setAttribute('data-theme', next)
			localStorage.setItem('theme', next)
			updateToggleIcon(next)
		})
	}

	/* --------------------
       6. Показ nav‑ссылок
  --------------------- */
	showRoleLinksIfNeeded()
})

Файл: C:\dev\projects\html\Курсовая работа\static\mainPage\style.css
/* style.css */

/* -----------------------------
   1. Сброс отступов и box-sizing
   ----------------------------- */
*,
*::before,
*::after {
	box-sizing: border-box; /* единая модель расчёта размеров */
	margin: 0; /* сброс внешних отступов */
	padding: 0; /* сброс внутренних отступов */
}

/* =================================
   2. Базовые настройки страницы
   ================================= */
html {
	font-size: 16px; /* базовый размер шрифта */
	scroll-behavior: smooth; /* плавный скролл по якорям */
}

body {
	font-family: 'Inter', sans-serif; /* основной шрифт */
	line-height: 1.6; /* межстрочный интервал */
	background-color: var(--bg); /* фон из переменных */
	color: var(--text); /* цвет текста из переменных */
	min-height: 100vh; /* минимум высоты экрана */
	transition: background-color 0.5s ease, color 0.5s ease; /* плавная смена темы */
}

/* =================================
   3. Переменные для тем и отступов
   ================================= */
:root {
	/* Светлая тема */
	--bg: #f9fafb; /* фон страницы */
	--text: #1f2937; /* основной текст */
	--card-bg: #ffffff; /* фон карточек */
	--border: #e5e7eb; /* цвет границ */
	--primary: #4f46e5; /* основной акцент */
	--text-muted: #6b7280; /* вспомогательный текст */

	/* Отступы */
	--sp-xxs: 0.25rem;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;

	/* Скругления и переходы */
	--radius: 0.5rem;
	--trans: 0.3s ease;
}

/* Тёмная тема (перекрывает переменные) */
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

/* =================================
   4. Стили для навигационной панели
   ================================= */
.navbar {
	display: flex; /* флекс-контейнер */
	justify-content: space-between;
	align-items: center;
	background-color: var(--card-bg); /* фон навбара */
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0; /* всегда сверху */
	z-index: 100;
	transition: background-color 0.5s ease;
}

/* Логотип */
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}

/* Ссылки меню */
.nav-links {
	display: flex;
	gap: var(--sp-md);
}

.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	padding: var(--sp-xxs) 0;
	transition: color var(--trans);
}

/* Активная ссылка и при наведении */
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background-color: var(--primary);
}

/* Блок действий */
.actions {
	display: flex;
	align-items: center;
}

/* Кнопка переключения темы */
#theme-toggle {
	background: none;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}

/* Иконка пользователя */
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* =================================
   5. Сетка плиток (main.container)
   ================================= */
.container {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
	grid-auto-rows: 200px;
	gap: var(--sp-md);
	padding: var(--sp-md);
}

/* =================================
   6. Стили плиток .tile
   ================================= */
.tile {
	background-color: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	cursor: pointer;
	transition: transform var(--trans), box-shadow var(--trans),
		background-color 0.5s ease, border-color 0.5s ease;
}
.tile:hover {
	transform: translateY(-4px);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Заголовок внутри плитки */
.tile h2 {
	color: var(--primary);
}
.tile p {
	color: var(--text-muted);
}

/* «одноцветная» тема для всех плиток */
.big-tile,
.courses-tile,
.tests-tile,
.leaderboard-tile,
.theory-tile {
	background-color: var(--card-bg);
	border-color: var(--border);
	color: var(--text);
}

/* =================================
   7. Адаптив для мобилок
   ================================= */
@media (max-width: 600px) {
	.navbar {
		flex-direction: column;
		gap: var(--sp-xs);
	}
	.nav-links {
		flex-wrap: wrap;
		justify-content: center;
	}
	.container {
		grid-auto-rows: 180px;
	}
}

Файл: C:\dev\projects\html\Курсовая работа\static\profile\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Личный кабинет — Set Learn</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<link rel="stylesheet" href="/static/profile/style.css" />
		<script src="/static/profile/script.js" defer></script>
	</head>
	<body>
		<!-- Единое верхнее меню -->
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="/static/courses/">Курсы</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
				>
					Панель админа
				</a>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefaultImg" />
				</div>
			</div>
		</header>

		<!-- Новый контейнер для аватарки + имени -->
		<div class="avatar-profile">
			<div class="avatar-wrapper">
				<img id="avatar" src="/static/uploads/default.png" alt="Avatar" />
				<img
					id="change-icon"
					class="change-icon"
					src="/static/img/change-icon-img.png"
					alt="Change"
				/>
				<button
					id="remove-avatar-btn"
					class="remove-avatar-btn"
					title="Удалить аватар"
				>
					✕
				</button>
				<input
					id="avatar-input"
					type="file"
					accept="image/*"
					style="display: none"
				/>
			</div>
			<!-- сюда JS будет записывать имя -->
			<div class="avatar-info">
				<span id="avatar-username" class="avatar-username"></span>
				<!-- разделитель -->
				<hr class="avatar-separator" />
				<!-- блок для роли -->
				<span id="avatar-role" class="avatar-role"></span>
			</div>
		</div>

		<!-- Подтверждающий попап на удаление фотки профиля -->
		<div id="confirm-modal" class="modal-overlay">
			<div class="modal">
				<p>Вы действительно хотите удалить фото?</p>
				<div class="modal-actions">
					<button id="confirm-yes" class="btn btn-primary">Да</button>
					<button id="confirm-no" class="btn btn-secondary">Нет</button>
				</div>
			</div>
		</div>

		<main class="profile-container">
			<div class="profile-section">
				<!-- заголовок‑тогглер -->
				<button id="profile-toggle" class="profile-toggle" type="button">
					<span>Личные данные</span>
					<span class="profile-toggle-icon">➕</span>
				</button>

				<!-- сам контент, по умолчанию скрыт -->
				<div id="profile-details" class="profile-details">
					<div class="profile-card">
						<p><strong>Имя:</strong> <span id="fullName"></span></p>
						<p><strong>Email:</strong> <span id="email"></span></p>
						<p><strong>Роль:</strong> <span id="role"></span></p>
						<p><strong>Группа:</strong> <span id="group">—</span></p>
						<p><strong>Активен:</strong> <span id="isActive"></span></p>
						<p><strong>Создан:</strong> <span id="createdAt"></span></p>
						<p><strong>Последний вход:</strong> <span id="lastLogin"></span></p>
					</div>
				</div>
				<div class="profile-logout">
					<button id="logout-btn" class="logout-btn">Выйти</button>
				</div>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\profile\script.js
/* -----------------------
   0. Функция навигации
------------------------ */
function navigate(url) {
	window.location.href = url
}

/* -----------------------
   1. Обновление иконки темы
------------------------ */
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = ''
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

/* -----------------------
   2. Подгрузка аватарки в навбар
   (возвращает объект user)
------------------------ */
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null // не залогинен или другая ошибка
		const user = await res.json()
		if (user.avatar_path) {
			const navImg = document.querySelector('.user-icon img')
			if (navImg) navImg.src = user.avatar_path
		}
		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

/* -----------------------
   3. Загрузка данных профиля
   + показ ссылки "Панель админа"
------------------------ */
async function loadProfile() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (res.status === 401) {
			window.location.href = '/'
			return
		}
		if (!res.ok) {
			console.error('Failed to fetch profile:', res.status, res.statusText)
			return
		}

		const user = await res.json()
		const setText = (id, text) => {
			const el = document.getElementById(id)
			if (el) el.textContent = text
		}

		// Имя и роль в блоке аватарки
		const avatarNameEl = document.getElementById('avatar-username')
		if (avatarNameEl) avatarNameEl.textContent = user.full_name

		const avatarRoleEl = document.getElementById('avatar-role')
		if (avatarRoleEl) {
			avatarRoleEl.textContent = user.role || ''
			avatarRoleEl.classList.remove('student', 'teacher', 'admin')
			avatarRoleEl.classList.add(user.role.toLowerCase())
		}

		// Остальные базовые поля
		setText('fullName', user.full_name)
		setText('email', user.email)
		setText('role', user.role)

		// Логика для отображения группы
		const groupEl = document.getElementById('group')
		if (groupEl) {
			// если студент и есть непустое поле user.group — показываем его
			if (user.role === 'student' && user.group) {
				groupEl.textContent = user.group
			} else {
				// во всех остальных случаях — прочерк
				groupEl.textContent = '—'
			}
		}

		// Онлайн / последний визит
		const isActiveEl = document.getElementById('isActive')
		if (isActiveEl) {
			if (user.is_active) {
				isActiveEl.textContent = 'в сети'
			} else {
				const dt = new Date(user.last_login)
				const now = new Date()
				const two = n => String(n).padStart(2, '0')
				const hhmm = `${two(dt.getHours())}:${two(dt.getMinutes())}`

				const isToday = dt.toDateString() === now.toDateString()
				const yesterday = new Date(now)
				yesterday.setDate(now.getDate() - 1)
				const isYesterday = dt.toDateString() === yesterday.toDateString()

				let text
				if (isToday) {
					text = `был(а) сегодня в ${hhmm}`
				} else if (isYesterday) {
					text = `был(а) вчера в ${hhmm}`
				} else {
					const monthNames = [
						'янв.',
						'фев.',
						'мар.',
						'апр.',
						'май',
						'июн.',
						'июл.',
						'авг.',
						'сен.',
						'окт.',
						'ноя.',
						'дек.',
					]
					text = `был(а) ${dt.getDate()} ${monthNames[dt.getMonth()]} в ${hhmm}`
				}
				isActiveEl.textContent = text
			}
		}

		// Даты создания и последнего входа
		setText('createdAt', new Date(user.created_at).toLocaleString())
		setText('lastLogin', new Date(user.last_login).toLocaleString())

		// Локальный превью аватара, если есть
		const avatarEl = document.getElementById('avatar')
		if (avatarEl && user.avatar_path) {
			avatarEl.src = user.avatar_path
		}

		// Показ ссылки "Панель админа" для админа
		if (user.role === 'admin') {
			const adminLink = document.getElementById('nav-admin')
			if (adminLink) adminLink.style.display = 'inline-block'
		}
		if (user.role === 'teacher') {
			const teacherLink = document.getElementById('nav-teacher')
			if (teacherLink) teacherLink.style.display = 'inline-block'
		}
	} catch (err) {
		console.error('Error loading profile:', err)
	}
}

/* -----------------------
   4. DOMContentLoaded
------------------------ */
document.addEventListener('DOMContentLoaded', () => {
	// A) Подсветка активной ссылки
	const path = window.location.pathname
	document
		.querySelectorAll('.nav-links a')
		.forEach(link =>
			link.classList.toggle(
				'active',
				path.startsWith(link.getAttribute('href'))
			)
		)

	// B) Инициализация темы
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)

	// C) Переключатель темы
	const toggle = document.getElementById('theme-toggle')
	if (toggle) {
		toggle.addEventListener('click', () => {
			const next =
				document.documentElement.getAttribute('data-theme') === 'dark'
					? 'light'
					: 'dark'
			document.documentElement.setAttribute('data-theme', next)
			localStorage.setItem('theme', next)
			updateToggleIcon(next)
		})
	}

	// D) Загрузка профиля
	loadProfile()

	// accordion для личных данных
	const toggleBtn = document.getElementById('profile-toggle')
	const details = document.getElementById('profile-details')
	const icon = toggleBtn.querySelector('.profile-toggle-icon')

	toggleBtn.addEventListener('click', () => {
		const isOpen = toggleBtn.classList.contains('open')

		if (isOpen) {
			// сворачиваем
			details.style.height = details.scrollHeight + 'px' // текущая высота
			requestAnimationFrame(() => {
				details.style.height = '0'
			})
			toggleBtn.classList.remove('open')
			icon.textContent = '➕'
		} else {
			// разворачиваем
			toggleBtn.classList.add('open')
			// сначала даём деталям максимально возможную высоту
			details.style.height = details.scrollHeight + 'px'
			icon.textContent = '➖'
			// после окончания анимации — убираем жёсткую высоту, чтобы контент мог расти
			details.addEventListener('transitionend', function handler() {
				details.style.height = 'auto'
				details.removeEventListener('transitionend', handler)
			})
		}
	})

	// E) Смена аватара
	const changeIcon = document.getElementById('change-icon')
	const avatarInput = document.getElementById('avatar-input')
	const avatarImg = document.getElementById('avatar')
	if (changeIcon && avatarInput && avatarImg) {
		changeIcon.addEventListener('click', () => avatarInput.click())
		avatarInput.addEventListener('change', () => {
			const file = avatarInput.files[0]
			if (!file) return
			// локальное превью сразу
			avatarImg.src = URL.createObjectURL(file)
			// отправляем на сервер
			const fd = new FormData()
			fd.append('avatar', file)
			fetch('/api/upload-avatar', {
				method: 'POST',
				body: fd,
				credentials: 'same-origin',
			})
				.then(res => res.json())
				.then(data => {
					if (data.url) avatarImg.src = data.url
				})
				.catch(err => console.error('Upload error:', err))
		})
	}

	// F) Подтверждающий попап удаления аватарки
	const removeBtn = document.getElementById('remove-avatar-btn')
	const modal = document.getElementById('confirm-modal')
	const yesBtn = document.getElementById('confirm-yes')
	const noBtn = document.getElementById('confirm-no')
	if (removeBtn && modal && yesBtn && noBtn && avatarImg) {
		// Показать окно
		removeBtn.addEventListener('click', () => {
			modal.classList.add('show')
		})

		// Отмена удаления
		noBtn.addEventListener('click', () => {
			modal.classList.remove('show')
		})

		// Подтверждение удаления
		yesBtn.addEventListener('click', () => {
			fetch('/api/remove-avatar', {
				method: 'POST',
				credentials: 'same-origin',
			})
				.then(res => res.json())
				.then(data => {
					if (data.url) {
						avatarImg.src = data.url
					}
				})
				.catch(err => console.error('Remove avatar error:', err))
				.finally(() => {
					modal.classList.remove('show')
				})
		})

		// Закрыть попап кликом по оверлею
		modal.addEventListener('click', e => {
			if (e.target === modal) {
				modal.classList.remove('show')
			}
		})
	}

	// G) Кнопка выхода
	const logoutBtn = document.getElementById('logout-btn')
	if (logoutBtn) {
		logoutBtn.addEventListener('click', () => {
			window.location.href = '/logout'
		})
	}

	loadUserIcon()
})

Файл: C:\dev\projects\html\Курсовая работа\static\profile\style.css
/* -----------------------------
   1. Сброс отступов и box-sizing
----------------------------- */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

/* =================================
   2. Базовые настройки страницы
================================= */
html {
	font-size: 16px;
	scroll-behavior: smooth;
}

body {
	font-family: 'Inter', sans-serif;
	line-height: 1.6;
	background-color: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background-color 0.5s ease, color 0.5s ease;
}

/* =================================
   3. Переменные для тем и отступов
================================= */
:root {
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;

	--sp-xxs: 0.25rem;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;

	--radius: 0.5rem;
	--trans: 0.3s ease;
}

:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

/* =================================
   4. Стили для навигационной панели
================================= */
.navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	background-color: var(--card-bg);
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
	transition: background-color 0.5s ease;
}

.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}

.nav-links {
	display: flex;
	gap: var(--sp-md);
}

.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	padding: var(--sp-xxs) 0;
	transition: color var(--trans);
}

.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background-color: var(--primary);
}

.actions {
	display: flex;
	align-items: center;
}

#theme-toggle {
	background: none;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}

.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* =================================
   5. Стили профиля
================================= */
.avatar-wrapper {
	position: relative;
	width: 120px;
	height: 120px;
	margin: 30px auto 0; /* 50px сверху, по центру, 0 снизу */
}
.avatar-wrapper img#avatar {
	width: 100%;
	height: 100%;
	object-fit: cover;
	border-radius: 50%;
	border: 2px solid var(--border);
	transition: border-color var(--trans);
}
.avatar-wrapper img#avatar:hover {
	border-color: var(--primary);
}

.avatar-profile {
	display: flex;
	flex-direction: column; /* вот это ключевое */
	align-items: center; /* центрируем по горизонтали */
	gap: var(--sp-sm); /* расстояние между аватаркой и именем */
	margin: var(--sp-lg) auto; /* верхний отступ и авт. центр по ширине */
	max-width: 600px; /* если нужно в рамках карточки */
}

/* Сам текст имени */
.avatar-username {
	font-size: 1.25rem;
	font-weight: 600;
	color: var(--text);
}

/* тонкая линия‑разделитель под именем */
.avatar-separator {
	width: 60%; /* длина линии — 60% от ширины родителя */
	border: none;
	border-bottom: 1px solid var(--border);
	margin: var(--sp-xs) auto; /* вертикальные отступы и центрирование */
}

/* текст роли пользователя */
.avatar-role {
	display: block;
	font-size: 1rem;
	color: var(--text-muted);
	text-align: center; /* по центру под линией */
	margin-top: var(--sp-xxs);
}

/* Цвета ролей */
.avatar-role.student {
	color: var(--text-muted);
}

.avatar-role.teacher {
	color: #10b981; /* зелёный (пример: Tailwind green-500) */
}

.avatar-role.admin {
	color: var(--primary);
}

/* Иконка «карандашика» для смены фото */
.change-icon {
	position: absolute;
	bottom: 0;
	right: 0;
	width: 32px;
	height: 32px;
	cursor: pointer;
	transition: transform var(--trans);
}
.change-icon:hover {
	transform: scale(1.1);
}

/* Кнопка удаления фотки профиля */
.remove-avatar-btn {
	position: absolute;
	bottom: 0;
	left: 0;
	border: none;
	background: var(--border);
	color: var(--text);
	width: 24px;
	height: 24px;
	border-radius: 4px;
	cursor: pointer;
	font-size: 14px;
}
.remove-avatar-btn:hover {
	background: var(--primary);
	color: #fff;
}

/* ===== Подтверждающий модал ===== */
.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.4);
	display: none; /* по умолчанию скрыт */
	align-items: center;
	justify-content: center;
	z-index: 1000;
	transition: opacity var(--trans);
}
.modal-overlay.show {
	display: flex;
	opacity: 1;
}

.modal {
	background: var(--card-bg);
	color: var(--text);
	padding: var(--sp-lg);
	border-radius: var(--radius);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
	max-width: 320px;
	text-align: center;
}

.modal p {
	margin-bottom: var(--sp-md);
}

.modal-actions {
	display: flex;
	justify-content: center;
	gap: var(--sp-md);
}

.modal .btn {
	padding: var(--sp-xs) var(--sp-md);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	font-weight: 500;
}
.btn-primary {
	background: var(--primary);
	color: #fff;
}
.btn-primary:hover {
	opacity: 0.9;
}
.btn-secondary {
	background: var(--border);
	color: var(--text);
}
.btn-secondary:hover {
	background: var(--primary);
	color: #fff;
}

.profile-container {
	max-width: 600px;
	margin: 2rem auto;
	padding: var(--sp-md);
}

.profile-card {
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.profile-card p {
	margin-bottom: var(--sp-sm);
}

.profile-logout {
	text-align: center;
	margin-top: var(--sp-lg);
}

.logout-btn {
	background-color: var(--primary);
	color: #fff;
	font-size: 1rem;
	padding: var(--sp-xs) var(--sp-md);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: transform var(--trans), opacity var(--trans);
}
.logout-btn:hover {
	transform: scale(1.02);
	opacity: 0.9;
}

/* контейнер‑аккордеон */
.profile-section {
	max-width: 600px;
	margin: var(--sp-lg) auto;
}

/* кнопка‑заголовок */
.profile-toggle {
	width: 100%;
	background: var(--card-bg);
	color: var(--text);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-sm) var(--sp-md);
	display: flex;
	align-items: center;
	justify-content: space-between;
	font-weight: 600;
	cursor: pointer;
	transition: background-color var(--trans), border-color var(--trans);
}
.profile-toggle:hover {
	background-color: var(--bg);
}

/* иконка внутри кнопки */
.profile-toggle-icon {
	display: inline-block;
	transition: transform var(--trans);
}

/* контейнер с деталями */
.profile-details {
	overflow: hidden;
	height: 0;
	transition: height 0.35s ease;
}

/* =================================
   6. Адаптив для мобильных
================================= */
@media (max-width: 600px) {
	.navbar {
		flex-direction: column;
		gap: var(--sp-xs);
	}
	.nav-links {
		flex-wrap: wrap;
		justify-content: center;
	}
}

Файл: C:\dev\projects\html\Курсовая работа\static\questions\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Тест — Set Learn</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>
		<!-- 2. Стили -->
		<link rel="stylesheet" href="style.css" />
		<!-- 3. Скрипт страницы -->
		<script src="script.js" defer></script>
	</head>
	<body>
		<!-- Навигационная панель -->
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="/static/courses/">Курсы</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
					>Панель админа</a
				>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
				<a href="index.html" class="active">Тест</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefaultImg" />
				</div>
			</div>
		</header>

		<!-- Контент страницы -->
		<div class="page-content">
			<!-- <h1 id="test-title">Загрузка теста...</h1> -->
			<form id="quiz">
				<!-- Вопросы вставятся динамически -->
			</form>
			<button type="button" id="check">Проверить</button>
		</div>

		<!-- Результат попытки -->
		<div id="finishAttemptModal" class="modal-overlay" style="display: none">
			<div class="modal-content">
				<!-- Крестик закрытия -->
				<button
					class="modal-close"
					aria-label="Закрыть"
					id="closeFinishAttempt"
				>
					×
				</button>
				<!-- Заголовок с баллами -->
				<h3 id="finishAttemptTitle">Вы набрали N баллов</h3>
				<!-- Сообщение про оставшиеся попытки -->
				<p id="finishAttemptMsg"></p>
				<!-- Кнопки действия -->
				<div class="modal-footer">
					<button id="btnConfirmFinish">Завершить</button>
					<button id="btnRetryAttempt">Пройти заново</button>
				</div>
			</div>
		</div>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\questions\script.js
// Навигация
function navigate(url) {
	window.location.href = url
}

// Обновление иконки темы
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = ''
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

// Инициализация темы
function initTheme() {
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)
	document.getElementById('theme-toggle').addEventListener('click', () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	})
}

// Подгрузка аватарки и ролей
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null
		const user = await res.json()
		if (user.avatar_path) {
			const navImg = document.querySelector('.user-icon img')
			if (navImg) navImg.src = user.avatar_path
		}
		if (user.role === 'admin') {
			document.getElementById('nav-admin').style.display = 'flex'
		}
		if (user.role === 'teacher') {
			document.getElementById('nav-teacher').style.display = 'inline-block'
		}
		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

function levenshtein(a, b) {
	const an = a.length
	const bn = b.length
	if (an === 0) return bn
	if (bn === 0) return an

	const matrix = []

	for (let i = 0; i <= bn; i++) {
		matrix[i] = [i]
	}
	for (let j = 0; j <= an; j++) {
		matrix[0][j] = j
	}

	for (let i = 1; i <= bn; i++) {
		for (let j = 1; j <= an; j++) {
			if (b.charAt(i - 1) === a.charAt(j - 1)) {
				matrix[i][j] = matrix[i - 1][j - 1]
			} else {
				matrix[i][j] = Math.min(
					matrix[i - 1][j - 1] + 1, // замена
					matrix[i][j - 1] + 1, // вставка
					matrix[i - 1][j] + 1 // удаление
				)
			}
		}
	}

	return matrix[bn][an]
}

function compareTextAnswers(userInput, correct, threshold = 80) {
	const u = userInput.trim().toLowerCase()
	const c = correct.trim().toLowerCase()
	if (!c) return false
	const distance = levenshtein(u, c)
	const maxLen = Math.max(u.length, c.length)
	const similarity = (1 - distance / maxLen) * 100
	return similarity >= threshold
}

// Показать popup с результатом
function showPopup(score, total) {
	const overlay = document.getElementById('popupOverlay')
	document.getElementById(
		'popupResult'
	).textContent = `Вы набрали ${score} из ${total}.`
	document.getElementById('progressFill').style.width = `${
		(score / total) * 100
	}%`
	overlay.classList.add('active')
}
function closePopup() {
	document.getElementById('popupOverlay').classList.remove('active')
}

async function createAttempt(testId) {
	const res = await fetch(`/api/tests/${testId}/attempts`, {
		method: 'POST',
		credentials: 'include',
	})
	if (!res.ok) throw new Error(`Не удалось создать попытку: ${res.status}`)
	return await res.json()
}

// Отправка одного ответа на бэкенд
async function submitAnswer(attemptId, questionId, isCorrect) {
	await fetch('/api/student/answer', {
		method: 'POST',
		credentials: 'same-origin',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({
			attempt_id: attemptId,
			question_id: questionId,
			is_correct: isCorrect,
		}),
	})
}

// Основная логика
document.addEventListener('DOMContentLoaded', async () => {
	initTheme()
	await loadUserIcon()

	const params = new URLSearchParams(location.search)
	const testId = params.get('test')
	const courseId = params.get('course')

	if (!testId || !courseId) {
		document.getElementById('quiz').textContent = 'Тест или курс не указан.'
		return
	}

	// ----- Работа с localStorage -----
	let currentAttempt = null
	function loadState() {
		const raw = localStorage.getItem('currentAttempt')
		currentAttempt = raw ? JSON.parse(raw) : null
	}
	function saveState() {
		localStorage.setItem('currentAttempt', JSON.stringify(currentAttempt))
	}
	function clearState() {
		localStorage.removeItem('currentAttempt')
		currentAttempt = null
	}

	// ===== Загружаем вопросы =====
	let questions
	try {
		const res = await fetch(`/api/tests/${testId}/questions`, {
			credentials: 'same-origin',
		})
		if (!res.ok) throw new Error(res.status)
		questions = await res.json()
	} catch (e) {
		document.getElementById('quiz').textContent = 'Ошибка загрузки теста.'
		console.error(e)
		return
	}

	// ----- Константы и API-обёртки -----
	const MAX_ATTEMPTS = 2

	async function finishAttempt(attemptId, score, correct, wrong) {
		const res = await fetch(`/api/attempts/${attemptId}/finish`, {
			method: 'PATCH',
			credentials: 'same-origin',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				score,
				correct_answers: correct,
				wrong_answers: wrong,
			}),
		})
		if (!res.ok) throw new Error(`Не удалось завершить попытку: ${res.status}`)
		return await res.json()
	}

	// ----- Утилиты модалок из coursePage -----
	function showModal(id) {
		const overlay = document.getElementById(id)
		overlay.style.display = 'flex' // flex, чтобы сработали align-items/justify
		// Закрытие кликом по фону
		overlay.addEventListener('click', onOverlayClick)
	}
	function closeModal(id) {
		const overlay = document.getElementById(id)
		overlay.style.display = 'none'
		overlay.removeEventListener('click', onOverlayClick)
	}
	function onOverlayClick(e) {
		// если кликнуто именно по оверлею, закроем
		// if (e.target.classList.contains('modal-overlay')) {
		// 	closeModal(e.target.id)
		// }
	}

	// ----- Основная логика рендера вопросов -----
	;(async function initQuiz() {
		loadState()
		const form = document.getElementById('quiz')

		questions.forEach((q, idx) => {
			const wrapper = document.createElement('div')
			wrapper.className = 'question'

			// Заголовок и метка сложности
			const header = document.createElement('div')
			header.className = 'question-header'

			const h = document.createElement('h4')
			h.textContent = `${idx + 1}. ${q.question_text}`

			const diffLabel = document.createElement('span')
			// diffLabel получает CSS-класс в зависимости от английского уровня,
			// чтобы стилизовать (цвета) по-прежнему работали
			diffLabel.className = `diff-label ${q.difficulty}`

			// Словарь перевода на русский
			const difficultyMap = {
				easy: 'лёгкий',
				medium: 'средний',
				hard: 'сложный',
			}

			// Устанавливаем текст метки на русском
			diffLabel.textContent = difficultyMap[q.difficulty] || q.difficulty

			header.append(h, diffLabel)
			wrapper.appendChild(header)

			// Вопрос закрытого/открытого типа
			if (q.question_type === 'closed') {
				q.options.forEach(opt => {
					const label = document.createElement('label')
					const inp = document.createElement('input')
					inp.type = q.multiple_choice ? 'checkbox' : 'radio'
					inp.name = `q_${q.id}`
					inp.value = String(opt.id)

					// Если в state уже есть ответ — восстановим его
					if (currentAttempt?.answers?.[q.id]) {
						const saved = currentAttempt.answers[q.id]
						if (q.multiple_choice) {
							if (saved.includes(String(opt.id))) inp.checked = true
						} else {
							if (saved === String(opt.id)) inp.checked = true
						}
					}

					// При изменении ответа — сохраняем
					inp.addEventListener('change', () => {
						loadState()
						if (!currentAttempt) return
						if (q.multiple_choice) {
							const sels = Array.from(form.elements[`q_${q.id}`])
								.filter(el => el.checked)
								.map(el => el.value)
							currentAttempt.answers[q.id] = sels
						} else {
							const sel = form.elements[`q_${q.id}`].value
							currentAttempt.answers[q.id] = sel
						}
						saveState()
					})

					label.append(inp, ' ', opt.option_text)
					wrapper.appendChild(label)
				})
			} else {
				const ta = document.createElement('textarea')
				ta.name = `q_${q.id}`
				ta.classList.add('open-question-input')

				// Восстановим предыдущий ввод
				if (currentAttempt?.answers?.[q.id]) {
					ta.value = currentAttempt.answers[q.id]
				}

				ta.addEventListener('input', () => {
					loadState()
					if (!currentAttempt) return
					currentAttempt.answers[q.id] = ta.value.trim()
					saveState()
				})

				wrapper.appendChild(ta)
			}

			form.appendChild(wrapper)
		})

		document.getElementById('check').addEventListener('click', async () => {
			let score = 0,
				correct = 0,
				wrong = 0

			for (const q of questions) {
				let isCorrect
				if (q.question_type === 'closed') {
					const sel = Array.isArray(currentAttempt.answers[q.id])
						? currentAttempt.answers[q.id]
						: [currentAttempt.answers[q.id]]
					const sol = q.options.filter(o => o.is_correct).map(o => String(o.id))
					isCorrect =
						sel.length === sol.length && sel.every(v => sol.includes(v))
				} else {
					isCorrect = compareTextAnswers(
						currentAttempt.answers[q.id] || '',
						q.correct_answer_text,
						80
					)
				}

				// здесь отправляем каждый ответ
				await submitAnswer(currentAttempt.attemptId, q.id, isCorrect)

				// считаем результат
				if (isCorrect) {
					score++
					correct++
				} else {
					wrong++
				}
			}

			// завершаем попытку один раз
			await finishAttempt(currentAttempt.attemptId, score, correct, wrong)

			// показываем модалку с результатом
			document.getElementById(
				'finishAttemptTitle'
			).textContent = `Вы набрали ${score} баллов`
			document.getElementById('finishAttemptMsg').textContent =
				currentAttempt.attemptNumber === 1
					? 'У вас осталась 1 попытка'
					: 'У вас не осталось попыток'
			document.getElementById('btnRetryAttempt').disabled =
				currentAttempt.attemptNumber >= MAX_ATTEMPTS

			showModal('finishAttemptModal')
		})

		// Крестик закрытия результата
		document.getElementById('closeFinishAttempt').onclick = () => {
			const courseId = currentAttempt.courseId
			clearState()
			closeModal('finishAttemptModal')
			navigate(`/static/coursePage/?course=${courseId}`)
		}

		document.getElementById('btnRetryAttempt').onclick = async () => {
			clearState()
			const { attemptId, attemptNumber } = await createAttempt(testId)
			currentAttempt = {
				attemptId,
				attemptNumber,
				startedAt: Date.now(),
				answers: {},
				testId,
				courseId,
			}
			saveState()
			closeModal('finishAttemptModal')
			navigate(`/static/questions/index.html?test=${testId}`)
		}

		// Кнопка «Завершить»
		document.getElementById('btnConfirmFinish').onclick = () => {
			const courseId = currentAttempt.courseId
			clearState()
			closeModal('finishAttemptModal')
			navigate(`/static/coursePage/?course=${courseId}`)
		}
	})()
})

Файл: C:\dev\projects\html\Курсовая работа\static\questions\style.css
/* RESET */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}

/* VARIABLES */
:root {
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

body {
	font-family: 'Inter', sans-serif;
	line-height: 1.6;
	background-color: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background-color 0.5s ease, color 0.5s ease;
}

/* NAVBAR */
.navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	background-color: var(--card-bg);
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
}
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}
.nav-links {
	display: flex;
	gap: var(--sp-md);
}
.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	transition: color var(--trans);
}
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background-color: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* PAGE CONTENT */
.page-content {
	padding: var(--sp-lg) var(--sp-md);
	max-width: 800px;
	margin: 0 auto;
}
.page-content h1 {
	margin-bottom: var(--sp-md);
	color: var(--primary);
	transition: color var(--trans);
}

/* QUESTIONS */
.question {
	background-color: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-sm);
	margin-bottom: var(--sp-md);
	transition: background-color var(--trans), border-color var(--trans);
}
.question h4 {
	margin-bottom: var(--sp-xs);
}
.question label {
	display: block;
	margin-bottom: var(--sp-xs);
	cursor: pointer;
	color: var(--text);
	transition: color var(--trans);
}
.question input[type='radio'],
.question input[type='checkbox'] {
	margin-right: var(--sp-xs);
}

/* BUTTON */
#check {
	display: inline-block;
	padding: var(--sp-sm) var(--sp-md);
	font-size: 1rem;
	background-color: var(--primary);
	color: #fff;
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: background-color var(--trans), transform var(--trans),
		box-shadow var(--trans);
}
#check:hover {
	transform: translateY(-2px);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
#check:active {
	transform: translateY(0);
}

/* POPUP */
.popup-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	display: none;
	align-items: center;
	justify-content: center;
	z-index: 1000;
	opacity: 0;
	transition: opacity 0.3s ease;
}
.popup-overlay.active {
	display: flex;
	opacity: 1;
}
.popup-content {
	background: var(--card-bg);
	padding: var(--sp-md);
	border-radius: var(--radius);
	width: 90%;
	max-width: 400px;
	position: relative;
	transform: translateY(-30px);
	transition: transform 0.3s ease;
}
.popup-overlay.active .popup-content {
	transform: translateY(0);
}
.close-btn {
	position: absolute;
	top: var(--sp-sm);
	right: var(--sp-sm);
	font-size: 1.5rem;
	cursor: pointer;
	color: var(--text-muted);
}
.popup-body h2 {
	margin-bottom: var(--sp-sm);
	color: var(--primary);
}
.popup-body p {
	margin-bottom: var(--sp-sm);
}
.progress-bar {
	background: var(--border);
	height: 10px;
	border-radius: 5px;
	overflow: hidden;
}
.progress {
	height: 100%;
	background: var(--primary);
	width: 0;
	transition: width 0.3s ease;
}

/* Стили для поля открытого ответа в панели учителя */
.open-question-input {
	width: 100%;
	max-width: 600px; /* ограничивает растяжение */
	min-height: 60px; /* минимальная высота */
	padding: var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	font-size: 1rem;
	font-family: inherit;
	resize: vertical; /* разрешает только вертикальное растяжение */
	background: var(--bg);
	color: var(--text);
	box-sizing: border-box; /* учитывает padding/border в width */
	transition: border-color var(--trans), background var(--trans),
		color var(--trans);
}

/* Если нужно, можно ограничить максимальную высоту */
.open-question-input {
	max-height: 200px;
}

/* RESPONSIVE */
@media (max-width: 600px) {
	.navbar {
		flex-direction: column;
		gap: var(--sp-xs);
	}
	.nav-links {
		flex-wrap: wrap;
		justify-content: center;
	}
	.page-content {
		padding: var(--sp-md);
	}
}

.question-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 8px;
}

.diff-label {
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 13px;
	font-weight: bold;
	text-transform: uppercase;
}

.diff-label.easy {
	background-color: #d4edda;
	color: #155724;
}

.diff-label.medium {
	background-color: #fff3cd;
	color: #856404;
}

.diff-label.hard {
	background-color: #f8d7da;
	color: #721c24;
}

.modal-overlay {
	position: fixed;
	inset: 0;
	display: none;
	background: rgba(0, 0, 0, 0.5);
	align-items: center;
	justify-content: center;
	z-index: 1000;
}
.modal-content {
	position: relative;
	background-color: var(--bg);
	color: var(--text);
	padding: 1.5rem;
	border-radius: 8px;
	max-width: 90%;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

#btnConfirmFinish {
	background: transparent;
	color: var(--primary);
	border: 2px solid var(--primary);
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
	text-align: center;
	display: inline-block;
}

#btnConfirmFinish:hover {
	background-color: var(--primary);
	color: white;
}

#btnRetryAttempt {
	background: transparent;
	color: var(--primary);
	border: 2px solid var(--primary);
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
	text-align: center;
	display: inline-block;
}

#btnRetryAttempt:hover {
	background-color: var(--primary);
	color: white;
}

#btnRetryAttempt.muted {
	opacity: 0.5;
	cursor: not-allowed;
	pointer-events: none; /* отключает ховер и клики */
	border-color: #ccc;
	color: #aaa;
}

#btnRetryAttempt.muted:hover {
	background-color: transparent;
	color: #aaa;
}

.modal-close {
	color: var(--text);
	position: absolute;
	top: 8px;
	right: 12px;
	background: transparent;
	border: none;
	font-size: 1.5rem;
	cursor: pointer;
}
.modal-footer {
	margin-top: 1rem;
	text-align: right;
}
.modal-footer button {
	margin-left: 0.5rem;
}

Файл: C:\dev\projects\html\Курсовая работа\static\stepByStepAnimation\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Пошаговая анимация: ассоциативность объединения</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<!-- GSAP -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
		<link rel="stylesheet" href="style.css" />
		<script src="script.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="/static/courses/">Курсы</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
				>
					Панель админа
				</a>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
				<a href="/static/stepByStepAnimation/" class="active"
					>Пошаговая анимация</a
				>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefaultImg" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<div id="animation-container">
				<!-- Шаг 1 -->
				<section class="step" data-step="1">
					<h2>Шаг 1: Множества A, B и C</h2>
					<div class="venn">
						<div class="set a">A</div>
						<div class="set b">B</div>
						<div class="set c">C</div>
					</div>
				</section>

				<!-- Шаг 2 -->
				<section class="step" data-step="2">
					<h2>Шаг 2: B ∪ C</h2>
					<div class="venn">
						<div class="set a faded">A</div>
						<div class="set b highlight">B</div>
						<div class="set c highlight">C</div>
						<!-- <div class="label bc-union">B ∪ C</div> -->
					</div>
				</section>

				<!-- Шаг 3 -->
				<section class="step" data-step="3">
					<h2>Шаг 3: A ∪ (B ∪ C)</h2>
					<div class="venn">
						<div class="set a highlight">A</div>
						<div class="set b highlight">B</div>
						<div class="set c highlight">C</div>
					</div>
				</section>

				<!-- Шаг 4 -->
				<section class="step" data-step="4">
					<h2>Шаг 4: A ∪ B</h2>
					<div class="venn">
						<div class="set a highlight">A</div>
						<div class="set b highlight">B</div>
						<div class="set c faded">C</div>
					</div>
				</section>

				<!-- Шаг 5 -->
				<section class="step" data-step="5">
					<h2>Шаг 5: (A ∪ B) ∪ C</h2>
					<div class="venn">
						<div class="set a highlight">A</div>
						<div class="set b highlight">B</div>
						<div class="set c highlight">C</div>
					</div>
				</section>

				<!-- Шаг 6 -->
				<section class="step" data-step="6">
					<h2>Шаг 6: Результат</h2>
					<div class="venn">
						<div class="set a highlight">A</div>
						<div class="set b highlight">B</div>
						<div class="set c highlight">C</div>
					</div>
					<p class="result">A ∪ (B ∪ C) = (A ∪ B) ∪ C</p>
				</section>
			</div>

			<div id="set-calculator">
				<h3>Калькулятор множеств</h3>
				<div class="inputs">
					<label
						>A: <input type="text" id="setA" placeholder="1, 2, 3"
					/></label>
					<label
						>B: <input type="text" id="setB" placeholder="2, 3, 4"
					/></label>
					<label
						>C: <input type="text" id="setC" placeholder="3, 4, 5"
					/></label>
				</div>
				<div id="calc-result">Результат шага: <code>{ }</code></div>
			</div>

			<div class="controls">
				<button id="prevStep">← Назад</button>
				<span id="currentStep">1</span> / <span id="totalSteps">6</span>
				<button id="nextStep">Вперед →</button>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\stepByStepAnimation\script.js
// Навигация для плиток
function navigate(url) {
	window.location.href = url
}

/* -----------------------
   2. Подгрузка аватарки в навбар
   (теперь возвращает user)
------------------------ */
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null // не залогинен или другая ошибка
		const user = await res.json()

		if (user.avatar_path) {
			const navImg = document.querySelector('.user-icon img')
			if (navImg) navImg.src = user.avatar_path
		}

		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

// Обновляет иконку темы
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = ''

	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

document.addEventListener('DOMContentLoaded', () => {
	// Подсветка активного пункта меню
	const path = window.location.pathname
	document.querySelectorAll('.nav-links a').forEach(link => {
		link.classList.toggle('active', path.startsWith(link.getAttribute('href')))
	})

	// Инициализация темы
	const stored = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = stored || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)

	// Обработчик переключения темы
	const toggleBtn = document.getElementById('theme-toggle')
	if (toggleBtn) {
		toggleBtn.addEventListener('click', () => {
			const next =
				document.documentElement.getAttribute('data-theme') === 'dark'
					? 'light'
					: 'dark'
			document.documentElement.setAttribute('data-theme', next)
			localStorage.setItem('theme', next)
			updateToggleIcon(next)
		})
	}

	// Подгрузить аватар и проверить роль
	loadUserIcon().then(user => {
		if (!user) return
		if (user.role === 'admin') {
			const adminTile = document.getElementById('nav-admin')
			if (adminTile) adminTile.style.display = 'flex'
		}
		if (user.role === 'teacher') {
			// 1) в навигации
			const navTeacher = document.getElementById('nav-teacher')
			if (navTeacher) navTeacher.style.display = 'inline-block'
			// 2) на главной странице-плитках
			const teacherTile = document.getElementById('go-to-teacher')
			if (teacherTile) teacherTile.style.display = 'flex'
		}
	})

	const steps = Array.from(document.querySelectorAll('.step'))
	let current = 0
	const total = steps.length

	document.getElementById('totalSteps').textContent = total
	updateView()

	document.getElementById('prevStep').onclick = () => {
		if (current > 0) current--
		updateView()
	}
	document.getElementById('nextStep').onclick = () => {
		if (current < total - 1) current++
		updateView()
	}

	function updateView() {
		steps.forEach((sec, i) => {
			sec.style.display = i === current ? 'block' : 'none'
		})
		document.getElementById('currentStep').textContent = current + 1
		runAnimationForStep(current + 1)
		updateCalculatorResult(current + 1)
	}
})

function runAnimationForStep(step) {
	const sel = `.step[data-step="${step}"] `
	switch (step) {
		case 1:
			gsap.fromTo(
				sel + '.set',
				{ scale: 0, opacity: 0 },
				{ scale: 1, opacity: 0.9, duration: 0.8, stagger: 0.2 }
			)
			break
		case 2:
			gsap.fromTo(
				sel + '.highlight',
				{ scale: 0, opacity: 0 },
				{ scale: 1, opacity: 1, duration: 0.6, stagger: 0.3 }
			)
			break
		case 3:
			gsap.fromTo(
				sel + '.label.union-all',
				{ scale: 0, opacity: 0 },
				{ scale: 1, opacity: 1, duration: 0.7 }
			)
			break
		case 4:
			gsap.fromTo(
				sel + '.highlight',
				{ scale: 0, opacity: 0 },
				{ scale: 1, opacity: 1, duration: 0.6, stagger: 0.2 }
			)
			break
		case 5:
			gsap.fromTo(
				sel + '.label.ab-c-union',
				{ scale: 0, opacity: 0 },
				{ scale: 1, opacity: 1, duration: 0.7 }
			)
			break
		case 6:
			gsap.fromTo(sel + '.result', { opacity: 0 }, { opacity: 1, duration: 1 })
			break
	}
}

function updateCalculatorResult(step) {
	const parseSet = id => {
		const raw = document.getElementById(id).value
		return new Set(
			raw
				.split(',')
				.map(s => s.trim())
				.filter(Boolean)
				.map(Number)
		)
	}

	const setA = parseSet('setA')
	const setB = parseSet('setB')
	const setC = parseSet('setC')

	const union = (a, b) => new Set([...a, ...b])

	let resultSet

	switch (step) {
		case 2:
			resultSet = union(setB, setC)
			break
		case 3:
			resultSet = union(setA, union(setB, setC))
			break
		case 4:
			resultSet = union(setA, setB)
			break
		case 5:
			resultSet = union(union(setA, setB), setC)
			break
		case 6:
			resultSet = union(setA, union(setB, setC)) // или union(union(A, B), C)
			break
		default:
			resultSet = new Set()
	}

	document.querySelector('#calc-result code').textContent = `{ ${[...resultSet]
		.sort((a, b) => a - b)
		.join(', ')} }`
}

Файл: C:\dev\projects\html\Курсовая работа\static\stepByStepAnimation\style.css
/* RESET & VARIABLES */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}

:root {
	/* Светлая тема */
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;

	/* Отступы и радиус */
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	/* Тёмная тема */
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

body {
	font-family: 'Inter', sans-serif;
	line-height: 1.6;
	background-color: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background-color 0.5s ease, color 0.5s ease;
}

/* NAVBAR */
.navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	background-color: var(--card-bg);
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
	transition: background-color 0.5s ease;
}
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}
.nav-links {
	display: flex;
	gap: var(--sp-md);
}
.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	transition: color var(--trans);
}
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background-color: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	margin-right: var(--sp-sm);
	transition: transform 0.2s;
}
#theme-toggle:hover {
	transform: scale(1.1);
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* PAGE CONTENT */
.page-content {
	max-width: 800px;
	margin: var(--sp-md) auto;
	padding: 0 var(--sp-md);
}
.page-content h1 {
	margin-bottom: var(--sp-md);
	color: var(--primary);
	transition: color 0.5s ease;
}

/* Анимация-контейнер */
#animation-container {
	background-color: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	transition: background-color 0.5s ease, border-color 0.5s ease;
	/* Задайте нужные размеры для вашей анимации */
	height: 400px;
}

.venn {
	position: relative;
	width: 400px;
	height: 350px;
	margin: 1.5rem auto;
}
.set {
	position: absolute;
	width: 150px;
	height: 150px;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 1.2rem;
	color: white;
	opacity: 0.9;
}
/* Корректные пересечения: */
.set.a {
	left: 70px;
	top: 20px;
	background: #4caf50;
}
.set.b {
	left: 210px;
	top: 20px;
	background: #2196f3;
}
.set.c {
	left: 145px;
	top: 140px;
	background: #ff9800;
}
.faded {
	opacity: 0.2;
}
.highlight {
	box-shadow: 0 0 10px 3px yellow;
}
.label {
	position: absolute;
	top: 300px;
	left: 50%;
	transform: translateX(-50%);
	font-weight: bold;
	color: black;
}
.bc-union,
.union-all,
.ab-union,
.ab-c-union {
	top: 300px;
}
.result {
	font-size: 1.2rem;
	margin-top: 1rem;
}
.controls {
	display: flex;
	justify-content: center;
	align-items: center;
	gap: 1rem;
	margin-top: 1rem;
}
.controls button {
	padding: 0.5rem 1rem;
	border: none;
	background: var(--primary, #333);
	color: white;
	border-radius: 4px;
	cursor: pointer;
}
.venn {
	position: relative;
	width: 400px;
	height: 250px;
	margin: 1.5rem auto;
}

/* убираем opacity, иначе blend работать не будет */
.set {
	position: absolute;
	width: 150px;
	height: 150px;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 1.2rem;
	color: white;
	/* вот эта строчка делает «автоматическую» подсветку пересечений */
	mix-blend-mode: difference;
}
/* Два круга сверху */
.set.a {
	left: 70px;
	top: 20px;
	background: #4caf50;
}
.set.b {
	left: 180px;
	top: 20px;
	background: #2196f3;
}
/* Один круг снизу по центру */
.set.c {
	left: calc(50% - 75px);
	top: 115px;
	background: #ff9800;
}
.faded {
	opacity: 0.2;
}
.highlight {
	box-shadow: 0 0 10px 3px yellow;
}
.bc-union {
	top: 300px;
}
.union-all {
	top: 300px;
}
.ab-union {
	top: 300px;
}
.ab-c-union {
	top: 300px;
}
.result {
	font-size: 1.2rem;
	margin-top: 1rem;
}
.controls {
	display: flex;
	justify-content: center;
	align-items: center;
	gap: 1rem;
	margin-top: 1rem;
}
.controls button {
	padding: 0.5rem 1rem;
	border: none;
	background: var(--primary, #333);
	color: white;
	border-radius: 4px;
	cursor: pointer;
}

#set-calculator {
	margin-top: 2rem;
	padding-top: 1rem;
	border-top: 1px dashed var(--border);
}
#set-calculator h3 {
	margin-bottom: 0.5rem;
	color: var(--text-muted);
}
.inputs {
	display: flex;
	gap: 1rem;
	flex-wrap: wrap;
	margin-bottom: 1rem;
}
.inputs label {
	display: flex;
	flex-direction: column;
	font-weight: 500;
	font-size: 0.9rem;
}
.inputs input {
	padding: 0.3rem 0.5rem;
	font-size: 1rem;
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	color: var(--text);
	min-width: 100px;
}
#calc-result {
	font-size: 1rem;
	font-weight: 500;
	color: var(--primary);
}

/* RESPONSIVE */
@media (max-width: 600px) {
	.navbar {
		flex-direction: column;
		gap: var(--sp-xs);
	}
	.nav-links {
		flex-wrap: wrap;
		justify-content: center;
	}
	#animation-container {
		height: 300px;
	}
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\common.css
/* === RESET & VARIABLES === */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}
:root {
	--bg: #f9fafb;
	--bg-rgb: 249, 250, 251;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;
	--sp-xs: 0.5rem;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--bg-rgb: 31, 41, 55;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}
body {
	font-family: 'Inter', sans-serif;
	background: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background 0.5s, color 0.5s;
}

/* NAVBAR */
.navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	background: var(--card-bg);
	padding: var(--sp-xs) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
}
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}
.nav-links {
	display: flex;
	gap: var(--sp-md);
}
.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	padding: var(--sp-xs) 0;
}
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	cursor: pointer;
	font-size: 1.25rem;
	margin-right: var(--sp-sm);
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	object-fit: cover;
	cursor: pointer;
	transition: transform var(--trans);
}
.user-icon img:hover {
	transform: scale(1.1);
}

/* PAGE CONTENT */
.page-content {
	max-width: 1400px;
	margin: var(--sp-lg) auto;
	padding: 0 var(--sp-md);
}
.page-content h1 {
	margin-bottom: var(--sp-md);
	color: var(--primary);
	transition: color var(--trans);
}

/* TABLE WRAPPER */
.table-wrapper {
	margin-top: var(--sp-md);
	overflow-x: auto;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}
.table-wrapper table {
	width: 100%;
	border-collapse: collapse;
	table-layout: auto;
}
.table-wrapper th,
.table-wrapper td {
	padding: var(--sp-sm) var(--sp-md);
	text-align: left;
	white-space: nowrap;
}
.table-wrapper thead {
	background: var(--primary);
}
.table-wrapper thead th {
	color: var(--bg);
	font-weight: 600;
}

.course-form {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)) auto;
	gap: var(--sp-sm);
	margin-top: var(--sp-md);
	align-items: end;
}

.course-form input,
.course-form select {
	padding: var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	transition: border-color var(--trans);
	color: var(--text);
}

.course-form input:focus,
.course-form select:focus {
	outline: none;
	border-color: var(--primary);
}
.course-form label {
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
}
.course-form button {
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}
.course-form button:hover {
	opacity: 0.9;
}

.table-wrapper thead th:first-child {
	border-top-left-radius: var(--radius);
}
.table-wrapper thead th:last-child {
	border-top-right-radius: var(--radius);
}
.table-wrapper tbody tr:nth-child(odd) {
	background: var(--bg);
}
.table-wrapper tbody tr:nth-child(even) {
	background: var(--border);
}
.table-wrapper tbody tr:hover {
	background: rgba(79, 70, 229, 0.1);
}
.table-wrapper tbody tr:last-child td:first-child {
	border-bottom-left-radius: var(--radius);
}
.table-wrapper tbody tr:last-child td:last-child {
	border-bottom-right-radius: var(--radius);
}

/* CRUD BUTTONS */
button.save-course,
button.save-open-answer,
button.view-group-btn,
button.save-test,
button.save-question,
button#saveNameBtn,
button.save-option,
.theory-card .save-theory,
button.save-new-option {
	background: transparent;
	color: green;
	border: 2px solid green;
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
	text-align: center;
	display: inline-block;
}
button.save-course:hover,
button.save-test:hover,
button.view-group-btn:hover,
button.save-question:hover,
button.save-option:hover,
button#saveNameBtn:hover,
.theory-card .save-theory:hover,
button.save-new-option:hover,
button.manage-options:hover {
	background-color: green;
	color: white;
}
button.del-course,
button.del-test,
button.delete-open-answer,
button.remove-student-btn,
.theory-card .btn-danger,
button.del-question,
button.del-option {
	background: transparent;
	border: 2px solid rgb(173, 4, 4);
	color: rgb(173, 4, 4);
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
	text-align: center;
	display: inline-block;
}
button.del-course:hover,
button.del-test:hover,
button.remove-student-btn:hover,
button.del-question:hover,
.theory-card .btn-danger:hover,
button.del-option:hover {
	background-color: rgb(173, 4, 4);
	color: white;
}

button.manage-options {
	background: transparent;
	color: var(--text);
	border: 2px solid var(--text);
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}

button.manage-options:hover {
	background-color: var(--text);
	color: var(--bg);
}

/* EDITABLE FIELDS */
.edit-opt-text,
#groupNameInput,
.input-add-student,
input.edit-text {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--bg);
	color: var(--text);
	transition: border-color var(--trans), background var(--trans),
		color var(--trans);
}
input.edit-text:focus,
.input-add-student:focus,
#groupNameInput:focus {
	outline: none;
	border-color: var(--primary);
	box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
}

button.submit-students-info {
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}

button.submit-students-info:hover {
	opacity: 0.9;
}

/* Добавьте этот CSS в /static/teacherPanel/css/common.css */

#toast-container {
	position: fixed;
	top: 20px;
	right: 20px;
	z-index: 9999;
	display: flex;
	flex-direction: column;
	gap: 10px;
}

.toast {
	background-color: var(--card-bg);
	color: var(--text);
	padding: 15px 20px;
	border-radius: var(--radius);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
	opacity: 0;
	transform: translateX(100%);
	transition: opacity 0.3s ease, transform 0.3s ease;
	display: flex;
	justify-content: space-between;
	align-items: center;
	min-width: 250px;
	max-width: 350px;
}

.toast.show {
	opacity: 1;
	transform: translateX(0);
}

.toast-success {
	border-left: 5px solid #28a745; /* Зеленый */
}

.toast-error {
	border-left: 5px solid #dc3545; /* Красный */
}

.toast-info {
	border-left: 5px solid #17a2b8; /* Синий */
}

.toast-close-btn {
	background: none;
	border: none;
	color: var(--text-muted);
	font-size: 1.5rem;
	line-height: 1;
	cursor: pointer;
	padding: 0 0 0 15px;
	opacity: 0.7;
}

.toast-close-btn:hover {
	opacity: 1;
}

.spinner-overlay {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(
		var(--bg-rgb, 249, 250, 251),
		0.7
	); /* Полупрозрачный фон, адаптирующийся к теме */
	display: flex;
	justify-content: center;
	align-items: center;
	z-index: 10;
}

.spinner {
	border: 4px solid var(--border);
	border-top: 4px solid var(--primary);
	border-radius: 50%;
	width: 40px;
	height: 40px;
	animation: spin 1s linear infinite;
}

@keyframes spin {
	0% {
		transform: rotate(0deg);
	}
	100% {
		transform: rotate(360deg);
	}
}

.preview-content {
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	max-width: 300px;
}

.pdf-icon {
	display: inline-block;
	width: 16px;
	height: 16px;
	background: url('/static/img/pdf-icon.svg') no-repeat;
}

[data-theme='dark'] .pdf-icon {
	filter: invert(1);
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\courses.css
.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 1rem auto;
}
#teacher-course-search {
	width: 100%;
	padding: 0.5rem 1rem;
	font-size: 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}
#teacher-suggestions {
	position: absolute;
	top: 100%;
	left: 0;
	right: 0;
	background: var(--card-bg);
	border: 1px solid var(--border);
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	margin: 0;
	padding: 0;
	z-index: 10;
}
#teacher-suggestions li {
	padding: 0.5rem;
	cursor: pointer;
}
#teacher-suggestions li.active,
#teacher-suggestions li:hover {
	background: rgba(79, 70, 229, 0.1);
}
.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75em;
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.2em;
	cursor: pointer;
	color: #666;
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\group.css
/* Столбец «Действия» в таблице уже покрыт .remove-student-btn,
     но зададим удобные отступы: */
.table-wrapper td:last-child {
	text-align: center;
	width: 8rem;
}

/* ============================= */
/* Стили для формы добавления студента */
/* ============================= */

/* Контейнер формы: делаем flex, выравниваем по центру, даём небольшой отступ снизу */
/* #addStudentForm {
	display: flex;
	align-items: center;
	gap: var(--sp-sm);
	margin-bottom: var(--sp-lg);
} */

/* Метка заголовка */
.page-content h3 {
	margin-bottom: var(--sp-sm);
	color: var(--primary);
	font-size: 1.125rem;
}

/* Поле ввода: растягиваем на всю оставшуюся ширину */
#addStudentForm .input-add-student {
	flex: 1 1 auto;
	padding: var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	color: var(--text);
	transition: border-color var(--trans), box-shadow var(--trans);
}

/* Фокус на поле ввода */
#addStudentForm .input-add-student:focus {
	outline: none;
	border-color: var(--primary);
	box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
}

/* Кнопка “Добавить”: не растягивается, красивая рамка и hover */
#addStudentForm .submit-students-info {
	flex: 0 0 auto;
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}

#addStudentForm .submit-students-info:hover {
	opacity: 0.9;
}

/* Контейнер поиска */
.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 1rem auto;
}

/* Само поле ввода */
#teacher-group-search {
	width: 100%;
	padding: 0.5rem 1rem;
	font-size: 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}

#teacher-group-search:focus {
	border-color: var(--primary-dark);
}

/* Кнопка очистки */
.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75rem;
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	color: #666;
	display: none; /* показывается скриптом при вводе */
}

/* Список подсказок */
#teacher-group-suggestions {
	position: absolute;
	top: calc(100% + 2px);
	left: 0;
	right: 0;
	z-index: 10;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	margin: 0;
	padding: 0;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Элемент подсказки */
#teacher-group-suggestions li {
	padding: 0.5rem 1rem;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

/* Подсветка при наведении и при выборе стрелками */
#teacher-group-suggestions li:hover,
#teacher-group-suggestions li.active {
	background: rgba(79, 70, 229, 0.1);
}

/* Подсветка найденного фрагмента */
#teacher-group-suggestions li mark {
	background-color: yellow;
	padding: 0;
	border-radius: 2px;
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\groups.css
/* Контейнер поиска */
.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 1rem auto;
}

/* Само поле ввода */
#teacher-group-search {
	width: 100%;
	padding: 0.5rem 1rem;
	font-size: 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}

#teacher-group-search:focus {
	border-color: var(--primary-dark);
}

/* Кнопка очистки */
.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75rem;
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	color: #666;
	display: none; /* показывается скриптом при вводе */
}

/* Список подсказок */
#teacher-group-suggestions {
	position: absolute;
	top: calc(100% + 2px);
	left: 0;
	right: 0;
	z-index: 10;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	margin: 0;
	padding: 0;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Элемент подсказки */
#teacher-group-suggestions li {
	padding: 0.5rem 1rem;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

/* Подсветка при наведении и при выборе стрелками */
#teacher-group-suggestions li:hover,
#teacher-group-suggestions li.active {
	background: rgba(79, 70, 229, 0.1);
}

/* Подсветка найденного фрагмента */
#teacher-group-suggestions li mark {
	background-color: yellow;
	padding: 0;
	border-radius: 2px;
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\index.css
/* TILES */
.tiles {
	display: flex;
	gap: var(--sp-md);
	flex-wrap: wrap;
	margin-top: var(--sp-lg);
}
.card {
	flex: 1 1 30%;
	background: var(--primary);
	color: var(--bg);
	text-align: center;
	padding: var(--sp-lg) var(--sp-md);
	border-radius: var(--radius);
	text-decoration: none;
	font-size: 1.2rem;
	transition: background var(--trans);
}
.card:hover {
	background: #3c3bd1;
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\questions.css
/* Контейнер поиска */
.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 1rem auto;
}

/* Само поле ввода */
#teacher-question-search {
	width: 100%;
	padding: 0.5rem 1rem;
	font-size: 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}

#teacher-question-search:focus {
	border-color: var(--primary-dark);
}

/* Кнопка очистки */
.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75rem;
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	color: #666;
	display: none; /* показывается скриптом при вводе */
}

/* Список подсказок */
#teacher-question-suggestions {
	position: absolute;
	top: calc(100% + 2px);
	left: 0;
	right: 0;
	z-index: 10;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	margin: 0;
	padding: 0;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Элемент подсказки */
#teacher-question-suggestions li {
	padding: 0.5rem 1rem;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

/* Подсветка при наведении и при выборе стрелками */
#teacher-question-suggestions li:hover,
#teacher-question-suggestions li.active {
	background: rgba(79, 70, 229, 0.1);
}

/* Подсветка найденного фрагмента */
#teacher-question-suggestions li mark {
	background-color: yellow;
	padding: 0;
	border-radius: 2px;
}

/* Стиль для выпадающего списка сложности */
.edit-difficulty {
	padding: 5px 8px;
	border-radius: 4px;
	font-size: 14px;
	border: 1px solid #ccc;
	transition: background-color 0.2s ease, color 0.2s ease;
}

/* Зеленый для easy */
.edit-difficulty.easy {
	background-color: #d4edda;
	color: #155724;
	border-color: #c3e6cb;
}

/* Желтый для medium */
.edit-difficulty.medium {
	background-color: #fff3cd;
	color: #856404;
	border-color: #ffeeba;
}

/* Красный для hard */
.edit-difficulty.hard {
	background-color: #f8d7da;
	color: #721c24;
	border-color: #f5c6cb;
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\tests.css
/* Список вопросов внутри модалки */
.quick-questions-list {
	list-style: none;
	max-height: 200px;
	overflow-y: auto;
	border-top: 1px solid var(--border);
}

.quick-questions-list .question-item {
	padding: var(--sp-sm);
	margin: 0;
	border-bottom: 1px solid var(--border);
	display: flex;
	align-items: center;
	justify-content: space-between;
	position: relative;
}

.quick-questions-list .question-item:nth-child(even) {
	background: var(--card-bg);
}
.quick-questions-list .question-item:hover {
	background: rgba(79, 70, 229, 0.05);
}
.quick-questions-list .question-text {
	flex: 1;
	margin-right: var(--sp-md);
	word-break: break-word;
}
.quick-questions-list .remove-quick-question {
	background: transparent;
	border: none;
	color: var(--text-muted);
	font-size: 1.2rem;
	cursor: pointer;
	transition: color var(--trans);
}
.quick-questions-list .remove-quick-question:hover {
	color: var(--primary);
}

/* Кнопка "Сохранить все вопросы" */
.save-questions {
	margin: var(--sp-sm) var(--sp-md);
}
.save-questions[disabled] {
	opacity: 0.4;
	cursor: not-allowed;
}

/* Подтверждение закрытия без сохранения */
.unsaved-confirm {
	position: absolute;
	top: var(--sp-sm);
	right: var(--sp-sm);
	background: var(--card-bg);
	color: var(--text);
	border: 1px solid var(--primary);
	border-radius: var(--radius);
	padding: var(--sp-sm);
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
	animation: fadeIn 0.3s ease;
}
.unsaved-confirm p {
	margin-bottom: var(--sp-sm);
}
.unsaved-confirm button {
	margin-right: var(--sp-sm);
	padding: var(--sp-xs) var(--sp-sm);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
}
@keyframes fadeIn {
	from {
		opacity: 0;
		transform: translateY(-10px);
	}
	to {
		opacity: 1;
		transform: translateY(0);
	}
}

/* ======== МОДАЛЬНОЕ ОКНО ======== */
.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 2000;
}
.modal-overlay.open {
	display: flex;
}

.modal-content {
	background: var(--card-bg);
	color: var(--text);
	width: 90%;
	max-width: 600px;
	border-radius: var(--radius);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
	overflow: hidden;
	display: flex;
	flex-direction: column;
}

/* Заголовок модалки */
.modal-header,
.modal-footer {
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: var(--bg);
	display: flex;
	align-items: center;
	justify-content: space-between;
}
.modal-header h3 {
	margin: 0;
	font-size: 1.25rem;
}
.modal-close {
	background: none;
	border: none;
	font-size: 1.5rem;
	color: var(--bg);
	cursor: pointer;
	line-height: 1;
	transition: opacity var(--trans);
}
.modal-close:hover {
	opacity: 0.8;
}

/* Тело модалки */
.modal-body {
	padding: var(--sp-md);
	max-height: 60vh;
	overflow-y: auto;
}

/* Форма внутри модалки */
.quick-form .form-group {
	margin-bottom: var(--sp-md);
}
.quick-form .form-group.inline {
	display: flex;
	align-items: center;
	gap: var(--sp-md);
}
.quick-form label {
	font-weight: 500;
}
.quick-form textarea,
.quick-form select,
.quick-form input[type='text'] {
	width: 100%;
	padding: var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	color: var(--text);
	transition: border-color var(--trans);
}
.quick-form textarea:focus,
.quick-form select:focus,
.quick-form input[type='text']:focus {
	outline: none;
	border-color: var(--primary);
}

/* Базовый класс кнопки */
.btn {
	display: inline-flex;
	align-items: center;
	gap: var(--sp-xs);
	padding: var(--sp-xs) var(--sp-sm);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}
.btn:hover {
	opacity: 0.8;
}

/* Футер модалки: кнопка «Сохранить всё» */
.modal-footer .btn.save-questions {
	padding: var(--sp-sm) var(--sp-lg);
	background: var(--primary);
	color: var(--bg);
	font-weight: 600;
	border: none;
	border-radius: var(--radius);
	display: inline-flex;
	align-items: center;
	gap: var(--sp-xs);
	transition: background var(--trans), opacity var(--trans);
}
.modal-footer .btn.save-questions:hover {
	background: #3c3bd1;
	opacity: 0.9;
}
.modal-footer .btn.save-questions:disabled {
	background: var(--border);
	cursor: not-allowed;
	opacity: 0.6;
}

/* Контейнер поиска */
.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 1rem auto;
}

/* Само поле ввода */
#teacher-test-search {
	width: 100%;
	padding: 0.5rem 1rem;
	font-size: 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}

#teacher-test-search:focus {
	border-color: var(--primary-dark);
}

/* Кнопка очистки */
.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75rem;
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	color: #666;
	display: none; /* показывается скриптом при вводе */
}

/* Список подсказок */
#teacher-test-suggestions {
	position: absolute;
	top: calc(100% + 2px);
	left: 0;
	right: 0;
	z-index: 10;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	margin: 0;
	padding: 0;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Элемент подсказки */
#teacher-test-suggestions li {
	padding: 0.5rem 1rem;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

/* Подсветка при наведении и при выборе стрелками */
#teacher-test-suggestions li:hover,
#teacher-test-suggestions li.active {
	background: rgba(79, 70, 229, 0.1);
}

/* Подсветка найденного фрагмента */
#teacher-test-suggestions li mark {
	background-color: yellow;
	padding: 0;
	border-radius: 2px;
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\css\theory.css
/* ======= Форма создания темы ======= */
.cards-toolbar {
	display: flex;
	gap: var(--sp-sm);
	margin-bottom: var(--sp-md);
}
.cards-toolbar select,
.cards-toolbar input[type='text'] {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	color: var(--text);
	transition: background var(--trans), border-color var(--trans);
}
.cards-toolbar button.btn-primary {
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
	padding: var(--sp-xs) var(--sp-md);
	border: none;
	border-radius: var(--radius);
	background: var(--primary);
	color: #fff;
	cursor: pointer;
	transition: background var(--trans);
}

/* ======= Карточки темы ======= */
.cards-container {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(250px, 250px));
	gap: var(--sp-md);
	justify-content: center;
}
.theory-card {
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: calc(var(--sp-md) + 1rem) var(--sp-md) var(--sp-md);
	position: relative;
	display: flex;
	flex-direction: column;
	gap: var(--sp-sm);
	transition: background var(--trans), border-color var(--trans);
	position: relative;
	max-width: 250px;
	width: 100%;
	margin: 0 auto;
}

.theory-card .title-input {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--bg);
	color: var(--text);
	transition: background var(--trans), border-color var(--trans);
}
.theory-card .edit-content {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--primary);
	color: #fff;
	cursor: pointer;
	transition: background var(--trans);
}
.theory-card .edit-content:hover {
	opacity: 0.9;
}

/* ======= Состояния пусто/ошибка ======= */
.cards-container .empty,
.cards-container .error {
	grid-column: 1 / -1;
	text-align: center;
	padding: var(--sp-md);
	border: 1px dashed var(--border);
	border-radius: var(--radius);
}
.cards-container .empty {
	color: var(--text-muted);
}
.cards-container .error {
	color: #e74c3c;
}

/* ======= Модалка ======= */
.modal {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 100;
}
.modal.hidden {
	display: none;
}
.modal-overlay {
	position: absolute;
	width: 100%;
	height: 100%;
	background: rgba(var(--bg-rgb), 0.8);
}
.modal-content {
	background: var(--card-bg);
	color: var(--text);
	padding: var(--sp-md);
	border-radius: var(--radius);
	border: 1px solid var(--border);
	width: 90%;
	max-width: 800px;
	z-index: 101;
	transition: background var(--trans), border-color var(--trans);
}
.modal-content h2 {
	margin-bottom: var(--sp-md);
}

/* ======= Quill редактор ======= */
#editorContainer {
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	transition: background var(--trans), border-color var(--trans);
}
#editorToolbar {
	background: var(--bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	margin-bottom: var(--sp-xs);
	padding: var(--sp-xs);
}
#editorCanvas {
	background: var(--bg);
	color: var(--text);
	min-height: 300px;
	padding: var(--sp-xs);
	border-radius: var(--radius);
	overflow-y: auto;
	transition: background var(--trans), color var(--trans);
}

/* ======= Кнопки в модалке ======= */
.modal-footer {
	display: flex;
	justify-content: flex-end;
	gap: var(--sp-sm);
	margin-top: var(--sp-md);
}
.modal-footer .btn {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--bg);
	color: var(--text);
	cursor: pointer;
	transition: background var(--trans), border-color var(--trans);
}
.modal-footer .btn-primary {
	background: var(--primary);
	color: #fff;
}
.modal-footer .btn-primary:hover {
	opacity: 0.9;
}

/* ======= Картинки внутри ======= */
.theory-content img,
#editorCanvas img {
	max-width: 100%;
	height: auto;
	display: block;
	margin: var(--sp-md) auto;
	border-radius: var(--radius);
}

#toast-container {
	position: fixed;
	top: var(--sp-sm);
	right: var(--sp-sm);
	z-index: 120;
}
.toast {
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
	margin-bottom: var(--sp-xs);
	padding: var(--sp-sm) var(--sp-md);
	border-radius: var(--radius);
	color: #fff;
	font-size: 0.95rem;
	animation: fadeIn 0.3s forwards;
}
.toast.success {
	background: #28a745;
}
.toast.error {
	background: #dc3545;
}
.toast.info {
	background: var(--primary);
}
.toast.hide {
	animation: fadeOut 0.3s forwards;
}
@keyframes fadeIn {
	to {
		opacity: 1;
		transform: none;
	}
}
@keyframes fadeOut {
	to {
		opacity: 0;
		transform: translateY(-10px);
	}
}

/* ======= Отключаем спиннер и оверлей полностью ======= */
#loading-overlay {
	display: none !important;
}
.spinner {
	display: none !important;
}

/* ======= Модалка ======= */
/* (остальные ваши правила без изменений) */
.modal-content {
	/* ... */
	/* Разрешаем скролл внутри, если сама модалка переполнена */
	max-height: 90vh;
	overflow-y: auto;
}

/* ======= Контейнер Quill ======= */
#editorContainer {
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	/* Ограничиваем высоту и даём скролл */
	max-height: 60vh;

	transition: background var(--trans), border-color var(--trans),
		color var(--trans);
}

#ql-editor {
	overflow-y: auto;
}

/* Контейнер поиска */
.search-wrapper {
	position: relative;
	max-width: 600px;
	margin: 1rem auto;
}

/* Само поле ввода */
#teacher-theory-search {
	width: 100%;
	padding: 0.5rem 1rem;
	font-size: 1rem;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	outline: none;
}

#teacher-theory-search:focus {
	border-color: var(--primary-dark);
}

/* Кнопка очистки */
.clear-search {
	position: absolute;
	top: 50%;
	right: 0.75rem;
	transform: translateY(-50%);
	background: transparent;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	color: #666;
	display: none; /* показывается скриптом при вводе */
}

/* Список подсказок */
#teacher-theory-suggestions {
	position: absolute;
	top: calc(100% + 2px);
	left: 0;
	right: 0;
	z-index: 10;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-top: none;
	max-height: 200px;
	overflow-y: auto;
	list-style: none;
	margin: 0;
	padding: 0;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Элемент подсказки */
#teacher-theory-suggestions li {
	padding: 0.5rem 1rem;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

/* Подсветка при наведении и при выборе стрелками */
#teacher-theory-suggestions li:hover,
#teacher-theory-suggestions li.active {
	background: rgba(79, 70, 229, 0.1);
}

/* Подсветка найденного фрагмента */
#teacher-theory-suggestions li mark {
	background-color: yellow;
	padding: 0;
	border-radius: 2px;
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\html\courses.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Панель учителя — Курсы</title>
		<script src="/static/js/theme-init.js"></script>
		<link rel="stylesheet" href="/static/teacherPanel/style.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/common.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/courses.css" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<script src="/static/teacherPanel/script.js" defer></script>
		<script src="/static/teacherPanel/js/courses.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('index.html')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/index.html">Главная</a>
				<a href="/static/teacherPanel/html/index.html">Панель учителя</a>
				<a href="/static/teacherPanel/html/courses.html" class="active"
					>Курсы</a
				>
				<a href="/static/teacherPanel/html/tests.html">Тесты</a>
				<a href="/static/teacherPanel/html/questions.html">Вопросы</a>
				<a href="/static/teacherPanel/html/theory.html">Теория</a>
				<a href="/static/teacherPanel/html/groups.html">Мои группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" altреключDefault" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Управление курсами</h1>

			<div class="search-wrapper">
				<input
					id="teacher-course-search"
					type="text"
					placeholder="Поиск курса…"
					aria-autocomplete="list"
					aria-controls="teacher-suggestions"
				/>
				<ul id="teacher-suggestions" role="listbox"></ul>
			</div>

			<form id="newTeacherCourseForm" class="course-form">
				<input name="title" placeholder="Название курса" required />
				<input name="description" placeholder="Описание курса" required />
				<button type="submit"><i class="fas fa-plus"></i> Добавить</button>
			</form>

			<div class="table-wrapper">
				<table id="teacherCoursesTable">
					<thead>
						<tr>
							<th>Название</th>
							<th>Описание</th>
							<th>Дата создания</th>
							<th>Действия</th>
						</tr>
					</thead>
					<tbody id="teacherCoursesBody"></tbody>
				</table>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\html\group.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Группа — Преподавательская панель</title>

		<script src="/static/js/theme-init.js"></script>
		<script src="/static/teacherPanel/script.js" defer></script>

		<link rel="stylesheet" href="/static/adminPanel/style.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/common.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/group.css" />

		<script src="/static/teacherPanel/js/teacherGroupDetail.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/index.html">Главная</a>
				<a href="/static/teacherPanel/html/index.html">Панель учителя</a>
				<a href="/static/teacherPanel/html/courses.html">Курсы</a>
				<a href="/static/teacherPanel/html/tests.html">Тесты</a>
				<a href="/static/teacherPanel/html/questions.html">Вопросы</a>
				<a href="/static/teacherPanel/html/theory.html">Теория</a>
				<a href="/static/teacherPanel/html/groups.html">Мои группы</a>
				<a href="/static/teacherPanel/html/group.html" class="active">Группа</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="user" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>
				Название группы:
				<input
					type="text"
					id="groupNameInput"
					value="..."
					style="font-size: 1.2em; padding: 4px; width: 300px"
				/>
				<button id="saveNameBtn"><i class="fas fa-check"></i> Сохранить</button>
			</h1>

			<div class="search-wrapper">
				<input
					id="teacher-group-search"
					type="text"
					placeholder="Поиск студента…"
					aria-autocomplete="list"
					aria-controls="teacher-group-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="teacher-group-suggestions" role="listbox"></ul>
			</div>

			<h3>Добавить студента</h3>
			<form id="addStudentForm">
				<input
					class="input-add-student"
					type="text"
					name="student_email"
					placeholder="Email студента"
					required
				/>
				<button type="submit" class="submit-students-info">
					<i class="fas fa-plus"></i> Добавить
				</button>

				<br />
				<br />
				<br />

				<h2>Состав группы</h2>
				<div class="table-wrapper">
					<table>
						<thead>
							<tr>
								<th>Email</th>
								<th>ФИО</th>
								<th>Действия</th>
							</tr>
						</thead>
						<tbody id="studentsBody"></tbody>
					</table>
				</div>
			</form>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\html\groups.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1.0" />
		<title>Мои группы — Преподавательская панель</title>

		<!-- 1) Смена темы и общий скрипт -->
		<script src="/static/js/theme-init.js"></script>
		<script src="/static/teacherPanel/script.js" defer></script>

		<!-- 2) Стили -->
		<link rel="stylesheet" href="/static/adminPanel/style.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/common.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/groups.css" />

		<!-- 3) Скрипт, специфичный для «Моих групп» -->
		<script src="/static/teacherPanel/js/teacherGroups.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/index.html">Главная</a>
				<a href="/static/teacherPanel/html/index.html">Панель учителя</a>
				<a href="/static/teacherPanel/html/courses.html">Курсы</a>
				<a href="/static/teacherPanel/html/tests.html">Тесты</a>
				<a href="/static/teacherPanel/html/questions.html">Вопросы</a>
				<a href="/static/teacherPanel/html/theory.html">Теория</a>
				<a href="/static/teacherPanel/html/groups.html" class="active"
					>Мои группы</a
				>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefault" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Мои группы</h1>

			<div class="search-wrapper">
				<input
					id="teacher-group-search"
					type="text"
					placeholder="Поиск группы…"
					aria-autocomplete="list"
					aria-controls="teacher-group-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="teacher-group-suggestions" role="listbox"></ul>
			</div>

			<div class="table-wrapper">
				<table id="teacherGroupsTable">
					<thead>
						<tr>
							<th>ID</th>
							<th>Название</th>
							<th>Действия</th>
						</tr>
					</thead>
					<tbody id="teacherGroupsBody">
						<!-- JS заполнит строки здесь -->
					</tbody>
				</table>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\html\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Панель учителя — Set Learn</title>
		<!-- 1. Инициализация темы -->
		<script src="/static/js/theme-init.js"></script>
		<!-- 2. Стили панели учителя -->
		<link rel="stylesheet" href="/static/teacherPanel/style.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/common.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/index.css" />
		<!-- 3. Font Awesome -->
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<!-- 4. Скрипт панели учителя -->
		<script src="/static/teacherPanel/script.js" defer></script>
	</head>
	<body>
		<!-- NAVBAR -->
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/index.html">Главная</a>
				<a href="/static/teacherPanel/html/index.html" class="active"
					>Панель учителя</a
				>
				<a href="/static/teacherPanel/html/courses.html">Курсы</a>
				<a href="/static/teacherPanel/html/tests.html">Тесты</a>
				<a href="/static/teacherPanel/html/questions.html">Вопросы</a>
				<a href="/static/teacherPanel/html/theory.html">Теория</a>
				<a href="/static/teacherPanel/html/groups.html">Мои группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="avatar" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Панель учителя</h1>
			<div class="tiles">
				<a class="card" href="/static/teacherPanel/html/courses.html"
					>Управление курсами</a
				>
				<a class="card" href="/static/teacherPanel/html/tests.html"
					>Управление тестами</a
				>
				<a class="card" href="/static/teacherPanel/html/questions.html"
					>Управление вопросами</a
				>
				<a class="card" href="/static/teacherPanel/html/theory.html"
					>Управление теорией</a
				>
				<a class="card" href="/static/teacherPanel/html/groups.html"
					>Управление группами</a
				>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\html\questions.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Панель учителя — Вопросы</title>
		<script src="/static/js/theme-init.js"></script>
		<link rel="stylesheet" href="/static/teacherPanel/style.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/common.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/questions.css" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<script src="/static/teacherPanel/script.js" defer></script>
		<script src="/static/teacherPanel/js/questions.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/index.html">Главная</a>
				<a href="/static/teacherPanel/html/index.html">Панель учителя</a>
				<a href="/static/teacherPanel/html/courses.html">Курсы</a>
				<a href="/static/teacherPanel/html/tests.html">Тесты</a>
				<a href="/static/teacherPanel/html/questions.html" class="active"
					>Вопросы</a
				>
				<a href="/static/teacherPanel/html/theory.html">Теория</a>
				<a href="/static/teacherPanel/html/groups.html">Мои группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefault" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Управление вопросами</h1>

			<div class="search-wrapper">
				<input
					id="teacher-question-search"
					type="text"
					placeholder="Поиск вопроса…"
					aria-autocomplete="list"
					aria-controls="teacher-question-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="teacher-question-suggestions" role="listbox"></ul>
			</div>

			<form id="newQuestionForm" class="course-form">
				<select name="test_id" id="testSelect" required>
					<option value="">Выберите тест</option>
				</select>
				<input
					name="question_text"
					type="text"
					placeholder="Текст вопроса"
					required
				/>

				<select name="question_type" id="newQuestionType">
					<option value="open">Открытый</option>
					<option value="closed" selected>Закрытый</option>
				</select>
				<label id="multiAnswerLabel" class="multi-answer-label">
					<input type="checkbox" name="multiple_choice" />
					Несколько ответов
				</label>

				<input
					type="text"
					name="correct_answer_text"
					id="newAnswerInput"
					placeholder="Правильный ответ (для открытых)"
					style="display: none"
				/>

				<button type="submit"><i class="fas fa-plus"></i> Добавить</button>
			</form>

			<div class="table-wrapper">
				<table id="questionsTable">
					<thead>
						<tr>
							<th>Вопрос</th>
							<th>Тип</th>
							<th>Несколько</th>
							<th>Тест ID</th>
							<th>Сложность</th>
							<th>Дата создания</th>
							<th>Ответ / Варианты</th>
							<th>Действия</th>
						</tr>
					</thead>
					<tbody id="questionsBody">
						<!-- Здесь JS динамически создаёт строки вопросов и их варианты -->
					</tbody>
				</table>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\html\tests.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Панель учителя — Тесты</title>
		<script src="/static/js/theme-init.js"></script>
		<link rel="stylesheet" href="/static/teacherPanel/style.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/common.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/tests.css" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>
		<script src="/static/teacherPanel/script.js" defer></script>
		<script src="/static/teacherPanel/js/tests.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/index.html">Главная</a>
				<a href="/static/teacherPanel/html/index.html">Панель учителя</a>
				<a href="/static/teacherPanel/html/courses.html">Курсы</a>
				<a href="/static/teacherPanel/html/tests.html" class="active">Тесты</a>
				<a href="/static/teacherPanel/html/questions.html">Вопросы</a>
				<a href="/static/teacherPanel/html/theory.html">Теория</a>
				<a href="/static/teacherPanel/html/groups.html">Мои группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefault" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1>Управление тестами</h1>

			<div class="search-wrapper">
				<input
					id="teacher-test-search"
					type="text"
					placeholder="Поиск теста…"
					aria-autocomplete="list"
					aria-controls="teacher-test-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="teacher-test-suggestions" role="listbox"></ul>
			</div>

			<form id="newTestForm" class="course-form">
				<select name="course_id" required>
					<option value="">Выберите курс</option>
				</select>
				<input name="title" placeholder="Название теста" required />
				<input name="description" placeholder="Описание теста" required />
				<button type="submit"><i class="fas fa-plus"></i> Добавить</button>
			</form>

			<div class="table-wrapper">
				<table id="testsTable">
					<thead>
						<tr>
							<th>Название</th>
							<th>Описание</th>
							<th>Курс ID</th>
							<th>Дата создания</th>
							<th>Действия</th>
						</tr>
					</thead>
					<tbody id="testsBody">
						<!-- JS заполнит сюда строки вида:
          <tr>
            <td>Название теста</td>
            <td>Описание теста</td>
            <td>42</td>
            <td>2025-05-10</td>
            <td>
              <button
                class="btn"
                data-action="open-quick-modal"
                data-test-id="${test.id}"
              >
                Добавить вопросы
              </button>
            </td>
          </tr>
          --></tbody>
				</table>
			</div>
		</main>

		<!-- Быстрая модалка -->
		<div id="questionModal" class="modal-overlay" style="display: none">
			<div class="modal-content">
				<div class="modal-header">
					<h3>Добавить вопросы</h3>
					<button class="modal-close" id="closeQuestionModal">&times;</button>
				</div>
				<div class="modal-body">
					<form id="quickQuestionForm" class="quick-form">
						<input type="hidden" id="quickTestId" name="test_id" />
						<div class="form-group">
							<label for="question_text">Текст вопроса</label>
							<textarea
								id="question_text"
								name="question_text"
								required
							></textarea>
						</div>
						<div class="form-group inline">
							<label for="question_type">Тип вопроса</label>
							<select id="question_type" name="question_type">
								<option value="closed" selected>Закрытый</option>
								<option value="open">Открытый</option>
							</select>
							<label id="multiLabel">
								<input
									type="checkbox"
									id="multiple_choice"
									name="multiple_choice"
								/>
								Несколько ответов
							</label>
							<input
								type="text"
								id="quick_correct_answer"
								name="correct_answer_text"
								placeholder="Правильный ответ (для открытого)"
								style="display: none; margin-left: 1rem"
							/>
						</div>
						<button type="submit" class="btn add-question">
							<i class="fas fa-plus"></i> Добавить
						</button>
					</form>

					<!-- Список вопросов -->
					<ul id="quickQuestionsList" class="quick-questions-list">
						<!-- Добавляется JS -->
					</ul>
				</div>

				<div class="modal-footer">
					<button class="btn save-questions" id="saveQuickQuestions" disabled>
						<i class="fas fa-save"></i> Сохранить всё
					</button>
				</div>

				<div id="unsavedConfirm" class="unsaved-confirm" style="display: none">
					<p>Вы не сохранили изменения</p>
					<button class="btn confirm-close" id="forceClose">
						Всё равно закрыть
					</button>
					<button class="btn cancel-close" id="cancelClose">Отмена</button>
				</div>
			</div>
		</div>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\html\theory.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Панель учителя — Теория</title>

		<!-- Стили приложения -->
		<link rel="stylesheet" href="/static/teacherPanel/style.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/common.css" />
		<link rel="stylesheet" href="/static/teacherPanel/css/theory.css" />

		<!-- FontAwesome -->
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
		/>

		<!-- Quill WYSIWYG -->
		<link
			href="https://cdn.quilljs.com/1.3.6/quill.snow.css"
			rel="stylesheet"
		/>

		<!-- Скрипты -->
		<script src="/static/js/theme-init.js"></script>
		<script src="https://cdn.quilljs.com/1.3.6/quill.min.js" defer></script>
		<script src="/static/teacherPanel/script.js" defer></script>
		<script src="/static/teacherPanel/js/common.js" defer></script>
		<script src="/static/teacherPanel/js/theory.js" defer></script>
	</head>

	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/index.html">Главная</a>
				<a href="/static/teacherPanel/html/index.html">Панель учителя</a>
				<a href="/static/teacherPanel/html/courses.html">Курсы</a>
				<a href="/static/teacherPanel/html/tests.html">Тесты</a>
				<a href="/static/teacherPanel/html/questions.html">Вопросы</a>
				<a href="/static/teacherPanel/html/theory.html" class="active"
					>Теория</a
				>
				<a href="/static/teacherPanel/html/groups.html">Мои группы</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="userDefault" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1 id="page-title">Управление теорией</h1>

			<div class="search-wrapper">
				<input
					id="teacher-theory-search"
					type="text"
					placeholder="Поиск темы…"
					aria-autocomplete="list"
					aria-controls="teacher-theory-suggestions"
				/>
				<button class="clear-search" aria-label="Очистить поиск">
					&times;
				</button>
				<ul id="teacher-theory-suggestions" role="listbox"></ul>
			</div>

			<!-- Loading overlay и спиннер -->
			<div id="loading-overlay" class="hidden">
				<div class="spinner"></div>
			</div>

			<!-- Контейнер для тостов -->
			<div id="toast-container" aria-live="polite"></div>

			<!-- Форма быстрого создания новой темы -->
			<form id="newTheoryForm" class="cards-toolbar">
				<select id="theoryCourseSelect" name="course_id" required>
					<option value="" disabled selected>Выберите курс</option>
					<!-- JS вставит опции курсов -->
				</select>
				<input
					type="text"
					id="new-theory-title"
					name="title"
					placeholder="Название темы"
					required
				/>
				<button type="submit" class="btn btn-primary">
					<i class="fas fa-plus"></i> Добавить тему
				</button>
			</form>

			<!-- Контейнер карточек для существующих тем -->
			<div id="theoryCards" class="cards-container">
				<!-- JS будет туда добавлять .theory-card -->
			</div>

			<!-- Модалка для редактирования содержимого темы -->
			<div id="theoryModal" class="modal hidden">
				<div class="modal-overlay"></div>
				<div class="modal-content">
					<h2>Редактировать содержание</h2>

					<!-- Контейнер Quill -->
					<div id="editorContainer">
						<div id="editorToolbar">
							<span class="ql-formats">
								<select class="ql-header">
									<option selected></option>
									<option value="1"></option>
									<option value="2"></option>
								</select>
								<button class="ql-bold"></button>
								<button class="ql-italic"></button>
							</span>
							<span class="ql-formats">
								<button class="ql-image"></button>
								<button id="ql-insert-pdf" type="button">
									<i class="fas fa-file-pdf"></i>
								</button>
							</span>
						</div>
						<div id="editorCanvas"></div>
					</div>

					<div class="modal-footer">
						<button id="saveTheoryContent" class="btn btn-primary">
							Сохранить
						</button>
						<button id="closeTheoryModal" class="btn" type="button">
							Отмена
						</button>
					</div>
				</div>
			</div>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\common.js
// -----------------------
// 1. Навигация
// -----------------------
function navigate(url) {
	window.location.href = url
}

// -----------------------
// 2. Загрузка аватарки
// -----------------------
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null // не залогинен или другая ошибка
		const user = await res.json()
		if (user.avatar_path) {
			const img = document.querySelector('.user-icon img')
			if (img) img.src = user.avatar_path
		}
		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

/* -----------------------
   1. Обновление иконки темы
------------------------ */
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = ''
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

/* --------------------
       5. Тема
  --------------------- */
const stored = localStorage.getItem('theme')
const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
const theme = stored || (prefersDark ? 'dark' : 'light')
document.documentElement.setAttribute('data-theme', theme)
updateToggleIcon(theme)

const toggle = document.getElementById('theme-toggle')
if (toggle) {
	toggle.addEventListener('click', () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	})
}

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\courses.js
// Поиск с подсветкой подстроки в подсказках
function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initTeacherCourseSearch() {
	const input = document.getElementById('teacher-course-search')
	const sugg = document.getElementById('teacher-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn =
		wrapper.querySelector('.clear-search') ||
		(() => {
			const btn = document.createElement('button')
			btn.className = 'clear-search'
			btn.setAttribute('aria-label', 'Очистить поиск')
			btn.innerHTML = '&times;'
			wrapper.appendChild(btn)
			return btn
		})()

	const tbody = document.getElementById('teacherCoursesBody')
	const rows = Array.from(tbody.querySelectorAll('tr'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowData(row) {
		const inputs = row.querySelectorAll('input.edit-text')
		const title = inputs[0]?.value.trim().toLowerCase() || ''
		const description = inputs[1]?.value.trim().toLowerCase() || ''
		return { title, description }
	}

	function isFuzzy(text, q) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows

		let matches = rows.filter(r => getRowData(r).title === query)
		if (matches.length) return matches

		matches = rows.filter(r => {
			const data = getRowData(r)
			return data.title.includes(query) || data.description.includes(query)
		})
		if (matches.length) return matches

		return rows.filter(r => {
			const data = getRowData(r)
			return isFuzzy(data.title + ' ' + data.description, query)
		})
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		const before = text.slice(0, idx)
		const match = text.slice(idx, idx + query.length)
		const after = text.slice(idx + query.length)
		return `${before}<mark>${match}</mark>${after}`
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			wrapper.setAttribute('aria-expanded', 'false')
			clearBtn.style.display = 'none'
			rows.forEach(r => (r.style.display = 'table-row'))
			return
		}
		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')
		results.slice(0, 10).forEach((row, idx) => {
			const data = getRowData(row)
			const titleRaw = data.title
			// В оригинале название может быть в любом регистре, берем из input
			const origInput = row.querySelector('input.edit-text')
			const titleDisplay = origInput ? origInput.value : titleRaw
			const highlighted = highlightText(titleDisplay, q.toLowerCase())
			const li = document.createElement('li')
			li.id = `sugg-${idx}`
			li.role = 'option'
			li.innerHTML = highlighted
			li.addEventListener('click', () => selectSuggestion(idx, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(results) {
		rows.forEach(r => (r.style.display = 'none'))
		results.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		const title = row.querySelector('input.edit-text')?.value.trim() || ''
		input.value = title
		renderResults(results)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		currentIndex = -1
		clearBtn.style.display = 'block'
	}

	const debouncedUpdate = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', debouncedUpdate)

	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()
		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const results = filterRows(input.value)
			if (currentIndex > -1 && items.length)
				selectSuggestion(currentIndex, results)
			else renderResults(results)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

document.addEventListener('teacherCourses:loaded', () => {
	if (document.getElementById('teacher-course-search')) {
		initTeacherCourseSearch()
	}
})

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\index.js

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\questions.js
function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initTeacherQuestionSearch() {
	const input = document.getElementById('teacher-question-search')
	const sugg = document.getElementById('teacher-question-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn =
		wrapper.querySelector('.clear-search') ||
		(() => {
			const btn = document.createElement('button')
			btn.className = 'clear-search'
			btn.setAttribute('aria-label', 'Очистить поиск')
			btn.innerHTML = '&times;'
			wrapper.appendChild(btn)
			return btn
		})()

	const tbody = document.getElementById('questionsBody')
	// Только основные строки вопросов (исключая строки с опциями)
	const rows = Array.from(tbody.querySelectorAll('tr:not(.options-row)'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowData(row) {
		const inputEl = row.querySelector('input.edit-text')
		const text = inputEl
			? inputEl.value.trim().toLowerCase()
			: row.cells[0].innerText.trim().toLowerCase()
		return text
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		const before = text.slice(0, idx)
		const match = text.slice(idx, idx + query.length)
		const after = text.slice(idx + query.length)
		return `${before}<mark>${match}</mark>${after}`
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows
		// точное
		let matches = rows.filter(r => getRowData(r) === query)
		if (matches.length) return matches
		// подстрока
		matches = rows.filter(r => getRowData(r).includes(query))
		if (matches.length) return matches
		// нечеткий
		return rows.filter(r => {
			const text = getRowData(r)
			let idx = 0
			for (const ch of text) {
				if (ch === query[idx]) {
					idx++
					if (idx === query.length) return true
				}
			}
			return false
		})
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			clearSearch()
			return
		}
		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((row, idx) => {
			const raw =
				row.querySelector('input.edit-text')?.value || row.cells[0].innerText
			const highlighted = highlightText(raw, q.toLowerCase())
			const li = document.createElement('li')
			li.id = `question-sugg-${idx}`
			li.role = 'option'
			li.innerHTML = highlighted
			li.addEventListener('click', () => selectSuggestion(idx, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(results) {
		rows.forEach(r => (r.style.display = 'none'))
		results.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		const title =
			row.querySelector('input.edit-text')?.value || row.cells[0].innerText
		input.value = title
		renderResults(results)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const debounced = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', debounced)
	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()
		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterRows(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})
	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

// Ждём события после загрузки вопросов из loadQuestions()
document.addEventListener('teacherQuestions:loaded', () => {
	if (document.getElementById('teacher-question-search')) {
		initTeacherQuestionSearch()
	}
})

function updateDifficultyStyles() {
	document.querySelectorAll('.edit-difficulty').forEach(select => {
		select.classList.remove('easy', 'medium', 'hard')
		const value = select.value
		select.classList.add(value)
	})
}

document.getElementById('questionsBody').addEventListener('change', e => {
	if (e.target.classList.contains('edit-difficulty')) {
		e.target.classList.remove('easy', 'medium', 'hard')
		const value = e.target.value
		e.target.classList.add(value)
	}
})

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\teacherGroupDetail.js
// Получение ID группы из URL
function getGroupIdFromURL() {
	const params = new URLSearchParams(window.location.search)
	const id = params.get('id')
	console.log('[DEBUG] groupId from URL:', id)
	return id
}

// Загрузка и отрисовка состава группы
async function initTeacherGroupDetail() {
	console.log('[DEBUG] initTeacherGroupDetail() start')
	const groupId = getGroupIdFromURL()
	if (!groupId) {
		console.error('[ERROR] no groupId in URL')
		alert('Не указан ID группы в URL')
		return
	}

	let res, group
	try {
		console.log(`[DEBUG] fetching /api/teacher/groups/${groupId}`)
		res = await fetch(`/api/teacher/groups/${groupId}`, {
			credentials: 'include',
		})
	} catch (err) {
		console.error('[ERROR] fetch threw:', err)
		alert('Ошибка сети при загрузке группы')
		return
	}

	console.log('[DEBUG] fetch response status:', res.status)
	if (!res.ok) {
		const text = await res.text().catch(() => '')
		console.error('[ERROR] fetch response not ok:', res.status, text)
		alert('Ошибка загрузки группы: ' + text)
		return
	}

	try {
		group = await res.json()
		console.log('[DEBUG] group JSON:', group)
	} catch (err) {
		console.error('[ERROR] JSON parse error:', err)
		alert('Ошибка разбора ответа от сервера')
		return
	}

	// ----------------------------------------
	// 1) Название: помещаем в input
	// ----------------------------------------
	const nameInput = document.getElementById('groupNameInput')
	if (!nameInput) {
		console.error('[ERROR] #groupNameInput element not found')
	} else {
		nameInput.value = group.name
		console.log('[DEBUG] set groupNameInput to:', group.name)
	}

	// ----------------------------------------
	// 2) Студенты
	// ----------------------------------------
	const tbody = document.getElementById('studentsBody')
	if (!tbody) {
		console.error('[ERROR] #studentsBody element not found')
		return
	}
	tbody.innerHTML = ''

	if (!Array.isArray(group.students)) {
		console.error('[ERROR] group.students is not array:', group.students)
		tbody.innerHTML =
			'<tr><td colspan="3">Неверный формат данных студентов</td></tr>'
		return
	}

	if (group.students.length === 0) {
		tbody.innerHTML =
			'<tr><td colspan="3" style="text-align:center;">Нет студентов в группе</td></tr>'
		console.log('[DEBUG] no students to render')
	} else {
		group.students.forEach(s => {
			console.log('[DEBUG] render student:', s)
			const tr = document.createElement('tr')
			tr.innerHTML = `
		  <td>${s.email}</td>
		  <td>${s.full_name}</td>
		  <td>
			<button class="remove-student-btn" data-id="${s.id}">
			  <i class="fas fa-trash"></i> Удалить
			</button>
		  </td>`
			tbody.appendChild(tr)
		})
	}
	document.dispatchEvent(new CustomEvent('teacherGroupDetail:loaded'))
}
document.addEventListener('teacherGroupDetail:loaded', initTeacherGroupSearch)

// поисковая строка
function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initTeacherGroupSearch() {
	const input = document.getElementById('teacher-group-search')
	const sugg = document.getElementById('teacher-group-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn = wrapper.querySelector('.clear-search')

	// все строки студентов
	const tbody = document.getElementById('studentsBody')
	const rows = Array.from(tbody.querySelectorAll('tr'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowData(row) {
		const email = row.cells[0].innerText.trim().toLowerCase()
		const name = row.cells[1].innerText.trim().toLowerCase()
		return { email, name }
	}

	function isFuzzy(text, q) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows

		// 1) точное совпадение email или ФИО
		let matches = rows.filter(r => {
			const d = getRowData(r)
			return d.email === query || d.name === query
		})
		if (matches.length) return matches

		// 2) подстрока
		matches = rows.filter(r => {
			const d = getRowData(r)
			return d.email.includes(query) || d.name.includes(query)
		})
		if (matches.length) return matches

		// 3) нечеткий поиск
		return rows.filter(r => {
			const d = getRowData(r)
			return isFuzzy(d.email + ' ' + d.name, query)
		})
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		const before = text.slice(0, idx)
		const match = text.slice(idx, idx + query.length)
		const after = text.slice(idx + query.length)
		return `${before}<mark>${match}</mark>${after}`
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			clearSearch()
			return
		}

		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((row, i) => {
			const data = getRowData(row)
			// отображаем email и ФИО
			const raw = `${row.cells[0].innerText} — ${row.cells[1].innerText}`
			const li = document.createElement('li')
			li.id = `group-sugg-${i}`
			li.role = 'option'
			li.innerHTML = highlightText(raw, q.toLowerCase())
			li.addEventListener('click', () => selectSuggestion(i, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(res) {
		rows.forEach(r => (r.style.display = 'none'))
		res.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		// Собираем оригинальный raw (email — name)
		const raw = `${row.cells[0].innerText} — ${row.cells[1].innerText}`
		// Берём только ту часть до " — "
		const key = raw.split(' — ')[0]
		// Подставляем в input только email (или ключевую часть)
		input.value = key
		// Применяем фильтр по ключу, чтобы оставить одну строку
		const filtered = filterRows(key)
		renderResults(filtered)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const deb = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', deb)

	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()

		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterRows(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

document.addEventListener('DOMContentLoaded', () => {
	console.log('[DEBUG] DOMContentLoaded')
	initTeacherGroupDetail()

	// ----------------------------------------
	// Обработчик: сохранить новое название
	// ----------------------------------------
	const saveBtn = document.getElementById('saveNameBtn')
	const nameInput = document.getElementById('groupNameInput')
	if (saveBtn && nameInput) {
		saveBtn.addEventListener('click', async () => {
			const groupId = getGroupIdFromURL()
			const newName = nameInput.value.trim()
			if (!newName) {
				alert('Название не может быть пустым')
				return
			}

			console.log('[DEBUG] saving new group name:', newName)
			let res, text
			try {
				res = await fetch(`/api/teacher/groups/${groupId}`, {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ name: newName }),
				})
			} catch (err) {
				console.error('[ERROR] PUT fetch threw:', err)
				alert('Ошибка сети при сохранении названия')
				return
			}

			console.log('[DEBUG] save name response status:', res.status)
			if (!res.ok) {
				text = await res.text().catch(() => '')
				console.error('[ERROR] save name failed:', res.status, text)
				alert('Ошибка сохранения: ' + text)
				return
			}
			console.log('[DEBUG] save name succeeded')
			alert('Название группы сохранено')
		})
	} else {
		console.error('[ERROR] saveNameBtn or groupNameInput not found')
	}

	// ----------------------------------------
	// Обработчик: удалить студента
	// ----------------------------------------
	const studentsBody = document.getElementById('studentsBody')
	if (studentsBody) {
		studentsBody.addEventListener('click', async e => {
			const btn = e.target.closest('.remove-student-btn')
			if (!btn) return
			console.log('[DEBUG] remove-student-btn clicked, id=', btn.dataset.id)
			if (!confirm('Удалить студента из группы?')) return

			const studentId = +btn.dataset.id
			const groupId = getGroupIdFromURL()
			console.log('[DEBUG] sending DELETE student-groups', {
				student_id: studentId,
				group_id: groupId,
			})

			let res, text
			try {
				res = await fetch('/api/teacher/student-groups', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ student_id: studentId, group_id: +groupId }),
				})
			} catch (err) {
				console.error('[ERROR] DELETE fetch threw:', err)
				alert('Ошибка сети при удалении студента')
				return
			}

			console.log('[DEBUG] DELETE response status:', res.status)
			if (!res.ok) {
				text = await res.text().catch(() => '<no body>')
				console.error('[ERROR] remove failed:', res.status, text)
				alert('Ошибка удаления: ' + text)
				return
			}

			console.log('[DEBUG] remove succeeded, reloading detail')
			await initTeacherGroupDetail()
		})
	} else {
		console.error('[ERROR] studentsBody not found')
	}

	// ----------------------------------------
	// Обработчик: добавить студента
	// ----------------------------------------
	const addForm = document.getElementById('addStudentForm')
	if (addForm) {
		addForm.addEventListener('submit', async e => {
			e.preventDefault()
			console.log('[DEBUG] addStudentForm submit')
			const email = addForm.student_email.value.trim()
			const groupId = getGroupIdFromURL()

			if (!email) {
				console.warn('[WARN] email empty')
				alert('Введите email студента')
				return
			}

			console.log('[DEBUG] sending PUT student-groups', {
				student_email: email,
				group_id: +groupId,
			})

			let res, text
			try {
				res = await fetch('/api/teacher/student-groups', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ student_email: email, group_id: +groupId }),
				})
			} catch (err) {
				console.error('[ERROR] PUT fetch threw:', err)
				alert('Ошибка сети при добавлении студента')
				return
			}

			console.log('[DEBUG] PUT response status:', res.status)
			if (!res.ok) {
				text = await res.text().catch(() => '<no body>')
				console.error('[ERROR] add failed:', res.status, text)
				alert('Ошибка добавления: ' + text)
				return
			}

			console.log('[DEBUG] add succeeded, reloading detail')
			addForm.reset()
			await initTeacherGroupDetail()
		})
	} else {
		console.error('[ERROR] addStudentForm not found')
	}
})

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\teacherGroups.js
// Инициализация страницы "Мои группы"
async function initTeacherGroups() {
	const tbody = document.getElementById('teacherGroupsBody')
	tbody.innerHTML = 'Загрузка...'

	try {
		const res = await fetch('/api/teacher/groups', { credentials: 'include' })
		if (!res.ok) throw new Error('Не удалось загрузить список групп')

		const groups = await res.json()

		if (!groups || !Array.isArray(groups)) {
			throw new Error('Получены некорректные данные')
		}

		tbody.innerHTML = ''

		if (groups.length === 0) {
			tbody.innerHTML =
				'<tr><td colspan="3" style="text-align:center;">Нет доступных групп</td></tr>'
			return
		}

		groups.forEach(g => {
			const tr = document.createElement('tr')
			tr.innerHTML = `
		  <td>${g.id}</td>
		  <td>${g.name}</td>
		  <td>
			<button class="view-group-btn" data-id="${g.id}">
			  <i class="fas fa-eye"></i> Просмотреть
			</button>
		  </td>
		`
			tbody.appendChild(tr)
		})

		document.dispatchEvent(new CustomEvent('teacherGroups:loaded'))
	} catch (err) {
		tbody.innerHTML = '<tr><td colspan="3">Ошибка загрузки</td></tr>'
		console.error(err)
	}
}

// Обработка клика "Просмотреть"
document.addEventListener('click', e => {
	const btn = e.target.closest('.view-group-btn')
	if (!btn) return

	const id = btn.dataset.id
	if (id) {
		window.location.href = `/static/teacherPanel/html/group.html?id=${id}`
	}
})

// static/teacherPanel/js/groups.js
// Поиск по группам (без input-полей) с подсветкой и подсказками

function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initTeacherGroupSearch() {
	const input = document.getElementById('teacher-group-search')
	const sugg = document.getElementById('teacher-group-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn = wrapper.querySelector('.clear-search')

	const tbody = document.getElementById('teacherGroupsBody')
	const rows = Array.from(tbody.querySelectorAll('tr'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowText(row) {
		// Название группы во втором столбце
		return row.cells[1].innerText.trim().toLowerCase()
	}

	function isFuzzy(text, q) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows

		// точное совпадение
		let matches = rows.filter(r => getRowText(r) === query)
		if (matches.length) return matches

		// подстрока
		matches = rows.filter(r => getRowText(r).includes(query))
		if (matches.length) return matches

		// нечеткий поиск
		return rows.filter(r => isFuzzy(getRowText(r), query))
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		const before = text.slice(0, idx)
		const match = text.slice(idx, idx + query.length)
		const after = text.slice(idx + query.length)
		return `${before}<mark>${match}</mark>${after}`
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			clearSearch()
			return
		}

		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((row, idx) => {
			const raw = row.cells[1].innerText
			const highlighted = highlightText(raw, q.toLowerCase())
			const li = document.createElement('li')
			li.id = `group-sugg-${idx}`
			li.role = 'option'
			li.innerHTML = highlighted
			li.addEventListener('click', () => selectSuggestion(idx, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(results) {
		rows.forEach(r => (r.style.display = 'none'))
		results.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		const raw = row.cells[1].innerText
		input.value = raw
		renderResults(results)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const debounced = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', debounced)
	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()

		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterRows(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

// Запуск при загрузке
document.addEventListener('DOMContentLoaded', () => {
	if (document.getElementById('teacher-group-search')) {
		document.addEventListener('teacherGroups:loaded', () => {
			initTeacherGroupSearch()
		})
	}
	if (document.getElementById('teacherGroupsBody')) {
		initTeacherGroups()
	}
})

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\tests.js
// static/teacherPanel/js/tests.js
// Поиск тестов с подсветкой подстроки в подсказках

function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initTeacherTestSearch() {
	const input = document.getElementById('teacher-test-search')
	const sugg = document.getElementById('teacher-test-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn =
		wrapper.querySelector('.clear-search') ||
		(() => {
			const btn = document.createElement('button')
			btn.className = 'clear-search'
			btn.setAttribute('aria-label', 'Очистить поиск')
			btn.innerHTML = '&times;'
			wrapper.appendChild(btn)
			return btn
		})()

	const tbody = document.getElementById('testsBody')
	const rows = Array.from(tbody.querySelectorAll('tr'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		rows.forEach(r => (r.style.display = 'table-row'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getRowData(row) {
		// Для тестов мы тоже считаем, что первые два столбца — это <input class="edit-text">
		const inputs = row.querySelectorAll('input.edit-text')
		const title =
			inputs[0]?.value.trim().toLowerCase() ||
			row.cells[0].innerText.trim().toLowerCase()
		const description =
			inputs[1]?.value.trim().toLowerCase() ||
			row.cells[1].innerText.trim().toLowerCase()
		return { title, description }
	}

	function isFuzzy(text, q) {
		let idx = 0
		for (const ch of text) {
			if (ch === q[idx]) {
				idx++
				if (idx === q.length) return true
			}
		}
		return false
	}

	function filterRows(q) {
		const query = q.trim().toLowerCase()
		if (!query) return rows

		// точное совпадение по названию
		let matches = rows.filter(r => getRowData(r).title === query)
		if (matches.length) return matches

		// подстрока
		matches = rows.filter(r => {
			const d = getRowData(r)
			return d.title.includes(query) || d.description.includes(query)
		})
		if (matches.length) return matches

		// нечеткий поиск
		return rows.filter(r => {
			const d = getRowData(r)
			return isFuzzy(d.title + ' ' + d.description, query)
		})
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		const before = text.slice(0, idx)
		const match = text.slice(idx, idx + query.length)
		const after = text.slice(idx + query.length)
		return `${before}<mark>${match}</mark>${after}`
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterRows(q)
		if (!q) {
			wrapper.setAttribute('aria-expanded', 'false')
			clearBtn.style.display = 'none'
			rows.forEach(r => (r.style.display = 'table-row'))
			return
		}
		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((row, idx) => {
			// Берём исходный заголовок из input или из ячейки
			const rawText =
				row.querySelector('input.edit-text')?.value || row.cells[0].innerText
			const highlighted = highlightText(rawText, q.toLowerCase())
			const li = document.createElement('li')
			li.id = `test-sugg-${idx}`
			li.role = 'option'
			li.innerHTML = highlighted
			li.addEventListener('click', () => selectSuggestion(idx, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(results) {
		rows.forEach(r => (r.style.display = 'none'))
		results.forEach(r => (r.style.display = 'table-row'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const row = results[idx]
		const title =
			row.querySelector('input.edit-text')?.value || row.cells[0].innerText
		input.value = title
		renderResults(results)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const debouncedUpdate = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', debouncedUpdate)

	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()

		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterRows(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

// Ждём события после загрузки и отрисовки тестов в script.js
document.addEventListener('teacherTests:loaded', () => {
	if (document.getElementById('teacher-test-search')) {
		initTeacherTestSearch()
	}
})

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\js\theory.js
function debounce(fn, ms = 300) {
	let timer
	return (...args) => {
		clearTimeout(timer)
		timer = setTimeout(() => fn(...args), ms)
	}
}

function initTeacherTheorySearch() {
	const input = document.getElementById('teacher-theory-search')
	const sugg = document.getElementById('teacher-theory-suggestions')
	const wrapper = document.querySelector('.search-wrapper')
	const clearBtn = wrapper.querySelector('.clear-search')

	// Собираем все карточки, отрисованные reloadTheoryList()
	const cards = Array.from(document.querySelectorAll('.theory-card'))
	let currentIndex = -1

	clearBtn.style.display = 'none'

	function clearSearch() {
		input.value = ''
		cards.forEach(c => (c.style.display = 'flex'))
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'none'
		currentIndex = -1
	}

	function getCardTitle(card) {
		// Заголовок темы хранится в <input class="title-input">
		const inp = card.querySelector('input.title-input')
		return inp ? inp.value.trim().toLowerCase() : ''
	}

	function isFuzzy(text, query) {
		const textLower = text.toLowerCase()
		let queryIndex = 0
		for (let i = 0; i < textLower.length; i++) {
			if (textLower[i] === query[queryIndex]) queryIndex++
			if (queryIndex === query.length) return true
		}
		return false
	}

	function filterCards(q) {
		const query = q.trim().toLowerCase()
		if (!query) return cards

		// точное совпадение
		let matches = cards.filter(c => getCardTitle(c) === query)
		if (matches.length) return matches

		// подстрока
		matches = cards.filter(c => getCardTitle(c).includes(query))
		if (matches.length) return matches

		// нечеткий поиск
		return cards.filter(c => isFuzzy(getCardTitle(c), query))
	}

	function highlightText(text, query) {
		const lower = text.toLowerCase()
		const idx = lower.indexOf(query)
		if (idx === -1) return text
		const before = text.slice(0, idx)
		const match = text.slice(idx, idx + query.length)
		const after = text.slice(idx + query.length)
		return `${before}<mark>${match}</mark>${after}`
	}

	function updateSuggestions(q) {
		sugg.innerHTML = ''
		currentIndex = -1
		const results = filterCards(q)
		if (!q) {
			clearSearch()
			return
		}

		clearBtn.style.display = 'block'
		wrapper.setAttribute('aria-expanded', 'true')

		results.slice(0, 10).forEach((card, i) => {
			const raw = card.querySelector('input.title-input').value
			const li = document.createElement('li')
			li.id = `theory-sugg-${i}`
			li.role = 'option'
			li.innerHTML = highlightText(raw, q.toLowerCase())
			li.addEventListener('click', () => selectSuggestion(i, results))
			sugg.appendChild(li)
		})
	}

	function renderResults(res) {
		cards.forEach(c => (c.style.display = 'none'))
		res.forEach(c => (c.style.display = 'flex'))
	}

	function highlightItem(items, idx) {
		items.forEach((li, i) => li.classList.toggle('active', i === idx))
		if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' })
	}

	function selectSuggestion(idx, results) {
		const card = results[idx]
		const raw = card.querySelector('input.title-input').value
		input.value = raw
		renderResults(results)
		sugg.innerHTML = ''
		wrapper.setAttribute('aria-expanded', 'false')
		clearBtn.style.display = 'block'
		currentIndex = -1
	}

	const deb = debounce(e => updateSuggestions(e.target.value))
	input.addEventListener('input', deb)

	input.addEventListener('keydown', e => {
		const items = Array.from(sugg.children)
		if (['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(e.key))
			e.preventDefault()

		if (e.key === 'ArrowDown' && items.length) {
			currentIndex = (currentIndex + 1) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'ArrowUp' && items.length) {
			currentIndex = (currentIndex - 1 + items.length) % items.length
			highlightItem(items, currentIndex)
		} else if (e.key === 'Enter') {
			const res = filterCards(input.value)
			if (currentIndex > -1 && items.length) selectSuggestion(currentIndex, res)
			else renderResults(res)
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
		} else if (e.key === 'Escape') {
			clearSearch()
		}
	})

	clearBtn.addEventListener('click', clearSearch)
	document.addEventListener('click', e => {
		if (!wrapper.contains(e.target)) {
			sugg.innerHTML = ''
			wrapper.setAttribute('aria-expanded', 'false')
			currentIndex = -1
		}
	})
}

// Слушаем событие после перерисовки тем в reloadTheoryList()
document.addEventListener('teacherTheory:loaded', initTeacherTheorySearch)

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\script.js
// -----------------------
// 1. Навигация
// -----------------------
function navigate(url) {
	window.location.href = url
}

// -----------------------
// 2. Загрузка аватарки
// -----------------------
async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return null // не залогинен или другая ошибка
		const user = await res.json()
		if (user.avatar_path) {
			const img = document.querySelector('.user-icon img')
			if (img) img.src = user.avatar_path
		}
		return user
	} catch (err) {
		console.error('Error loading user icon:', err)
		return null
	}
}

/* -----------------------
   1. Обновление иконки темы
------------------------ */
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = ''
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme'
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'
	btn.appendChild(icon)
}

/* --------------------
       5. Тема
  --------------------- */
const stored = localStorage.getItem('theme')
const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
const theme = stored || (prefersDark ? 'dark' : 'light')
document.documentElement.setAttribute('data-theme', theme)
updateToggleIcon(theme)

const toggle = document.getElementById('theme-toggle')
if (toggle) {
	toggle.addEventListener('click', () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	})
}

// ——— State и функции для модалки быстрых вопросов ———
let quickIsDirty = false

function openQuestionModal(testId) {
	document.getElementById('quickTestId').value = testId
	document.getElementById('questionModal').style.display = 'flex'
	quickIsDirty = false
	document.getElementById('saveQuickQuestions').disabled = true
	clearQuickModal()
}

function clearQuickModal() {
	document.getElementById('quickQuestionsList').innerHTML = ''
	document.getElementById('quickQuestionForm').reset()
	document.getElementById('quick_correct_answer').style.display = 'none'
}

function tryCloseModal() {
	if (quickIsDirty) {
		document.getElementById('unsavedConfirm').style.display = 'block'
	} else {
		forceCloseModal()
	}
}

function forceCloseModal() {
	document.getElementById('questionModal').style.display = 'none'
	document.getElementById('unsavedConfirm').style.display = 'none'
	clearQuickModal()
	location.reload()
}

function cancelClose() {
	document.getElementById('unsavedConfirm').style.display = 'none'
}

async function saveQuickQuestions() {
	const testId = +document.getElementById('quickTestId').value
	const items = document.querySelectorAll('#quickQuestionsList .question-item')

	for (let li of items) {
		// Сохраняем сам вопрос
		const qRes = await fetch('/api/teacher/questions', {
			method: 'POST',
			credentials: 'include',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				test_id: testId,
				question_text: li.querySelector('.question-text')?.textContent ?? '',
				question_type: li.dataset.type,
				multiple_choice: li.dataset.multi === 'true',
				correct_answer_text:
					li.dataset.type === 'open' ? li.dataset.correct : null,
			}),
		})

		if (!qRes.ok) throw new Error('Не удалось сохранить вопрос')

		const { id: questionId } = await qRes.json()

		// Сохраняем варианты
		if (li.dataset.type === 'closed') {
			const opts = li.querySelectorAll('li.option-item')
			for (let opt of opts) {
				const textEl = opt.querySelector('.option-text')
				if (!textEl) continue

				const isCorrect = opt.dataset.correct === 'true'

				await fetch('/api/teacher/options', {
					method: 'POST',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						question_id: questionId,
						option_text: textEl.textContent.trim(),
						is_correct: isCorrect,
					}),
				})
			}
		}
	}

	quickIsDirty = false
	document.getElementById('saveQuickQuestions').disabled = true
	forceCloseModal()
}

function renumberQuestions() {
	document
		.querySelectorAll('#quickQuestionsList .question-item')
		.forEach((li, idx) => {
			const num = li.querySelector('.question-number')
			if (num) num.textContent = `${idx + 1}.`
		})
}

// -----------------------
// loadOptions
// -----------------------
async function loadOptions(questionId) {
	const tbodyOpts = document.getElementById(`opts-${questionId}`)
	if (!tbodyOpts) return
	tbodyOpts.innerHTML = ''
	try {
		const res = await fetch(`/api/teacher/options?question_id=${questionId}`, {
			credentials: 'include',
		})
		if (!res.ok) throw ''
		const opts = await res.json()
		opts.forEach(o => {
			const tr = document.createElement('tr')
			tr.innerHTML = `
        <td><input class="edit-opt-text" data-id="${o.id}" value="${
				o.option_text
			}"></td>
        <td><input type="checkbox" class="edit-opt-correct" data-id="${o.id}"${
				o.is_correct ? ' checked' : ''
			}></td>
        <td>
          <button class="save-option" data-id="${
						o.id
					}"><i class="fas fa-save"></i></button>
          <button class="del-option" data-id="${
						o.id
					}"><i class="fas fa-trash"></i></button>
        </td>`
			tbodyOpts.appendChild(tr)
		})
	} catch {
		console.error('Ошибка загрузки вариантов')
	}
}

async function loadQuestions(testId) {
	const tbody = document.getElementById('questionsBody')
	tbody.innerHTML = ''
	if (!testId) return
	try {
		const res = await fetch(`/api/teacher/questions?test_id=${testId}`, {
			credentials: 'include',
		})
		if (!res.ok) throw ''
		const qs = await res.json()
		qs.forEach(q => {
			// Основная строка
			const tr = document.createElement('tr')
			tr.innerHTML = `
        <td><input class="edit-text" data-id="${q.id}" value="${
				q.question_text
			}"></td>
        <td>
          <select class="edit-type" data-id="${q.id}">
            <option value="open"${
							q.question_type === 'open' ? ' selected' : ''
						}>Открытый</option>
            <option value="closed"${
							q.question_type === 'closed' ? ' selected' : ''
						}>Закрытый</option>
          </select>
        </td>
        <td>
          <input
            type="checkbox"
            class="edit-multi ${
							q.question_type === 'open' ? 'checkbox-disabled' : ''
						}"
            data-id="${q.id}"
            ${q.multiple_choice ? 'checked' : ''}
            ${q.question_type === 'open' ? 'disabled' : ''}
          >
        </td>
        <td>${q.test_id}</td>
        <td>
          <select class="edit-difficulty" data-id="${q.id}">
            <option value="easy"${
							q.difficulty === 'easy' ? ' selected' : ''
						}>лёгкий</option>
            <option value="medium"${
							q.difficulty === 'medium' ? ' selected' : ''
						}>средний</option>
            <option value="hard"${
							q.difficulty === 'hard' ? ' selected' : ''
						}>сложный</option>
          </select>
        </td>
        <td>${new Date(q.created_at).toLocaleDateString()}</td>
        <td>
          <button class="manage-options"
                  data-id="${q.id}"
                  data-type="${q.question_type}">
            <i class="fas fa-list"></i> Варианты
          </button>
        </td>
        <td class="action-cell">
          <button class="save-question" data-id="${
						q.id
					}"><i class="fas fa-save"></i> Сохранить</button>
          <button class="del-question" data-id="${
						q.id
					}"><i class="fas fa-trash"></i> Удалить</button>
        </td>`
			tbody.appendChild(tr)

			// Скрытая строка
			const trOpts = document.createElement('tr')
			trOpts.className = 'options-row'
			trOpts.dataset.qid = q.id
			trOpts.dataset.type = q.question_type
			trOpts.style.display = 'none'

			if (q.question_type === 'closed') {
				trOpts.innerHTML = `
          <td colspan="8">
            <div class="options-wrapper" style="min-height:100px; padding:10px;">
              <table class="options-table">
                <thead><tr><th>Вариант</th><th>Правильный?</th><th>Действия</th></tr></thead>
                <tbody id="opts-${q.id}"></tbody>
              </table>
              <div class="option-form">
                <input type="text" class="new-opt-text" placeholder="Новый вариант">
                <input type="checkbox" class="new-opt-correct">
                <button class="save-new-option" data-id="${q.id}"><i class="fas fa-plus"></i></button>
              </div>
            </div>
          </td>`
			} else {
				trOpts.innerHTML = `
          <td colspan="8">
            <div class="options-wrapper">
              <div class="open-answer-wrapper">
                <label>Правильный ответ:</label>
                <input type="text" class="open-answer-input" value="${
									q.correct_answer_text || ''
								}" />
                <button class="save-open-answer" data-id="${
									q.id
								}">Сохранить</button>
                <button class="delete-open-answer" data-id="${
									q.id
								}">Удалить</button>
              </div>
            </div>
          </td>`
			}
			tbody.appendChild(trOpts)
		})

		document.dispatchEvent(new CustomEvent('teacherQuestions:loaded'))
	} catch {
		console.error('Ошибка загрузки вопросов')
	}
	updateDifficultyStyles()
}

async function initQuestions() {
	const select = document.getElementById('testSelect')

	// 1) Загрузка списка тестов
	try {
		const r = await fetch('/api/teacher/tests', { credentials: 'include' })
		if (!r.ok) throw new Error(r.statusText)
		const ts = await r.json()
		ts.forEach(t => {
			const o = document.createElement('option')
			o.value = t.id
			o.textContent = t.title
			select.appendChild(o)
		})
		if (ts.length) {
			select.value = ts[0].id
			await loadQuestions(ts[0].id)
		}
	} catch (err) {
		console.error('Не удалось загрузить тесты', err)
	}

	// 2) При смене выбранного теста — перезагружаем вопросы
	select.addEventListener('change', () => {
		loadQuestions(select.value)
	})

	// 3) Форма добавления нового вопроса
	const form = document.getElementById('newQuestionForm')
	const typeSelect = document.getElementById('newQuestionType')
	const answerInput = document.getElementById('newAnswerInput')
	const multiCheckboxNew = form.querySelector("input[name='multiple_choice']")
	const multiLabel = document.getElementById('multiAnswerLabel')

	typeSelect.addEventListener('change', () => {
		const isOpen = typeSelect.value === 'open'
		answerInput.style.display = isOpen ? 'block' : 'none'
		multiCheckboxNew.checked = false
		multiCheckboxNew.disabled = isOpen
		multiCheckboxNew.classList.toggle('checkbox-disabled', isOpen)
		multiLabel.classList.toggle('checkbox-disabled', isOpen)
	})

	form.addEventListener('submit', async e => {
		e.preventDefault()
		const fd = new FormData(form)
		const payload = {
			test_id: +fd.get('test_id'),
			question_text: fd.get('question_text'),
			question_type: fd.get('question_type'),
			multiple_choice: fd.get('multiple_choice') === 'on',
			correct_answer_text: fd.get('correct_answer_text') || null,
		}
		try {
			const res = await fetch('/api/teacher/questions', {
				method: 'POST',
				credentials: 'include',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload),
			})
			if (!res.ok) throw new Error(await res.text())
			form.reset()
			answerInput.style.display = 'none'
			await loadQuestions(payload.test_id)
		} catch (err) {
			alert('Ошибка создания вопроса: ' + err.message)
		}
	})

	// 4) Изменение типа вопроса прямо в таблице вопросов
	const tbody = document.getElementById('questionsBody')
	tbody.addEventListener('change', e => {
		if (!e.target.matches('.edit-type')) return
		const sel = e.target
		const id = sel.dataset.id
		const row = sel.closest('tr')
		const multiInput = row.querySelector(`.edit-multi[data-id="${id}"]`)
		const optsBtn = row.querySelector(`.manage-options[data-id="${id}"]`)
		if (sel.value === 'open') {
			multiInput.checked = false
			multiInput.disabled = true
			multiInput.classList.add('checkbox-disabled')
			optsBtn.style.display = 'none'
		} else {
			multiInput.disabled = false
			multiInput.classList.remove('checkbox-disabled')
			optsBtn.style.display = 'inline-block'
		}
	})

	// 5) Делегированный обработчик кликов по таблице вопросов
	tbody.addEventListener('click', async e => {
		// a) Переключение панели вариантов/ответа
		if (e.target.closest('.manage-options')) {
			const btn = e.target.closest('.manage-options')
			const qid = btn.dataset.id
			const row = document.querySelector(`.options-row[data-qid="${qid}"]`)
			const isHidden = getComputedStyle(row).display === 'none'
			if (isHidden) {
				if (btn.dataset.type === 'closed') {
					await loadOptions(qid)
				}
				row.style.display = 'table-row'
			} else {
				row.style.display = 'none'
			}
			return
		}

		// b) Сохранение открытого ответа
		if (e.target.matches('.save-open-answer')) {
			const qid = e.target.dataset.id
			const row = document.querySelector(`.options-row[data-qid="${qid}"]`)
			const answer = row.querySelector('.open-answer-input').value.trim()
			try {
				const res = await fetch('/api/teacher/questions/set_open_answer', {
					method: 'POST',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id: +qid, answer }),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Ответ сохранён')
			} catch (err) {
				console.error(err)
				alert('Не удалось сохранить ответ')
			}
			return
		}

		// c) Удаление открытого ответа
		if (e.target.matches('.delete-open-answer')) {
			const qid = e.target.dataset.id
			if (!confirm('Удалить ответ?')) return
			try {
				const res = await fetch('/api/teacher/questions/set_open_answer', {
					method: 'POST',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id: +qid, answer: '' }),
				})
				if (!res.ok) throw new Error(await res.text())
				const row = document.querySelector(`.options-row[data-qid="${qid}"]`)
				row.querySelector('.open-answer-input').value = ''
				alert('Ответ удалён')
			} catch (err) {
				console.error(err)
				alert('Не удалось удалить ответ')
			}
			return
		}

		// d) Сохранить отредактированный вопрос вместе со всеми вариантами
		if (e.target.matches('.save-question')) {
			const qid = e.target.dataset.id
			const row = e.target.closest('tr')
			const text = row
				.querySelector(`.edit-text[data-id="${qid}"]`)
				.value.trim()
			const type = row.querySelector(`.edit-type[data-id="${qid}"]`).value
			const multi = row.querySelector(`.edit-multi[data-id="${qid}"]`).checked
			const diff = row.querySelector(`.edit-difficulty[data-id="${qid}"]`).value // <-- новое

			const payload = {
				id: +qid,
				question_text: text,
				question_type: type,
				multiple_choice: multi,
				difficulty: diff, // <-- новое поле
			}

			// Для open‑вопросов — корректный ответ
			if (type === 'open') {
				const optionsRow = document.querySelector(
					`.options-row[data-qid="${qid}"]`
				)
				const input = optionsRow?.querySelector('.open-answer-input')
				if (input) payload.correct_answer_text = input.value.trim()
			}

			try {
				// 1) Обновляем сам вопрос
				const resQ = await fetch('/api/teacher/questions', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(payload),
				})
				if (!resQ.ok) throw new Error(await resQ.text())

				// 2) Для закрытых вопросов — обновляем все варианты
				if (type === 'closed') {
					const tbodyOpts = document.getElementById(`opts-${qid}`)
					if (tbodyOpts) {
						for (let rowOpt of tbodyOpts.querySelectorAll('tr')) {
							const oid = rowOpt.querySelector('.edit-opt-text')?.dataset.id
							if (!oid) continue

							const optionText = rowOpt
								.querySelector(`.edit-opt-text[data-id="${oid}"]`)
								.value.trim()
							const isCorrect = rowOpt.querySelector(
								`.edit-opt-correct[data-id="${oid}"]`
							).checked

							const resO = await fetch('/api/teacher/options', {
								method: 'PUT',
								credentials: 'include',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify({
									id: +oid,
									option_text: optionText,
									is_correct: isCorrect,
								}),
							})
							if (!resO.ok) {
								const txt = await resO.text()
								throw new Error(`Ошибка сохранения варианта ${oid}: ${txt}`)
							}
						}
					}
				}

				alert('Вопрос и варианты сохранены')
				await loadQuestions(select.value)
			} catch (err) {
				console.error(err)
				alert(err.message || 'Не удалось сохранить вопрос и варианты')
			}
			return
		}

		// e) Удалить вопрос
		if (e.target.matches('.del-question')) {
			const qid = e.target.dataset.id
			if (!confirm('Удалить вопрос?')) return
			try {
				const res = await fetch('/api/teacher/questions', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id: +qid }),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Вопрос удалён')
				loadQuestions(select.value)
			} catch (err) {
				console.error(err)
				alert('Не удалось удалить вопрос')
			}
			return
		}

		// f) Создать новый вариант ответа для закрытого вопроса
		if (e.target.matches('.save-new-option')) {
			const qid = e.target.dataset.id
			const row = e.target.closest('tr')
			const textEl = row.querySelector('.new-opt-text')
			const correctEl = row.querySelector('.new-opt-correct')
			const optionText = textEl.value.trim()
			const isCorrect = correctEl.checked
			if (!optionText) {
				alert('Введите текст варианта')
				return
			}
			try {
				const res = await fetch('/api/teacher/options', {
					method: 'POST',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						question_id: +qid,
						option_text: optionText,
						is_correct: isCorrect,
					}),
				})
				if (!res.ok) throw new Error(await res.text())
				textEl.value = ''
				correctEl.checked = false
				await loadOptions(qid)
			} catch (err) {
				console.error(err)
				alert('Не удалось добавить вариант')
			}
			return
		}

		// g) Сохранить существующий вариант ответа
		if (e.target.matches('.save-option')) {
			const oid = e.target.dataset.id
			const rowOpt = e.target.closest('tr')
			const optionText = rowOpt
				.querySelector(`.edit-opt-text[data-id="${oid}"]`)
				.value.trim()
			const isCorrect = rowOpt.querySelector(
				`.edit-opt-correct[data-id="${oid}"]`
			).checked
			const qid = rowOpt.closest('tbody').id.split('-')[1]
			try {
				const res = await fetch('/api/teacher/options', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						id: +oid,
						option_text: optionText,
						is_correct: isCorrect,
					}),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Вариант сохранён')
				await loadOptions(qid)
			} catch (err) {
				console.error(err)
				alert('Не удалось сохранить вариант')
			}
			return
		}

		// h) Удалить существующий вариант ответа
		if (e.target.matches('.del-option')) {
			const oid = e.target.dataset.id
			const rowOpt = e.target.closest('tr')
			const qid = rowOpt.closest('tbody').id.split('-')[1]
			if (!confirm('Удалить вариант?')) return
			try {
				const res = await fetch('/api/teacher/options', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id: +oid }),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Вариант удалён')
				await loadOptions(qid)
			} catch (err) {
				console.error(err)
				alert('Не удалось удалить вариант')
			}
			return
		}
	})
}

// -----------------------
// initCourses
// -----------------------
async function initCourses() {
	const tbody = document.getElementById('teacherCoursesBody')
	try {
		const response = await fetch('/api/teacher/courses', {
			credentials: 'include',
		})
		if (!response.ok) throw new Error(response.statusText)
		const courses = await response.json()

		courses.forEach(c => {
			const tr = document.createElement('tr')
			tr.innerHTML = `
		  <td><input class="edit-text" data-id="${c.id}" value="${c.title}"></td>
		  <td><input class="edit-text" data-id="${c.id}" value="${c.description}"></td>
		  <td>${new Date(c.created_at).toLocaleDateString()}</td>
		  <td class="action-cell">
			<button class="save-course" data-id="${
				c.id
			}"><i class="fas fa-save"></i> Сохранить</button>
			<button class="del-course" data-id="${
				c.id
			}"><i class="fas fa-trash"></i> Удалить</button>
		  </td>
		`
			tbody.appendChild(tr)
		})

		// Уведомляем о завершении загрузки курсов для поиска
		document.dispatchEvent(new CustomEvent('teacherCourses:loaded'))
	} catch (err) {
		console.error('Ошибка загрузки курсов:', err)
	}

	// Обработка кликов по кнопкам Сохранить/Удалить
	tbody.addEventListener('click', async e => {
		const btn = e.target.closest('button')
		if (!btn) return
		const id = +btn.dataset.id

		if (btn.classList.contains('save-course')) {
			const inputs = Array.from(
				document.querySelectorAll(`.edit-text[data-id="${id}"]`)
			)
			const title = inputs[0].value
			const desc = inputs[1].value
			try {
				const res = await fetch('/api/teacher/courses', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id, title, description: desc }),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Курс сохранён')
			} catch (err) {
				alert(err.message)
			}
		}

		if (btn.classList.contains('del-course')) {
			if (!confirm('Удалить курс?')) return
			try {
				const res = await fetch('/api/teacher/courses', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id }),
				})
				if (!res.ok) throw new Error(await res.text())
				btn.closest('tr').remove()
			} catch (err) {
				alert(err.message)
			}
		}
	})

	// Обработка добавления нового курса
	const form = document.getElementById('newTeacherCourseForm')
	form.addEventListener('submit', async e => {
		e.preventDefault()
		const fd = new FormData(form)
		try {
			const res = await fetch('/api/teacher/courses', {
				method: 'POST',
				credentials: 'include',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					title: fd.get('title'),
					description: fd.get('description'),
				}),
			})
			if (!res.ok) throw new Error(await res.text())
			// перезагрузка страницы после успешного добавления
			location.reload()
		} catch (err) {
			alert(err.message)
		}
	})
}

// -----------------------
// initTests
// -----------------------
async function initTests() {
	// Заполняем селект курсами
	const select = document.querySelector('#newTestForm select[name="course_id"]')
	try {
		const resCourses = await fetch('/api/teacher/courses', {
			credentials: 'include',
		})
		if (!resCourses.ok) throw new Error(resCourses.statusText)
		const cs = await resCourses.json()
		cs.forEach(c => {
			const o = document.createElement('option')
			o.value = c.id
			o.textContent = c.title
			select.appendChild(o)
		})
	} catch (err) {
		console.error('Ошибка загрузки курсов для тестов:', err)
	}

	// Загружаем тесты и рендерим строки
	const tbody = document.getElementById('testsBody')
	try {
		const resTests = await fetch('/api/teacher/tests', {
			credentials: 'include',
		})
		if (!resTests.ok) throw new Error(resTests.statusText)
		const ts = await resTests.json()
		ts.forEach(t => {
			const tr = document.createElement('tr')
			tr.innerHTML = `
		  <td><input class="edit-text" data-id="${t.id}" value="${t.title}"></td>
		  <td><input class="edit-text" data-id="${t.id}" value="${t.description}"></td>
		  <td>${t.course_id}</td>
		  <td>${new Date(t.created_at).toLocaleDateString()}</td>
		  <td class="action-cell">
			<button class="save-test" data-id="${
				t.id
			}"><i class="fas fa-save"></i> Сохранить</button>
			<button class="del-test" data-id="${
				t.id
			}"><i class="fas fa-trash"></i> Удалить</button>
		  </td>
		`
			tbody.appendChild(tr)
		})
		// Сигнализируем модулю поиска о готовности таблицы
		document.dispatchEvent(new CustomEvent('teacherTests:loaded'))
	} catch (err) {
		console.error('Ошибка загрузки тестов:', err)
	}

	// Обработка кликов Сохранить/Удалить
	tbody.addEventListener('click', async e => {
		const btn = e.target.closest('button')
		if (!btn) return
		const id = +btn.dataset.id

		if (btn.classList.contains('save-test')) {
			const inputs = Array.from(
				document.querySelectorAll(`.edit-text[data-id="${id}"]`)
			)
			const title = inputs[0].value
			const desc = inputs[1].value
			try {
				const res = await fetch('/api/teacher/tests', {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id, title, description: desc }),
				})
				if (!res.ok) throw new Error(await res.text())
				alert('Тест сохранён')
			} catch (err) {
				alert(err.message)
			}
		}

		if (btn.classList.contains('del-test')) {
			if (!confirm('Удалить тест?')) return
			try {
				const res = await fetch('/api/teacher/tests', {
					method: 'DELETE',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ id }),
				})
				if (!res.ok) throw new Error(await res.text())
				btn.closest('tr').remove()
			} catch (err) {
				alert(err.message)
			}
		}
	})

	// Обработка формы добавления теста
	const form = document.getElementById('newTestForm')
	form.addEventListener('submit', async e => {
		e.preventDefault()
		const fd = new FormData(form)
		try {
			const res = await fetch('/api/teacher/tests', {
				method: 'POST',
				credentials: 'include',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					title: fd.get('title'),
					description: fd.get('description'),
					course_id: +fd.get('course_id'),
				}),
			})
			if (!res.ok) throw new Error(await res.text())
			const data = await res.json()
			const newTestId = data.id ?? data.test_id
			if (!newTestId) throw new Error('Не удалось получить ID созданного теста')
			openQuestionModal(newTestId)
		} catch (err) {
			alert('Ошибка создания теста: ' + err.message)
		}
	})
}

// Страница Теория

// -----------------------
// Инициализация и CRUD для раздела «Теория»
// -----------------------

// Глобальные переменные
let _theoryList = []
let _theoryCourseId = null
let _theoryCourseTitle = ''

let quill,
	quillInitialized = false
let _isCreatingTheory = false

// -----------------------
// initTheory — заполняет селектор курсов и загружает темы
// -----------------------
async function initTheory() {
	// 1) Заполняем селект курсами
	const select = document.getElementById('theoryCourseSelect')
	if (!select) {
		console.error('Не найден селект #theoryCourseSelect')
		return
	}
	select.innerHTML = '<option value="" disabled selected>Выберите курс</option>'

	let courses
	try {
		const res = await fetch('/api/teacher/courses', { credentials: 'include' })
		if (!res.ok) throw new Error(`Status ${res.status}`)
		courses = await res.json()
	} catch (err) {
		console.error('Ошибка загрузки курсов:', err)
		return
	}
	if (!Array.isArray(courses) || !courses.length) {
		console.warn('Нет курсов')
		return
	}
	courses.forEach(c => {
		const o = document.createElement('option')
		o.value = c.id
		o.textContent = c.title
		select.appendChild(o)
	})

	// 2) Выбираем первый курс и загружаем темы
	select.selectedIndex = 1
	_theoryCourseId = +select.value
	_theoryCourseTitle = select.selectedOptions[0].textContent
	document.getElementById(
		'page-title'
	).textContent = `Теория — ${_theoryCourseTitle}`
	await reloadTheoryList(_theoryCourseId)
	// Сигнализируем модулю поиска, что темы отрисованы
	document.dispatchEvent(new CustomEvent('teacherTheory:loaded'))

	// 3) При смене селекта — перезагружаем темы
	select.addEventListener('change', async e => {
		_theoryCourseId = +e.target.value
		_theoryCourseTitle = e.target.selectedOptions[0].textContent
		document.getElementById(
			'page-title'
		).textContent = `Теория — ${_theoryCourseTitle}`
		await reloadTheoryList(_theoryCourseId)
		// Снова кидаем событие после перерисовки
		document.dispatchEvent(new CustomEvent('teacherTheory:loaded'))
	})

	// 4) Обработка формы создания новой темы — вешаем только один раз
	const newForm = document.getElementById('newTheoryForm')
	if (newForm && !newForm.dataset.bound) {
		newForm.dataset.bound = 'true'
		newForm.addEventListener('submit', async e => {
			e.preventDefault()
			if (_isCreatingTheory) return
			const title = e.target.title.value.trim()
			if (!title) return
			_isCreatingTheory = true
			try {
				const res = await fetch(
					`/api/teacher/courses/${_theoryCourseId}/theory`,
					{
						method: 'POST',
						credentials: 'include',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ title }),
					}
				)
				if (!res.ok) throw new Error(await res.text())
				e.target.reset()
				await reloadTheoryList(_theoryCourseId)
				showToast('Тема успешно создана!', 'success')
				// Сигнал для поиска: новые строки отрисованы
				document.dispatchEvent(new CustomEvent('teacherTheory:loaded'))
			} catch (err) {
				console.error('Ошибка создания темы:', err)
				showToast('Ошибка при создании темы: ' + err.message, 'error')
			} finally {
				_isCreatingTheory = false
			}
		})
	}

	// 5) Делегированное открытие модалки редактирования содержания
	document.body.addEventListener('click', e => {
		const btn = e.target.closest('[data-action="open-theory-modal"]')
		if (!btn) return
		openTheoryModal(btn.dataset.topicId)
	})
}

// -----------------------
// reloadTheoryList — загрузить список тем и отрисовать карточки
// -----------------------
async function reloadTheoryList(courseId) {
	const container = document.getElementById('theoryCards')
	container.innerHTML = ''

	// 1) Запрос списка тем
	let res
	try {
		res = await fetch(`/api/courses/${courseId}/theory`, {
			credentials: 'include',
		})
	} catch (err) {
		console.error('Сетевая ошибка при загрузке тем:', err)
		container.innerHTML =
			'<p class="error">Не удалось загрузить темы (сетевая ошибка).</p>'
		showToast('Не удалось загрузить темы (сетевая ошибка).', 'error')
		return
	}

	// 2) Обработка HTTP‑статуса
	if (!res.ok) {
		console.error(`Ошибка ${res.status} при загрузке тем: ${res.statusText}`)
		container.innerHTML = `<p class="error">Не удалось загрузить темы (код ${res.status}).</p>`
		showToast(`Не удалось загрузить темы (код ${res.status}).`, 'error')
		return
	}

	// 3) Парсинг JSON
	let list
	try {
		list = await res.json()
	} catch (err) {
		console.error('Ошибка разбора JSON от сервера:', err)
		container.innerHTML = '<p class="error">Некорректный ответ сервера.</p>'
		showToast('Некорректный ответ сервера.', 'error')
		return
	}

	// 4) Пустой список тем
	if (!Array.isArray(list) || list.length === 0) {
		container.innerHTML = '<p class="empty">Тем ещё нет. Создайте первую!</p>'
		return
	}

	// 5) Рендер каждой карточки темы
	list.forEach(item => {
		const card = document.createElement('div')
		card.classList.add('theory-card')
		card.dataset.id = item.id

		// --- Редактирование заголовка ---
		const titleInput = document.createElement('input')
		titleInput.type = 'text'
		titleInput.classList.add('title-input')
		titleInput.value = item.title
		card.appendChild(titleInput)

		// --- Кнопка редактирования содержания ---
		const editBtn = document.createElement('button')
		editBtn.classList.add('edit-content', 'btn')
		editBtn.textContent = 'Редактировать содержание'
		editBtn.setAttribute('data-action', 'open-theory-modal')
		editBtn.setAttribute('data-topic-id', item.id)
		card.appendChild(editBtn)

		container.appendChild(card)

		// кнопка сохранить
		const saveBtn = document.createElement('button')
		saveBtn.classList.add('save-theory')
		saveBtn.textContent = 'Сохранить'
		saveBtn.addEventListener('click', async () => {
			const newTitle = titleInput.value.trim()
			if (!newTitle) {
				alert('Заголовок не может быть пустым')
				titleInput.value = item.title
				return
			}
			if (newTitle === item.title) return
			try {
				const updRes = await fetch(`/api/teacher/theory/${item.id}`, {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ title: newTitle }),
				})
				if (!updRes.ok) throw new Error(`Код ${updRes.status}`)
				item.title = newTitle
				saveBtn.textContent = 'Сохранено'
				setTimeout(() => (saveBtn.textContent = 'Сохранить'), 1000)
			} catch (err) {
				console.error('Ошибка при сохранении темы:', err)
				alert('Не удалось сохранить: ' + err.message)
				titleInput.value = item.title
			}
		})
		card.appendChild(saveBtn)

		// --- Удаление темы ---
		const delBtn = document.createElement('button')
		delBtn.classList.add('btn', 'btn-danger')
		delBtn.textContent = 'Удалить'

		delBtn.addEventListener('click', async () => {
			if (!confirm('Удалить тему?')) return
			try {
				const delRes = await fetch(`/api/teacher/theory/${item.id}`, {
					method: 'DELETE',
					credentials: 'include',
				})
				if (!delRes.ok) throw new Error(`Код ${delRes.status}`)
				await reloadTheoryList(courseId)
			} catch (err) {
				console.error('Ошибка при удалении темы:', err)
				alert('Не удалось удалить тему: ' + err.message)
			}
		})
		card.appendChild(delBtn)
	})
}

let currentTheoryId = null

async function openTheoryModal(topicId) {
	currentTheoryId = topicId
	const modal = document.getElementById('theoryModal')
	modal.classList.remove('hidden')

	// Инициализируем Quill единожды
	if (!quillInitialized) {
		quill = new Quill('#editorCanvas', {
			modules: { toolbar: '#editorToolbar' },
			theme: 'snow',
		})
		quillInitialized = true

		// Регистрируем PDF‑blot
		const BlockEmbed = Quill.import('blots/block/embed')
		class PdfBlot extends BlockEmbed {
			static create(val) {
				const node = super.create()
				node.setAttribute('href', val.url)
				node.setAttribute('target', '_blank')
				node.innerHTML = `<i class="pdf-icon"></i>${val.name}`
				return node
			}
			static value(node) {
				return { url: node.getAttribute('href'), name: node.textContent }
			}
		}
		PdfBlot.blotName = 'pdf'
		PdfBlot.tagName = 'a'
		Quill.register(PdfBlot)

		// Обработчик вставки PDF
		document.getElementById('ql-insert-pdf').addEventListener('click', () => {
			const input = document.createElement('input')
			input.type = 'file'
			input.accept = 'application/pdf'
			input.click()
			input.onchange = async () => {
				const file = input.files[0]
				if (!file) return
				const fd = new FormData()
				fd.append('file', file)
				// showLoader()
				try {
					const res = await fetch(`/api/teacher/upload-theory-asset`, {
						method: 'POST',
						credentials: 'include',
						body: fd,
					})
					if (!res.ok) throw new Error(res.status)
					const { url } = await res.json()
					const range = quill.getSelection(true)
					quill.insertEmbed(range.index, 'pdf', { url, name: file.name })
					quill.setSelection(range.index + 1)
					showToast('PDF вставлен', 'success')
				} catch (err) {
					console.error(err)
					showToast('Ошибка загрузки PDF: ' + err.message, 'error')
				} finally {
					hideLoader()
				}
			}
		})
	}

	// Активируем редактор и загружаем контент
	quill.enable(true)
	quill.focus()
	try {
		const data = await fetch(`/api/teacher/theory/${currentTheoryId}`, {
			credentials: 'include',
		}).then(r => {
			if (!r.ok) throw r
			return r.json()
		})
		quill.root.innerHTML = data.content || ''
	} catch (err) {
		console.error(err)
		showToast('Не удалось загрузить содержание', 'error')
	}

	// Закрытие по оверлею и Esc
	modal.querySelector('.modal-overlay').onclick = () =>
		modal.classList.add('hidden')
	document.addEventListener('keydown', function esc(e) {
		if (e.key === 'Escape') {
			modal.classList.add('hidden')
			document.removeEventListener('keydown', esc)
		}
	})
}

function insertHtmlAtCursor(html) {
	const sel = window.getSelection()
	if (!sel.rangeCount) return
	const range = sel.getRangeAt(0)
	range.deleteContents()
	const el = document.createElement('div')
	el.innerHTML = html
	const frag = document.createDocumentFragment()
	let node, lastNode
	while ((node = el.firstChild)) {
		lastNode = frag.appendChild(node)
	}
	range.insertNode(frag)
	// Сдвинуть курсор после вставленного фрагмента
	if (lastNode) {
		range.setStartAfter(lastNode)
		sel.removeAllRanges()
		sel.addRange(range)
	}
}

async function handleFileUpload(inputEl, field) {
	if (!inputEl.files || inputEl.files.length === 0) return

	const file = inputEl.files[0]
	const allowedTypes = {
		image: ['image/jpeg', 'image/png', 'image/gif'],
		pdf: ['application/pdf'],
	}

	// Валидация файла
	if (!allowedTypes[field].includes(file.type)) {
		showToast('Недопустимый тип файла', 'error')
		return
	}

	if (file.size > 5 * 1024 * 1024) {
		// 5MB лимит
		showToast('Файл слишком большой (макс. 5MB)', 'error')
		return
	}

	const fd = new FormData()
	fd.append('file', file)
	fd.append('type', field)

	try {
		showToast('Загрузка файла...', 'info')
		const response = await fetch('/api/teacher/upload-theory-asset', {
			method: 'POST',
			credentials: 'include',
			body: fd,
		})

		if (!response.ok) throw new Error(await response.text())

		const data = await response.json()
		const safeUrl = DOMPurify.sanitize(data.url)
		const safeName = this.escapeHtml(file.name)

		switch (field) {
			case 'image':
				quill.insertEmbed(quill.getSelection().index, 'image', safeUrl)
				break

			case 'pdf':
				quill.insertEmbed(quill.getSelection().index, 'pdf', {
					url: safeUrl,
					name: safeName,
				})
				break
		}

		showToast('Файл успешно загружен', 'success')
	} catch (error) {
		console.error('Ошибка загрузки:', error)
		showToast(`Ошибка: ${error.message}`, 'error')
	} finally {
		inputEl.value = '' // Сброс инпута
	}
}

function createToastContainer() {
	const container = document.createElement('div')
	container.id = 'toast-container'
	document.body.appendChild(container)
	return container
}

// Универсальная функция тостов
function showToast(message, type = 'success', timeout = 3000) {
	const container = document.getElementById('toast-container')
	const toast = document.createElement('div')
	toast.className = `toast ${type}`
	toast.textContent = message
	container.appendChild(toast)
	setTimeout(() => {
		toast.style.opacity = '0'
		setTimeout(() => container.removeChild(toast), 300)
	}, timeout)
}

// -----------------------
// Стартуем всё при загрузке страницы
// -----------------------
document.addEventListener('DOMContentLoaded', () => {
	loadUserIcon()
	updateToggleIcon(document.documentElement.getAttribute('data-theme'))

	// Инициализация страниц
	if (document.getElementById('teacherCoursesBody')) initCourses()
	if (document.getElementById('testsBody')) initTests()
	if (document.getElementById('questionsBody')) initQuestions()
	if (document.querySelector('#newTheoryForm')) initTheory()

	// Открытие модалки
	document.body.addEventListener('click', e => {
		const btn = e.target.closest('[data-action="open-quick-modal"]')
		if (!btn) return
		openQuestionModal(btn.dataset.testId)
	})

	// Закрытие модалки
	document
		.getElementById('closeQuestionModal')
		?.addEventListener('click', tryCloseModal)
	document
		.getElementById('forceClose')
		?.addEventListener('click', forceCloseModal)
	document.getElementById('cancelClose')?.addEventListener('click', cancelClose)

	// Форма выбора типа вопроса
	const quickType = document.getElementById('question_type')
	const quickCorrect = document.getElementById('quick_correct_answer')
	const multiEl = document.getElementById('multiple_choice')
	const multiLabel = document.getElementById('multiLabel')
	quickType?.addEventListener('change', () => {
		const isOpen = quickType.value === 'open'
		quickCorrect.style.display = isOpen ? 'inline-block' : 'none'
		if (!isOpen) quickCorrect.value = ''
		multiLabel.style.display = isOpen ? 'none' : 'inline-flex'
		if (isOpen) multiEl.checked = false
	})

	// Добавление нового вопроса
	document
		.getElementById('quickQuestionForm')
		?.addEventListener('submit', e => {
			e.preventDefault()
			const text = document.getElementById('question_text').value.trim()
			const type = quickType.value
			const multi = multiEl.checked
			const correctOpen = quickCorrect.value.trim()
			if (!text) return alert('Введите текст вопроса')

			const li = document.createElement('li')
			li.className = 'question-item'
			li.dataset.type = type
			li.dataset.multi = multi
			if (type === 'open') li.dataset.correct = correctOpen

			if (type === 'closed') {
				li.innerHTML = `
		  <div class="question-header">
			<span class="question-number"></span>
			<span class="question-text">${text}</span>
			<div class="question-controls">
			  <button class="toggle-options" title="Варианты"><i class="fas fa-caret-down"></i></button>
			  <button class="remove-quick-question" title="Удалить">×</button>
			</div>
		  </div>
		  <div class="options-builder" style="display:none;">
			<ul class="option-list" style="list-style:none; padding:0;"></ul>
			<div class="add-option-form" style="display:flex; gap:0.5rem; margin-top:0.5rem;">
			  <input type="text" class="new-opt-text" placeholder="Новый вариант" style="flex:1;" />
			  <label><input type="checkbox" class="new-opt-correct" /> Правильный</label>
			  <button type="button" class="add-option-btn btn">Добавить</button>
			</div>
		  </div>
		`
			} else {
				li.innerHTML = `
		  <div class="question-header">
			<span class="question-number"></span>
			<span class="question-text">${text}</span>
			<div class="question-controls">
			  <button class="remove-quick-question" title="Удалить">×</button>
			</div>
		  </div>
		  <div class="options-builder" style="padding:0.5rem 0;">
			<label>Правильный ответ:</label>
			<input type="text" class="open-answer-builder" value="${correctOpen}" style="width:100%;" />
		  </div>
		`
			}

			document.getElementById('quickQuestionsList').appendChild(li)
			renumberQuestions()
			// clearQuickModal()
			quickIsDirty = true
			document.getElementById('saveQuickQuestions').disabled = false
		})

	// Делегированное управление вариантами и вопросами
	document
		.getElementById('quickQuestionsList')
		?.addEventListener('click', e => {
			const li = e.target.closest('li.question-item')
			if (!li) return

			// Переключаем блок вариантов
			if (e.target.closest('.toggle-options')) {
				const builder = li.querySelector('.options-builder')
				const icon = li.querySelector('.toggle-options i')
				const open = builder.style.display === 'block'
				builder.style.display = open ? 'none' : 'block'
				icon.className = open ? 'fas fa-caret-down' : 'fas fa-caret-up'
				return
			}
			// Добавляем вариант
			if (e.target.closest('.add-option-btn')) {
				const form = li.querySelector('.add-option-form')
				const txt = form.querySelector('.new-opt-text').value.trim()
				const corr = form.querySelector('.new-opt-correct').checked
				if (!txt) return alert('Введите текст варианта')

				const item = document.createElement('li')
				item.className = 'option-item'
				item.dataset.correct = corr ? 'true' : 'false'
				const span = document.createElement('span')
				span.className = 'option-text'
				span.textContent = txt
				item.appendChild(span)
				if (corr) {
					const badge = document.createElement('span')
					badge.className = 'correct-badge'
					badge.textContent = '✔'
					item.appendChild(badge)
				}
				const delBtn = document.createElement('button')
				delBtn.className = 'remove-option btn'
				delBtn.title = 'Удалить'
				delBtn.textContent = '×'
				item.appendChild(delBtn)

				li.querySelector('.option-list').appendChild(item)

				form.querySelector('.new-opt-text').value = ''
				form.querySelector('.new-opt-correct').checked = false
				quickIsDirty = true
				document.getElementById('saveQuickQuestions').disabled = false
			}

			// Удаляем вариант
			if (e.target.closest('.remove-option')) {
				e.target.closest('li.option-item').remove()
				quickIsDirty = true
				document.getElementById('saveQuickQuestions').disabled = false
				return
			}
			// Удаляем вопрос
			if (e.target.closest('.remove-quick-question')) {
				li.remove()
				renumberQuestions()
				quickIsDirty = true
				document.getElementById('saveQuickQuestions').disabled = false
				return
			}
		})

	// Обработка open-ответа
	document
		.getElementById('quickQuestionsList')
		?.addEventListener('input', e => {
			if (e.target.matches('.open-answer-builder')) {
				const li = e.target.closest('li.question-item')
				li.dataset.correct = e.target.value.trim()
				quickIsDirty = true
				document.getElementById('saveQuickQuestions').disabled = false
			}
		})

	// Сохранение всех
	document
		.getElementById('saveQuickQuestions')
		?.addEventListener('click', saveQuickQuestions)

	// Обработчик кнопки «PDF»
	document.getElementById('ql-insert-pdf').addEventListener('click', () => {
		const input = document.createElement('input')
		input.setAttribute('type', 'file')
		input.setAttribute('accept', 'application/pdf')
		input.click()
		input.onchange = async () => {
			const file = input.files[0]
			if (!file) return
			const fd = new FormData()
			fd.append('file', file)
			// showLoader()
			try {
				const res = await fetch('/api/teacher/upload-theory-asset', {
					method: 'POST',
					credentials: 'include',
					body: fd,
				})
				if (!res.ok) throw new Error(`Ошибка ${res.status}`)
				const { url } = await res.json()
				// Вставляем ссылку‑иконку PDF
				const range = quill.getSelection(true)
				quill.insertEmbed(range.index, 'pdf', { url, name: file.name })
				quill.setSelection(range.index + 1)
				showToast('PDF вставлен', 'success')
			} catch (err) {
				console.error(err)
				showToast('Ошибка загрузки PDF: ' + err.message, 'error')
			} finally {
				// hideLoader()
			}
		}
	})

	// Регистрируем кастомный blot для PDF
	const BlockEmbed = Quill.import('blots/block/embed')
	class PdfBlot extends BlockEmbed {
		static create(value) {
			const node = super.create()
			node.setAttribute('href', value.url)
			node.setAttribute('target', '_blank')
			node.innerHTML = `<i class="pdf-icon"></i>${value.name}`
			return node
		}
		static value(node) {
			return {
				url: node.getAttribute('href'),
				name: node.textContent,
			}
		}
	}
	PdfBlot.blotName = 'pdf'
	PdfBlot.tagName = 'a'
	Quill.register(PdfBlot)

	const saveBtn = document.getElementById('saveTheoryContent')
	if (saveBtn) {
		saveBtn.addEventListener('click', async () => {
			const content = quill.root.innerHTML
			try {
				const res = await fetch(`/api/teacher/theory/${currentTheoryId}`, {
					method: 'PUT',
					credentials: 'include',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ content }),
				})
				if (!res.ok) throw new Error(`Ошибка ${res.status}`)
				showToast('Содержание сохранено', 'success')
				document.getElementById('theoryModal').classList.add('hidden')
			} catch (err) {
				console.error(err)
				showToast(err.message, 'error')
			}
		})
	}

	// Закрытие модалки по кнопке Отмена
	const closeBtn = document.getElementById('closeTheoryModal')
	if (closeBtn) {
		closeBtn.addEventListener('click', () => {
			document.getElementById('theoryModal').classList.add('hidden')
		})
	}

	document
		.getElementById('questionsBody')
		.addEventListener('change', async e => {
			if (!e.target.classList.contains('edit-difficulty')) return

			const select = e.target
			const id = select.dataset.id
			const newDiff = select.value

			// Найти остальные поля из строки
			const row = select.closest('tr')
			const text = row.querySelector('.edit-text').value
			const type = row.querySelector('.edit-type').value
			const multi = row.querySelector('.edit-multi').checked
			// Правильный ответ для открытых:
			const correct =
				row.nextElementSibling.querySelector('.open-answer-input')?.value || ''

			const payload = {
				id: Number(id),
				test_id: testId, // передайте текущий testId
				question_text: text,
				question_type: type,
				multiple_choice: multi,
				correct_answer_text: correct,
				difficulty: newDiff,
			}

			const res = await fetch('/api/teacher/questions', {
				method: 'PUT',
				headers: { 'Content-Type': 'application/json' },
				credentials: 'include',
				body: JSON.stringify(payload),
			})

			if (!res.ok) {
				alert('Не удалось сохранить сложность')
				// можно откатить select к предыдущему значению при желании
			}
		})
})

Файл: C:\dev\projects\html\Курсовая работа\static\teacherPanel\style.css
/* SELECT & CHECKBOX */
select.edit-type {
	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
	color: var(--text);
	padding: var(--sp-xs) var(--sp-sm);
	background: var(--card-bg)
		url("data:image/svg+xml;charset=UTF-8,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none'%3E%3Cpath d='M0 0l5 6l5-6' stroke='%23999' stroke-width='1.2'/%3E%3C/svg%3E")
		no-repeat right var(--sp-sm) center / 0.6em;
	border: 1px solid var(--border);
	border-radius: var(--radius);
	cursor: pointer;
	transition: border-color var(--trans), box-shadow var(--trans);
}
select.edit-type:focus {
	outline: none;
	border-color: var(--primary);
	box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
}
input.edit-multi[type='checkbox'] {
	transform: scale(1.2);
	cursor: pointer;
}

/* OPTIONS WRAPPER */
.options-wrapper {
	position: relative;
	z-index: 1; /* создаём контекст наложения */
}

.options-row .options-wrapper {
	/* display: none; */
	padding: var(--sp-sm);
	margin-top: var(--sp-md);
	background: var(--bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	overflow-x: auto;
}
.options-table {
	width: 100%;
	border-collapse: collapse;
	margin-bottom: var(--sp-sm);
}
.options-table th {
	background-color: var(--primary);
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	text-align: left;
	white-space: nowrap;
}

.options-table td {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	text-align: left;
	white-space: nowrap;
}
.options-table thead {
	background: var(--primary);
	position: sticky;
	top: 0;
	z-index: 2;
}
.options-table thead th {
	color: var(--bg);
	font-weight: 600;
	padding: var(--sp-sm) var(--sp-md);
}

/* === Вложенная таблица вариантов: теперь полностью как основная === */
.options-wrapper table.options-table {
	/* ширина и раскладка */
	width: 100%;
	min-width: auto;
	border-collapse: collapse;
	table-layout: auto;

	/* визуальные рамки и фон */
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);

	margin-bottom: var(--sp-sm);
}

/* ячейки */
.options-wrapper table.options-table th,
.options-wrapper table.options-table td {
	padding: var(--sp-sm) var(--sp-md);
	text-align: left;
	white-space: nowrap;
	border: 1px solid var(--border);
}

/* шапка */
.options-wrapper table.options-table thead {
	opacity: 1 !important;
	visibility: visible !important;
	display: table-header-group !important;
	background: rgba(255, 255, 255, 0.95); /* полупрозрачный фон */
	border: 1px solid red;
	position: sticky;
	top: 0;
	z-index: 10; /* выше других ячеек */
}
.options-wrapper table.options-table thead th {
	color: var(--bg);
	font-weight: 600;
}
/* скругляем уголки шапки */
.options-wrapper table.options-table thead th:first-child {
	border-top-left-radius: var(--radius);
}
.options-wrapper table.options-table thead th:last-child {
	border-top-right-radius: var(--radius);
}

/* зебра-через-одну строк */
.options-wrapper table.options-table tbody tr:nth-child(odd) {
	background: var(--bg);
}
.options-wrapper table.options-table tbody tr:nth-child(even) {
	background: var(--border);
}

/* скругляем уголки последней строки */
.options-wrapper table.options-table tbody tr:last-child td:first-child {
	border-bottom-left-radius: var(--radius);
}
.options-wrapper table.options-table tbody tr:last-child td:last-child {
	border-bottom-right-radius: var(--radius);
}

/* Шапка таблицы — стиль как у основной */
.options-wrapper table.options-table thead {
	background-color: var(--primary);
}

.options-wrapper table.options-table thead th {
	color: var(--bg); /* светлый текст */
	font-weight: 600;
	padding: var(--sp-sm) var(--sp-md);
	text-align: left;
	white-space: nowrap;
	border: 1px solid var(--border);
}

/* Скругление углов */
.options-wrapper table.options-table thead th:first-child {
	border-top-left-radius: var(--radius);
}
.options-wrapper table.options-table thead th:last-child {
	border-top-right-radius: var(--radius);
}

/* NEW OPTION FORM */
.option-form {
	display: grid;
	grid-template-columns: 1fr auto auto;
	gap: var(--sp-sm);
	align-items: center;
	margin-top: var(--sp-sm);
}
.option-form input[type='text'] {
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	width: 100%;
}
.option-form input[type='checkbox'] {
	transform: scale(1.2);
	margin-left: var(--sp-xs);
	cursor: pointer;
}
.option-form button {
	padding: var(--sp-xs) var(--sp-sm);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}
.option-form button:hover {
	opacity: 0.8;
}

/* ======== МОДАЛЬНОЕ ОКНО ======== */
.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 2000;
}

.modal {
	background: var(--card-bg);
	color: var(--text);
	width: 90%;
	max-width: 600px;
	border-radius: var(--radius);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
	overflow: hidden;
	display: flex;
	flex-direction: column;
}

.modal-header,
.modal-footer {
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: var(--bg);
	display: flex;
	align-items: center;
	justify-content: space-between;
}

.modal-header h3 {
	margin: 0;
	font-size: 1.25rem;
}

.modal-close {
	background: none;
	border: none;
	font-size: 1.5rem;
	color: var(--bg);
	cursor: pointer;
	line-height: 1;
}

.modal-body {
	padding: var(--sp-md);
	max-height: 60vh;
	overflow-y: auto;
}

/* Форма быстрого добавления */
.quick-form .form-group {
	margin-bottom: var(--sp-md);
}
.quick-form .form-group.inline {
	display: flex;
	align-items: center;
	gap: var(--sp-md);
}
.quick-form label {
	font-weight: 500;
}
.quick-form textarea,
.quick-form select,
.quick-form input[type='text'] {
	width: 100%;
	padding: var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--card-bg);
	color: var(--text);
	transition: border-color var(--trans);
}
.quick-form textarea:focus,
.quick-form select:focus {
	outline: none;
	border-color: var(--bg);
}
.btn {
	display: inline-flex;
	align-items: center;
	gap: var(--sp-xs);
	padding: var(--sp-xs) var(--sp-sm);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: opacity var(--trans);
}
.btn:hover {
	opacity: 0.8;
}

/* Список вопросов внутри модалки */
.quick-questions-list {
	list-style: none;
	max-height: 200px;
	overflow-y: auto;
	border-top: 1px solid var(--border);
}

.quick-questions-list .question-item {
	padding: var(--sp-sm);
	margin: 0;
	border-bottom: 1px solid var(--border);
	display: flex;
	align-items: center;
	justify-content: space-between;
	position: relative;
}
.question-item .question-text {
	flex: 1;
	margin-right: var(--sp-md);
}
.question-item .expand-options {
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: 50%;
	width: 1.5rem;
	height: 1.5rem;
	font-size: 1rem;
	line-height: 1;
	cursor: pointer;
}

/* — Основной контейнер вопроса — */
.question-item {
	display: flex;
	flex-direction: column;
}

/* 2) шапка с текстом + кнопкой */
.question-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	width: 100%;
}

/* — Верхняя строка: вопрос + плюсик — */
.question-item .question-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
}

/* текст вопроса — не блочный, чтобы не «ломал» flex */
.question-header .question-text {
	display: inline-block; /* или просто оставить span по умолчанию */
	margin: 0; /* сбросьте любые внешние отступы */
	flex: 1; /* чтобы вопрос занимал всё свободное место */
}

.question-header .expand-options {
	flex: 0 0 auto;
	margin-left: var(--sp-sm);
}

/* конструктор вариантов — скрыт по умолчанию и всегда снизу */
.options-builder {
	display: none;
	margin-top: var(--sp-sm);
	clear: both; /* на всякий случай */
	width: 100%;
	/* ваши существующие стили… */
	padding: var(--sp-sm);
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
}

.question-item.expanded > .options-builder {
	display: block;
}

/* — При открытии (когда .question-item получает .expanded) — */
.question-item.expanded > .options-builder {
	display: block;
}

.options-list {
	list-style: none;
	margin: 0 0 var(--sp-sm) 0;
	padding: 0;
}
.options-list .option-item {
	display: flex;
	align-items: center;
	gap: var(--sp-md);
	margin-bottom: var(--sp-xs);
}
.options-list .option-text {
	flex: 1;
}
.new-option-form {
	display: flex;
	align-items: center;
	gap: var(--sp-sm);
}
.new-option-form input[type='text'] {
	flex: 1;
	padding: var(--sp-xs);
	border: 1px solid var(--border);
	border-radius: var(--radius);
}
.new-option-form label {
	display: flex;
	align-items: center;
	gap: var(--sp-xs);
}
.new-option-form button {
	background: var(--primary);
	color: var(--bg);
	border: none;
	padding: var(--sp-xs) var(--sp-sm);
	border-radius: var(--radius);
}

/* Кнопка "Сохранить все вопросы" */
.save-questions {
	margin: var(--sp-sm) var(--sp-md);
}
.save-questions[disabled] {
	opacity: 0.4;
	cursor: not-allowed;
}

/* Подтверждение закрытия без сохранения */
.unsaved-confirm {
	position: absolute;
	top: var(--sp-sm);
	right: var(--sp-sm);
	background: var(--card-bg);
	color: var(--text);
	border: 1px solid var(--primary);
	border-radius: var(--radius);
	padding: var(--sp-sm);
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
	animation: fadeIn 0.3s ease;
}
.unsaved-confirm p {
	margin-bottom: var(--sp-sm);
}
.unsaved-confirm button {
	margin-right: var(--sp-sm);
	padding: var(--sp-xs) var(--sp-sm);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
}
@keyframes fadeIn {
	from {
		opacity: 0;
		transform: translateY(-10px);
	}
	to {
		opacity: 1;
		transform: translateY(0);
	}
}

.popover {
	z-index: -1 !important;
	position: absolute !important;
	pointer-events: none !important;
	background: transparent !important;
}

table.variant-table thead {
	opacity: 1 !important;
	visibility: visible !important;
	display: table-header-group !important;
}

/* Обёртка, чтобы кнопки и поле располагались аккуратно */
.open-answer-wrapper {
	display: flex;
	flex-wrap: wrap; /* Перенос строк, если места мало */
	gap: var(--sp-sm); /* Расстояние между элементами */
	align-items: center; /* Выравнивание по центру по вертикали */
}

/* Сама текстовая область */
.open-answer-input {
	flex: 1; /* Занимает всё доступное место */
	min-width: 200px; /* Минимальная ширина для удобства */
	max-width: 400px; /* Максимальная ширина */
	width: 100%; /* Чтобы flex:1 работал корректно */
	box-sizing: border-box; /* Включаем padding и border в ширину */
	padding: var(--sp-xs) var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--bg);
	color: var(--text);
	transition: border-color var(--trans), background var(--trans),
		color var(--trans);
}

.checkbox-disabled {
	opacity: 0.6;
	pointer-events: none;
}

.multi-answer-label.checkbox-disabled {
	opacity: 0.4;
	pointer-events: none;
}

/* ======= END MODAL STYLES ======= */

/* MOBILE */
@media (max-width: 600px) {
	.course-form {
		grid-template-columns: 1fr;
	}
	.table-wrapper {
		overflow-x: auto;
	}
	.nav-links {
		flex-direction: column;
		gap: var(--sp-xs);
	}
}

/* Быстрая форма создания */
#new-theory-form {
	display: grid;
	grid-template-columns: 2fr 2fr 4fr auto;
	gap: 0.5rem;
	margin-bottom: 1.5rem;
}
#new-theory-content[contenteditable]:empty:before {
	content: attr(placeholder);
	color: #888;
}

/* Таблица */
#theory-table th,
#theory-table td {
	padding: 0.5rem;
	border: 1px solid var(--border);
}
#theory-table tbody tr:nth-child(odd) {
	background: var(--row-bg);
}

/* === Улучшенный дизайн модалки === */
.modal-overlay {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0, 0, 0, 0.6);
	align-items: center;
	justify-content: center;
	z-index: 2000;
}

.modal-overlay.open {
	display: flex;
}

.modal-content {
	background: var(--card-bg);
	color: var(--text);
	width: 100%;
	max-width: 600px;
	border-radius: var(--radius);
	box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
	overflow: hidden;
	display: flex;
	flex-direction: column;
}

/* Заголовок */
.modal-header {
	padding: var(--sp-md) var(--sp-lg);
	background: var(--primary);
	color: var(--bg);
	display: flex;
	align-items: center;
	justify-content: space-between;
}
.modal-header h3 {
	font-size: 1.5rem;
	margin: 0;
}
.modal-close {
	background: none;
	border: none;
	font-size: 1.5rem;
	color: var(--bg);
	cursor: pointer;
	padding: var(--sp-xs);
	transition: opacity var(--trans);
}
.modal-close:hover {
	opacity: 0.8;
}

/* Тело модалки */
.modal-body {
	padding: var(--sp-lg);
	background: var(--card-bg);
	color: var(--text);
	display: grid;
	grid-template-rows: auto auto 1fr;
	row-gap: var(--sp-lg);
	max-height: 80vh; /* увеличено с 60vh до 80vh */
	overflow-y: auto;
}

/* Метки и поля */
.modal-body label {
	display: block;
	margin-bottom: var(--sp-xs);
	font-weight: 500;
}
.modal-body textarea,
.modal-body select,
.modal-body input[type='text'] {
	width: 100%;
	padding: var(--sp-sm);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	background: var(--bg);
	color: var(--text);
	transition: border-color var(--trans), box-shadow var(--trans);
}
.modal-body textarea:focus,
.modal-body select:focus,
.modal-body input[type='text']:focus {
	outline: none;
	border-color: var(--primary);
	box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
}

/* Кнопка добавления */
.btn.add-question {
	justify-self: start;
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	font-weight: 500;
	display: inline-flex;
	align-items: center;
	gap: var(--sp-xs);
	transition: background var(--trans), opacity var(--trans);
}
.btn.add-question:hover {
	background: #3c3bd1;
	opacity: 0.9;
}

/* Список быстрых вопросов */
.quick-questions-list {
	list-style: none;
	max-height: 100%;
	overflow-y: auto;
	border-top: 1px solid var(--border);
}
.quick-questions-list .question-item {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: var(--sp-sm) var(--sp-md);
	border-bottom: 1px solid var(--border);
	background: var(--bg);
	transition: background var(--trans);
}
.quick-questions-list .question-item:nth-child(even) {
	background: var(--card-bg);
}
.quick-questions-list .question-item:hover {
	background: rgba(79, 70, 229, 0.05);
}
.quick-questions-list .question-text {
	flex: 1;
	margin-right: var(--sp-md);
	word-break: break-word;
}
.quick-questions-list .remove-quick-question {
	background: transparent;
	border: none;
	color: var(--text-muted);
	font-size: 1.2rem;
	cursor: pointer;
	transition: color var(--trans);
}
.quick-questions-list .remove-quick-question:hover {
	color: var(--primary);
}

/* Футер модалки */
.modal-footer {
	padding: var(--sp-md) var(--sp-lg);
	background: var(--card-bg);
	display: flex;
	justify-content: flex-end;
	gap: var(--sp-md);
	border-top: 1px solid var(--border);
}
.modal-footer .btn.save-questions {
	padding: var(--sp-sm) var(--sp-lg);
	background: var(--primary);
	color: var(--bg);
	font-weight: 600;
	border: none;
	border-radius: var(--radius);
	display: inline-flex;
	align-items: center;
	gap: var(--sp-xs);
	transition: background var(--trans), opacity var(--trans);
}
.modal-footer .btn.save-questions:hover {
	background: #3c3bd1;
	opacity: 0.9;
}
.modal-footer .btn.save-questions:disabled {
	background: var(--border);
	cursor: not-allowed;
	opacity: 0.6;
}

/* Подтверждение несохранённых изменений */
.unsaved-confirm {
	position: absolute;
	top: var(--sp-md);
	right: var(--sp-lg);
	background: var(--card-bg);
	border: 1px solid var(--primary);
	border-radius: var(--radius);
	padding: var(--sp-sm);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
	z-index: 2100;
}
.unsaved-confirm p {
	margin-bottom: var(--sp-sm);
	color: var(--text);
}
.unsaved-confirm .btn {
	padding: var(--sp-xs) var(--sp-sm);
	font-size: 0.9rem;
}

.quick-questions-list .question-item {
	padding: 0.75rem 1rem;
	border-bottom: 1px solid var(--border);
	background: var(--bg);
}
.question-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
}
.question-text {
	flex: 1;
	word-break: break-word;
}
.question-controls button {
	background: none;
	border: none;
	color: var(--text-muted);
	font-size: 1.2rem;
	cursor: pointer;
	padding: 0.25rem;
	transition: color var(--trans);
}
.question-controls button:hover {
	color: var(--primary);
}
.options-builder {
	display: none;
	margin-top: 0.5rem;
	padding: 0.5rem;
	background: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
}
.question-item.expanded .options-builder {
	display: block;
}
.add-option-form {
	display: flex;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
}
.add-option-form input {
	flex: 1;
	padding: 0.5rem;
	border: 1px solid var(--border);
	border-radius: var(--radius);
}
.add-option-form button {
	padding: 0.5rem 1rem;
	background: var(--primary);
	color: var(--bg);
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
}
.option-list {
	list-style: none;
	max-height: 120px;
	overflow-y: auto;
}
.option-list li {
	display: flex;
	justify-content: space-between;
	padding: 0.25rem 0;
}

/* Keyframes для плавного появления */
@keyframes fadeIn {
	from {
		opacity: 0;
		transform: translateY(-10px);
	}
	to {
		opacity: 1;
		transform: translateY(0);
	}
}

/* для того, чтобы кнопки сохранить и удалить были в одной строке колонкой */
.action-cell {
	display: flex;
	flex-direction: column; /* укладываем элементы сверху вниз */
	align-items: stretch; /* растягиваем кнопки по ширине ячейки */
	gap: 4px; /* небольшое расстояние между кнопками */
}

/* Опционально: чтобы кнопки выглядели чуть крупнее */
.action-cell .btn {
	padding: 6px 12px;
	font-size: 14px;
}

Файл: C:\dev\projects\html\Курсовая работа\static\theory\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Теория — Set Learn</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<!-- 2. Стили -->
		<link rel="stylesheet" href="style.css" />
		<!-- 3. Логика страницы -->
		<script src="script.js" defer></script>
	</head>
	<body>
		<header class="navbar">
			<div class="logo" onclick="navigate('/static/mainPage/')">Set Learn</div>
			<nav class="nav-links">
				<a href="/static/mainPage/">Главная</a>
				<a href="/static/courses/">Курсы</a>
				<a
					href="/static/adminPanel/index.html"
					id="nav-admin"
					style="display: none"
					>Панель админа</a
				>
				<a
					href="/static/teacherPanel/html/"
					id="nav-teacher"
					style="display: none"
					>Панель учителя</a
				>
				<a href="#" class="active">Теория</a>
			</nav>
			<div class="actions">
				<button id="theme-toggle" aria-label="Переключить тему"></button>
				<div class="user-icon" onclick="navigate('/profile')">
					<img src="/static/img/userDefault.png" alt="avatar" />
				</div>
			</div>
		</header>

		<main class="page-content">
			<h1 id="title">Загрузка...</h1>
			<article id="content">
				<!-- сюда подгрузится текст из БД -->
			</article>
		</main>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\theory\script.js
// Сенарий: подгрузка одного раздела теории
// Навигация и тема берём из глобальных утилит
function navigate(url) {
	window.location.href = url
}

async function loadUserIcon() {
	try {
		const res = await fetch('/api/profile', { credentials: 'same-origin' })
		if (!res.ok) return
		const user = await res.json()
		if (user.avatar_path) {
			document.querySelector('.user-icon img').src = user.avatar_path
		}
		if (user.role === 'admin')
			document.getElementById('nav-admin').style.display = 'flex'
		if (user.role === 'teacher')
			document.getElementById('nav-teacher').style.display = 'inline-block'
	} catch {}
}

function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	if (!btn) return
	btn.innerHTML = `<img src="/static/img/${
		theme === 'dark' ? 'light' : 'dark'
	}-theme.png" alt="toggle"/>`
}
function initTheme() {
	const stored = localStorage.getItem('theme')
	const prefers = window.matchMedia('(prefers-color-scheme: dark)').matches
		? 'dark'
		: 'light'
	const theme = stored || prefers
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)
	document.getElementById('theme-toggle').addEventListener('click', () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	})
}

document.addEventListener('DOMContentLoaded', async () => {
	initTheme()
	await loadUserIcon()

	// Параметр ?topic=ID
	const params = new URLSearchParams(location.search)
	const id = params.get('topic')
	if (!id) {
		document.getElementById('content').textContent = 'Тема не указана.'
		return
	}

	try {
		const res = await fetch(`/api/theory/${id}/with-tests`, {
			credentials: 'same-origin',
		})
		if (!res.ok) throw new Error()
		const data = await res.json()

		// Выводим теорию
		document.getElementById('title').textContent = data.title
		document.getElementById('content').innerHTML = data.content
	} catch (err) {
		console.error(err)
		document.getElementById('content').textContent = 'Ошибка загрузки теории.'
	}
})

Файл: C:\dev\projects\html\Курсовая работа\static\theory\style.css
/* Скопировано и слегка адаптировано из вашего общего style.css */

*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}
:root {
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #fff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--sp-lg: 2rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

body {
	font-family: 'Inter', sans-serif;
	background: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background 0.5s ease, color 0.5s ease;
}

.navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	background: var(--card-bg);
	padding: var(--sp-sm) var(--sp-md);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
}
.logo {
	font-size: 1.25rem;
	color: var(--primary);
	font-weight: 700;
	cursor: pointer;
}
.nav-links {
	display: flex;
	gap: var(--sp-md);
}
.nav-links a {
	position: relative;
	text-decoration: none;
	color: var(--text-muted);
	font-weight: 500;
	transition: color var(--trans);
}
.nav-links a.active,
.nav-links a:hover {
	color: var(--primary);
}
.nav-links a.active::after,
.nav-links a:hover::after {
	content: '';
	position: absolute;
	left: 0;
	bottom: -2px;
	width: 100%;
	height: 2px;
	background: var(--primary);
}
.actions {
	display: flex;
	align-items: center;
}
#theme-toggle {
	background: none;
	border: none;
	cursor: pointer;
	margin-right: var(--sp-sm);
}
.user-icon img {
	width: 2rem;
	height: 2rem;
	border-radius: 50%;
	cursor: pointer;
}

.page-content {
	max-width: 800px;
	margin: var(--sp-lg) auto;
	padding: 0 var(--sp-md);
	text-align: left;
}
#title {
	margin-bottom: var(--sp-md);
	color: var(--primary);
}
#content {
	line-height: 1.6;
	margin-bottom: var(--sp-lg);
}
#go-to-questions {
	display: inline-block;
	padding: var(--sp-sm) var(--sp-md);
	background: var(--primary);
	color: #fff;
	border: none;
	border-radius: var(--radius);
	cursor: pointer;
	transition: transform var(--trans), box-shadow var(--trans);
}
#go-to-questions:hover {
	transform: translateY(-2px);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

img {
	max-width: 100%;
	height: auto;
	display: block;
	margin: 1rem auto;
	border-radius: 8px;
}

Файл: C:\dev\projects\html\Курсовая работа\static\welcomeMainPage\index.html
<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Главная — Set Learn</title>

		<!-- 1. Сначала — инициализация темы -->
		<script src="/static/js/theme-init.js"></script>

		<link rel="stylesheet" href="style.css" />
		<script src="script.js" defer></script>
	</head>
	<body>
		<!-- Навигационная панель для незарегистрированных -->
		<header class="navbar">
			<div class="actions">
				<!-- Переключатель темы -->
				<button id="theme-toggle" aria-label="Переключить тему">
					<img src="/static/img/dark-theme.png" alt="dark-theme-toggle" />
				</button>
			</div>
			<!-- Ссылка на страницу входа/регистрации -->
			<div class="auth-link">
				<a href="/static/loginPage/">Зарегистрироваться/Войти</a>
			</div>
		</header>

		<!-- Основной контент: плитки закрытого доступа -->
		<main class="container">
			<div class="tile" data-title="Пошаговая анимация">
				<h2><span class="lock-icon">🔒</span>Пошаговая анимация</h2>
				<p>
					Просмотр интерактивной демонстрации ассоциативного свойства множеств
				</p>
			</div>
			<div class="tile" data-title="Курсы">
				<h2><span class="lock-icon">🔒</span>Курсы</h2>
				<p>Курсы по темам, которые вы проходите на данный момент</p>
			</div>
			<div class="tile" data-title="Лидерборд">
				<h2><span class="lock-icon">🔒</span>Лидерборд</h2>
			</div>
		</main>

		<!-- Модальное окно с уведомлением о регистрации -->
		<div id="access-modal" class="modal">
			<div class="modal-content">
				<span class="close">&times;</span>
				<p>
					Для получения доступа необходимо
					<a href="/static/loginPage/">зарегистрироваться или войти</a>.
				</p>
			</div>
		</div>
	</body>
</html>

Файл: C:\dev\projects\html\Курсовая работа\static\welcomeMainPage\script.js
// Показ/скрытие модального окна доступа
function toggleModal(open) {
	document.getElementById('access-modal').classList.toggle('open', open)
}

// Обновление иконки темы
function updateToggleIcon(theme) {
	const btn = document.getElementById('theme-toggle')
	// Очищаем содержимое кнопки
	btn.innerHTML = ''

	// Создаём элемент изображения
	const icon = document.createElement('img')
	icon.alt = 'Toggle theme' // Альтернативный текст для доступности

	// Устанавливаем путь к изображению в зависимости от темы
	icon.src =
		theme === 'dark'
			? '/static/img/light-theme.png'
			: '/static/img/dark-theme.png'

	// Добавляем изображение в кнопку
	btn.appendChild(icon)
}

document.addEventListener('DOMContentLoaded', () => {
	// Клик по плиткам показывает попап
	document
		.querySelectorAll('.tile')
		.forEach(tile => tile.addEventListener('click', () => toggleModal(true)))

	// Закрытие по крестику
	document
		.querySelector('.modal .close')
		.addEventListener('click', () => toggleModal(false))

	// Закрытие кликом вне окна
	document.getElementById('access-modal').addEventListener('click', e => {
		if (e.target.id === 'access-modal') toggleModal(false)
	})

	// Инициализация темы
	const saved = localStorage.getItem('theme')
	const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
	const theme = saved || (prefersDark ? 'dark' : 'light')
	document.documentElement.setAttribute('data-theme', theme)
	updateToggleIcon(theme)

	// Переключатель темы
	document.getElementById('theme-toggle').addEventListener('click', () => {
		const next =
			document.documentElement.getAttribute('data-theme') === 'dark'
				? 'light'
				: 'dark'
		document.documentElement.setAttribute('data-theme', next)
		localStorage.setItem('theme', next)
		updateToggleIcon(next)
	})
})

Файл: C:\dev\projects\html\Курсовая работа\static\welcomeMainPage\style.css
/* RESET & VARIABLES */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
html {
	font-size: 16px;
	scroll-behavior: smooth;
}
body {
	font-family: 'Inter', sans-serif;
	background-color: var(--bg);
	color: var(--text);
	min-height: 100vh;
	transition: background-color 0.5s ease, color 0.5s ease;
}

/* THEME PALETTE */
:root {
	--bg: #f9fafb;
	--text: #1f2937;
	--card-bg: #ffffff;
	--border: #e5e7eb;
	--primary: #4f46e5;
	--text-muted: #6b7280;
	--sp-sm: 1rem;
	--sp-md: 1.5rem;
	--radius: 0.5rem;
	--trans: 0.3s ease;
}
:root[data-theme='dark'] {
	--bg: #1f2937;
	--text: #f9fafb;
	--card-bg: #2d3748;
	--border: #4a5568;
	--primary: #a78bfa;
	--text-muted: #a0aec0;
}

/* NAVBAR */
.navbar {
	display: flex;
	justify-content: flex-end;
	align-items: center;
	background-color: var(--card-bg);
	padding: var(--sp-sm);
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	z-index: 100;
	transition: background-color 0.5s ease;
}
.actions {
	margin-right: var(--sp-md);
}
#theme-toggle {
	background: none;
	border: none;
	font-size: 1.25rem;
	cursor: pointer;
	transition: transform var(--trans);
}
#theme-toggle:hover {
	transform: scale(1.1);
}

.auth-link a {
	color: var(--primary);
	font-weight: 600;
	text-decoration: none;
	transition: color var(--trans);
}
.auth-link a:hover {
	color: var(--text);
}

/* GRID */
.container {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
	gap: var(--sp-md);
	padding: var(--sp-md);
}

/* TILE */
.tile {
	background-color: var(--card-bg);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--sp-md);
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	cursor: pointer;
	transition: transform var(--trans), box-shadow var(--trans);
}
.tile:hover {
	transform: translateY(-4px);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.lock-icon {
	margin-right: 0.5rem;
}

/* MODAL */
.modal {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0, 0, 0, 0.4);
	align-items: center;
	justify-content: center;
	z-index: 200;
}
.modal.open {
	display: flex;
}
.modal-content {
	position: relative; /* нужно для абсолютного позиционирования крестика */
	padding: 2.5rem var(--sp-md) var(--sp-md);
	border-radius: var(--radius);
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
	max-width: 90%;
	background-color: var(--card-bg);
	display: flex;
	flex-direction: column;
	align-items: center;
	text-align: center;
}
.modal-content p a {
	color: var(--primary);
	font-weight: 600;
	text-decoration: none;
}
.modal-content .close {
	position: absolute;
	top: 1rem;
	right: 1rem;
	font-size: 1.5rem;
	cursor: pointer;
}

Файл: C:\dev\projects\html\Курсовая работа\difficulty.go
package main

import (
	"database/sql"
	"log"
)

// RecalcDifficulty пересчитывает поле difficulty в таблице questions
// на основе статистики из user_question_answers.
func RecalcDifficulty(db *sql.DB) error {
	const query = `
WITH stats AS (
  SELECT
    question_id,
    COUNT(*)           AS total_attempts,
    SUM(CASE WHEN is_correct THEN 1 ELSE 0 END)::FLOAT AS correct_count
  FROM user_question_answers
  GROUP BY question_id
  HAVING COUNT(*) >= 50
)
UPDATE questions q
   SET difficulty = CASE
       WHEN s.correct_count / s.total_attempts >= 0.7 THEN 'easy'
       WHEN s.correct_count / s.total_attempts <= 0.3 THEN 'hard'
       ELSE 'medium'
   END
  FROM stats s
 WHERE q.id = s.question_id
   AND q.difficulty IS DISTINCT FROM
       CASE
         WHEN s.correct_count / s.total_attempts >= 0.7 THEN 'easy'
         WHEN s.correct_count / s.total_attempts <= 0.3 THEN 'hard'
         ELSE 'medium'
       END;
`
	res, err := db.Exec(query)
	if err != nil {
		return err
	}
	count, _ := res.RowsAffected()
	log.Printf("RecalcDifficulty: updated %d rows\n", count)
	return nil
}

func RecalcDifficultyML(db *sql.DB) error {
	rows, err := db.Query(`SELECT id, question_text FROM questions`)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var id int
		var text string
		if err := rows.Scan(&id, &text); err != nil {
			log.Println("Ошибка чтения вопроса:", err)
			continue
		}

		diff, err := predictDifficulty(text)
		if err != nil {
			log.Println("Ошибка предсказания сложности для вопроса", id, ":", err)
			continue
		}

		_, err = db.Exec(`UPDATE questions SET difficulty = $1 WHERE id = $2`, diff, id)
		if err != nil {
			log.Println("Ошибка обновления вопроса", id, ":", err)
			continue
		}
	}

	log.Println("ML-пересчёт сложности завершён.")
	return nil
}

Файл: C:\dev\projects\html\Курсовая работа\handlers.go
package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
	"golang.org/x/crypto/bcrypt"
)

const (
	// всегда хранится в static/uploads/default.png
	defaultAvatar = "/static/uploads/default.png"
)

func uploadTheoryAssetHandler(w http.ResponseWriter, r *http.Request) {
	// 1) Ограничение метода
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	// 2) Разбор multipart-фомы
	err := r.ParseMultipartForm(10 << 20) // до 10 МБ
	if err != nil {
		http.Error(w, "Cannot parse form: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 3) Получение файла
	file, header, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "Field 'file' missing: "+err.Error(), http.StatusBadRequest)
		return
	}
	defer file.Close()

	// 4) Создание папки uploads, если нужно
	uploadDir := "./static/fileUploads"
	if err := os.MkdirAll(uploadDir, 0755); err != nil {
		http.Error(w, "Cannot create upload dir: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// 5) Генерация уникального имени файла
	timestamp := strconv.FormatInt(time.Now().UnixNano(), 10)
	filename := timestamp + "_" + filepath.Base(header.Filename)
	destPath := filepath.Join(uploadDir, filename)

	// 6) Сохранение на диск
	dst, err := os.Create(destPath)
	if err != nil {
		http.Error(w, "Cannot save file: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer dst.Close()
	if _, err := io.Copy(dst, file); err != nil {
		http.Error(w, "Error writing file: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// 7) Формирование URL для клиента
	// т.к. статика отдается по префиксу /static/, путь будет:
	fileURL := "/static/fileUploads/" + filename

	// 8) Отправка ответа
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"url": fileURL})
}

// uploadAvatarHandler — принимает multipart/form-data с полем "avatar"
func uploadAvatarHandler(w http.ResponseWriter, r *http.Request) {
	// 1. Проверяем метод
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// 2. Аутентификация по JWT
	tokenCookie, err := r.Cookie("token")
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}
	claims := &Claims{}
	if _, err := jwt.ParseWithClaims(tokenCookie.Value, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	}); err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// 3. Парсим форму (макс 10 MiB)
	if err := r.ParseMultipartForm(10 << 20); err != nil {
		http.Error(w, "File too big", http.StatusBadRequest)
		return
	}
	file, hdr, err := r.FormFile("avatar")
	if err != nil {
		http.Error(w, "No file uploaded", http.StatusBadRequest)
		return
	}
	defer file.Close()

	// 4. Считываем старый путь аватарки из БД
	var oldPath sql.NullString
	_ = db.QueryRow("SELECT avatar_path FROM users WHERE email = $1", claims.Email).
		Scan(&oldPath)

	// 5. Генерируем новое имя и сохраняем файл
	ext := filepath.Ext(hdr.Filename)
	filename := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)
	saveDir := "./static/uploads"
	if err := os.MkdirAll(saveDir, 0755); err != nil {
		http.Error(w, "Server error", http.StatusInternalServerError)
		return
	}
	outPath := filepath.Join(saveDir, filename)
	outFile, err := os.Create(outPath)
	if err != nil {
		http.Error(w, "Server error", http.StatusInternalServerError)
		return
	}
	defer outFile.Close()
	if _, err := io.Copy(outFile, file); err != nil {
		http.Error(w, "Server error", http.StatusInternalServerError)
		return
	}

	// 6. Обновляем путь в БД
	newDBPath := "/static/uploads/" + filename
	if _, err := db.Exec(
		"UPDATE users SET avatar_path = $1 WHERE email = $2",
		newDBPath, claims.Email,
	); err != nil {
		log.Println("Failed to update avatar_path:", err)
	}

	// 7. Удаляем старый файл, только если он не дефолтный
	if oldPath.Valid && oldPath.String != defaultAvatar {
		if err := os.Remove("." + oldPath.String); err != nil {
			log.Println("Failed to remove old avatar:", err)
		}
	}

	// 8. Возвращаем клиенту JSON с новым URL
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"url": newDBPath})
}

func removeAvatarHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	// авторизация
	tokenCookie, err := r.Cookie("token")
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}
	claims := &Claims{}
	if _, err := jwt.ParseWithClaims(tokenCookie.Value, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	}); err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// читаем старый путь
	var oldPath sql.NullString
	_ = db.QueryRow("SELECT avatar_path FROM users WHERE email=$1", claims.Email).Scan(&oldPath)

	// обновляем БД на дефолт
	_, _ = db.Exec("UPDATE users SET avatar_path=$1 WHERE email=$2", defaultAvatar, claims.Email)

	// если старый был не дефолтным — удаляем файл
	if oldPath.Valid && oldPath.String != defaultAvatar {
		os.Remove("." + oldPath.String)
	}

	// отдаем JSON с дефолтным URL
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"url": defaultAvatar})
}

// rootHandler: выдаёт welcomeMainPage или mainPage в зависимости от валидности JWT
func rootHandler(w http.ResponseWriter, r *http.Request) {
	// 0) Отключаем кэширование HTML-ответа
	w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
	w.Header().Set("Pragma", "no-cache")
	w.Header().Set("Expires", "0")

	// 1) Проверяем наличие JWT-куки
	tokenCookie, err := r.Cookie("token")
	if err != nil {
		// нет токена — отдаём welcome-страницу со всеми её статикой
		http.FileServer(http.Dir(welcomePagePath)).ServeHTTP(w, r)
		return
	}

	// 2) Парсим и проверяем токен
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tokenCookie.Value, claims, func(t *jwt.Token) (interface{}, error) {
		// проверяем алгоритм подписи
		if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
		}
		return jwtKey, nil
	})
	if err != nil {
		log.Printf("JWT parse error: %v", err)
		http.FileServer(http.Dir(welcomePagePath)).ServeHTTP(w, r)
		return
	}
	if !tkn.Valid || claims.ExpiresAt < time.Now().Unix() {
		log.Printf("Invalid or expired token for %s", claims.Email)
		http.FileServer(http.Dir(welcomePagePath)).ServeHTTP(w, r)
		return
	}

	// 3) Токен валиден — обновляем last_login
	if _, err := db.Exec(
		"UPDATE users SET last_login = $1 WHERE email = $2",
		time.Now(), claims.Email,
	); err != nil {
		log.Println("Failed to update last_login:", err)
	}

	// 4) Отдаём основную страницу со всеми статикой
	http.FileServer(http.Dir(mainPagePath)).ServeHTTP(w, r)
}

// registerHandler: регистрация нового пользователя
func registerHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var newUser struct {
		Name     string `json:"name"`
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	if err := json.NewDecoder(r.Body).Decode(&newUser); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	hashedPass, err := bcrypt.GenerateFromPassword([]byte(newUser.Password), bcrypt.DefaultCost)
	if err != nil {
		http.Error(w, "Server error", http.StatusInternalServerError)
		return
	}

	var exists bool
	err = db.QueryRow(
		"SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)",
		newUser.Email,
	).Scan(&exists)
	if err != nil || exists {
		http.Error(w, "User already exists", http.StatusBadRequest)
		return
	}

	_, err = db.Exec(
		`INSERT INTO users(email, password_hash, role, full_name, is_active, created_at)
		 VALUES($1,$2,$3,$4,$5,$6)`,
		newUser.Email, string(hashedPass), "student", newUser.Name, true, time.Now(),
	)
	if err != nil {
		http.Error(w, "Error creating user", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	w.Write([]byte("Registration successful"))
}

// loginHandler: аутентификация и установка JWT-куки
func loginHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var creds struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	if err := json.NewDecoder(r.Body).Decode(&creds); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	var user User
	err := db.QueryRow(
		"SELECT email, password_hash, role FROM users WHERE email = $1",
		creds.Email,
	).Scan(&user.Email, &user.PasswordHash, &user.Role)
	if err != nil {
		http.Error(w, "Invalid email or password", http.StatusUnauthorized)
		return
	}

	if err := bcrypt.CompareHashAndPassword(
		[]byte(user.PasswordHash), []byte(creds.Password),
	); err != nil {
		http.Error(w, "Invalid email or password", http.StatusUnauthorized)
		return
	}

	// Генерация токена
	expiration := time.Now().Add(48 * time.Hour) // токен обновляется каждые 48 часов
	claims := &Claims{
		Email:          user.Email,
		Role:           user.Role,
		StandardClaims: jwt.StandardClaims{ExpiresAt: expiration.Unix()},
	}
	tok := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokStr, err := tok.SignedString(jwtKey)
	if err != nil {
		http.Error(w, "Server error", http.StatusInternalServerError)
		return
	}

	// Устанавливаем куку
	http.SetCookie(w, &http.Cookie{
		Name:     "token",
		Value:    tokStr,
		Path:     "/",
		Expires:  expiration,
		MaxAge:   int(time.Until(expiration).Seconds()),
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
		Secure:   false,
	})

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"role": user.Role})
}

// profileAPIHandler — возвращает JSON профиля, с вычислением is_active по last_login
func profileAPIHandler(w http.ResponseWriter, r *http.Request) {
	// Авторизация через JWT-куку
	tokenCookie, err := r.Cookie("token")
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}
	claims := &Claims{}
	if _, err := jwt.ParseWithClaims(tokenCookie.Value, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	}); err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// Доставать поля, вычисляя is_active: true, если last_login < 5 минут назад
	var u struct {
		ID         int       `json:"id"`
		Email      string    `json:"email"`
		FullName   string    `json:"full_name"`
		IsActive   bool      `json:"is_active"`
		CreatedAt  time.Time `json:"created_at"`
		LastLogin  time.Time `json:"last_login"`
		AvatarPath string    `json:"avatar_path"`
		Role       string    `json:"role"`
		Group      *string   `json:"group"`
	}
	err = db.QueryRow(`
		SELECT
			id,
			email,
			full_name,
			CASE
				WHEN NOW() - last_login < INTERVAL '5 minutes' THEN TRUE
				ELSE FALSE
			END AS is_active,
			created_at,
			last_login,
			avatar_path,
			role
		FROM users
		WHERE email = $1
	`, claims.Email).Scan(
		&u.ID,
		&u.Email,
		&u.FullName,
		&u.IsActive,
		&u.CreatedAt,
		&u.LastLogin,
		&u.AvatarPath,
		&u.Role,
	)
	if u.Role == "student" {
		var name sql.NullString
		err = db.QueryRow(`
		  SELECT g.name
		  FROM student_groups sg
		  JOIN groups g ON g.id = sg.group_id
		  WHERE sg.student_id = $1 AND sg.removed_at IS NULL
		`, u.ID).Scan(&name)
		if err != nil && err != sql.ErrNoRows {
			http.Error(w, "Ошибка загрузки группы: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if name.Valid {
			u.Group = &name.String
		} else {
			u.Group = nil // не назначен в группу
		}
	}
	if err != nil {
		http.Error(w, "Server error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(u)
}

func profilePageHandler(w http.ResponseWriter, r *http.Request) {
	// 1) Проверяем JWT-куку
	tokenCookie, err := r.Cookie("token")
	if err != nil {
		http.Redirect(w, r, "/", http.StatusSeeOther)
		return
	}
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tokenCookie.Value, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil || !tkn.Valid || claims.ExpiresAt < time.Now().Unix() {
		http.Redirect(w, r, "/", http.StatusSeeOther)
		return
	}

	// 2) Отдаём index.html из папки profile
	http.ServeFile(w, r, filepath.Join(profilePath, "index.html"))
}

// logoutHandler: обнуляет токен и отдаёт страницу с обратным отсчётом
func logoutHandler(w http.ResponseWriter, r *http.Request) {
	// Удаляем куку
	http.SetCookie(w, &http.Cookie{
		Name:     "token",
		Value:    "",
		Path:     "/",
		Expires:  time.Unix(0, 0),
		MaxAge:   -1,
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
	})

	// Отдаём HTML с JS-таймером
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	fmt.Fprint(w, `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Вы вышли</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin-top: 50px; }
    #count { font-weight: bold; }
  </style>
</head>
<body>
  <h2>Вы вышли из учётной записи</h2>
  <p>Перенаправление на главную через <span id="count">3</span> секунды...</p>
  <p><a href="/">Перейти сразу</a></p>
  <script>
    (function() {
      let count = 3;
      const span = document.getElementById('count');
      const timer = setInterval(() => {
        count--;
        if (count >= 0) span.textContent = count;
        if (count <= 0) {
          clearInterval(timer);
          window.location.href = '/';
        }
      }, 1000);
    })();
  </script>
</body>
</html>`)
}

// POST /api/ping — обновляет last_login для текущего пользователя
func pingHandler(w http.ResponseWriter, r *http.Request) {
	// 1. Проверка метода запроса
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	// 2. Получаем JWT-куку
	cookie, err := r.Cookie("token")
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}
	tokenStr := cookie.Value

	// 3. Парсим и валидируем токен
	claims := &Claims{}
	token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
		// Проверка метода подписи
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return jwtKey, nil
	})
	if err != nil || !token.Valid {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// 4. Обновляем last_login (используем контекст и параметризованный запрос)
	_, err = db.ExecContext(r.Context(),
		`UPDATE users SET last_login = NOW() WHERE email = $1`,
		claims.Email,
	)
	if err != nil {
		log.Printf("pingHandler: failed to update last_login for %s: %v", claims.Email, err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	// log.Printf("PING received from %s (user: %s)", r.RemoteAddr, claims.Email)

	// 5. Успешный ответ — пустой (204 No Content)
	w.WriteHeader(http.StatusNoContent)
}

// adminUsersHandler — GET/PUT/DELETE: список, обновление роли и удаление пользователя
func adminUsersHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		rows, err := db.Query(`
            SELECT 
              u.id,
              u.email,
              u.full_name,
              u.role,
              (now() - u.last_login) < interval '10 seconds' AS is_active,
              u.last_login,
              sg.group_id
            FROM users u
            LEFT JOIN LATERAL (
              SELECT group_id
              FROM student_groups
              WHERE student_id = u.id
                AND removed_at IS NULL
              ORDER BY assigned_at DESC
              LIMIT 1
            ) sg ON TRUE
            ORDER BY u.id
        `)
		if err != nil {
			http.Error(w, "Database error: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var users []UserInfo
		for rows.Next() {
			var u UserInfo
			if err := rows.Scan(
				&u.ID,
				&u.Email,
				&u.FullName,
				&u.Role,
				&u.IsActive,
				&u.LastLogin,
				&u.GroupID, // сканируем group_id
			); err != nil {
				http.Error(w, "Scan error: "+err.Error(), http.StatusInternalServerError)
				return
			}
			users = append(users, u)
		}
		if err := rows.Err(); err != nil {
			http.Error(w, "Rows error: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(users)

	case http.MethodPut:
		// 2) PUT — изменить роль пользователя
		var req struct {
			ID   int    `json:"id"`
			Role string `json:"role"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		switch req.Role {
		case "student", "teacher", "admin":
		default:
			http.Error(w, "Invalid role", http.StatusBadRequest)
			return
		}
		res, err := db.Exec(
			"UPDATE users SET role = $1 WHERE id = $2",
			req.Role, req.ID,
		)
		if err != nil {
			http.Error(w, "DB error: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if cnt, _ := res.RowsAffected(); cnt == 0 {
			http.Error(w, "User not found", http.StatusNotFound)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	case http.MethodDelete:
		// 3) DELETE — удалить пользователя
		var req struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		res, err := db.Exec("DELETE FROM users WHERE id = $1", req.ID)
		if err != nil {
			http.Error(w, "DB error: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if cnt, _ := res.RowsAffected(); cnt == 0 {
			http.Error(w, "User not found", http.StatusNotFound)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	default:
		// 4) Всё остальное — метод не поддерживается
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

// adminGroupsHandler обрабатывает CRUD операции с группами
func adminGroupsHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		handleGetGroups(w, r)
	case http.MethodPost:
		handleCreateGroup(w, r)
	case http.MethodPut:
		handleUpdateGroup(w, r)
	case http.MethodDelete:
		handleDeleteGroup(w, r)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// === 1. Получить все группы ===
func handleGetGroups(w http.ResponseWriter, r *http.Request) {
	rows, err := db.Query(`SELECT id, name, teacher_id, created_at, updated_at FROM groups`)
	if err != nil {
		http.Error(w, "Не удалось загрузить группы: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var groups []Group
	for rows.Next() {
		var g Group
		err := rows.Scan(&g.ID, &g.Name, &g.TeacherID, &g.CreatedAt, &g.UpdatedAt)
		if err != nil {
			http.Error(w, "Ошибка чтения групп: "+err.Error(), http.StatusInternalServerError)
			return
		}
		groups = append(groups, g)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(groups)
}

// === 2. Создать новую группу ===
func handleCreateGroup(w http.ResponseWriter, r *http.Request) {
	var g Group
	if err := json.NewDecoder(r.Body).Decode(&g); err != nil {
		http.Error(w, "Некорректный JSON: "+err.Error(), http.StatusBadRequest)
		return
	}
	if g.Name == "" {
		http.Error(w, "Название группы обязательно", http.StatusBadRequest)
		return
	}

	var id int
	err := db.QueryRow(
		`INSERT INTO groups (name, teacher_id) VALUES ($1, $2) RETURNING id`,
		g.Name, g.TeacherID,
	).Scan(&id)
	if err != nil {
		http.Error(w, "Ошибка создания группы: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	fmt.Fprintf(w, `{"id":%d}`, id)
}

// === 3. Обновить данные группы ===
func handleUpdateGroup(w http.ResponseWriter, r *http.Request) {
	var g Group
	if err := json.NewDecoder(r.Body).Decode(&g); err != nil {
		http.Error(w, "Некорректный JSON: "+err.Error(), http.StatusBadRequest)
		return
	}
	if g.ID == 0 {
		http.Error(w, "ID группы обязателен", http.StatusBadRequest)
		return
	}

	// Обновляем только те поля, которые пришли
	_, err := db.Exec(
		`UPDATE groups SET name = COALESCE(NULLIF($1, ''), name), 
                          teacher_id = $2, 
                          updated_at = NOW() 
         WHERE id = $3`,
		g.Name, g.TeacherID, g.ID,
	)
	if err != nil {
		http.Error(w, "Ошибка обновления группы: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// === 4. Удалить группу (если в ней нет активных студентов) ===
func handleDeleteGroup(w http.ResponseWriter, r *http.Request) {
	var g Group
	if err := json.NewDecoder(r.Body).Decode(&g); err != nil {
		http.Error(w, "Некорректный JSON: "+err.Error(), http.StatusBadRequest)
		return
	}
	if g.ID == 0 {
		http.Error(w, "ID группы обязателен", http.StatusBadRequest)
		return
	}

	// Проверяем, что в группе нет активных студентов
	var count int
	err := db.QueryRow(`
    SELECT COUNT(*) 
    FROM student_groups 
    WHERE group_id = $1 AND removed_at IS NULL`, g.ID).Scan(&count)
	if err != nil {
		http.Error(w, "Ошибка проверки студентов: "+err.Error(), http.StatusInternalServerError)
		return
	}
	if count > 0 {
		http.Error(w, "Группа не пуста, её нельзя удалить", http.StatusBadRequest)
		return
	}

	_, err = db.Exec(`DELETE FROM groups WHERE id = $1`, g.ID)
	if err != nil {
		http.Error(w, "Ошибка удаления группы: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// adminStudentGroupsHandler обрабатывает назначение и удаление студентов в группах (только для Admin)
func adminStudentGroupsHandler(w http.ResponseWriter, r *http.Request) {
	// log.Printf("adminStudentGroupsHandler called: %s %s\n", r.Method, r.URL.Path)

	switch r.Method {
	case http.MethodPut:
		handleAssignStudentToGroup(w, r)
	case http.MethodDelete:
		handleRemoveStudentFromGroup(w, r)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// === Назначить или сменить группу ===
// PUT /api/admin/student-groups
// Тело: { "student_id": 123, "group_id": 456 }  или  { "student_id": 123, "group_id": null }
func handleAssignStudentToGroup(w http.ResponseWriter, r *http.Request) {
	// log.Println("▶ handleAssignStudentToGroup start")
	var p studentGroupPayload
	if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
		log.Println("⚠ JSON decode error:", err)
		http.Error(w, "Invalid JSON payload: "+err.Error(), http.StatusBadRequest)
		return
	}
	// log.Printf("▶ payload: student_id=%d, group_id=%v\n", p.StudentID, p.GroupID)

	tx, err := db.Begin()
	if err != nil {
		log.Println("⚠ db.Begin error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer tx.Rollback()

	// 1) Закрыть все существующие связи
	res, err := tx.Exec(`
      UPDATE student_groups
      SET removed_at = NOW()
      WHERE student_id = $1 AND removed_at IS NULL
    `, p.StudentID)
	if err != nil {
		log.Println("⚠ UPDATE error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	n, _ := res.RowsAffected()
	log.Printf("▶ closed %d old assignment(s)\n", n)

	// 2) Если группа задана — вставить новую запись
	if p.GroupID != nil {
		res2, err := tx.Exec(`
          INSERT INTO student_groups(student_id, group_id, assigned_at)
          VALUES($1, $2, NOW())
        `, p.StudentID, *p.GroupID)
		if err != nil {
			log.Println("⚠ INSERT error:", err)
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		n2, _ := res2.RowsAffected()
		log.Printf("▶ inserted %d new assignment\n", n2)
	}

	if err := tx.Commit(); err != nil {
		log.Println("⚠ Commit error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	log.Println("✔ handleAssignStudentToGroup committed")
	w.WriteHeader(http.StatusNoContent)
}

// === Удалить студента из группы ===
// DELETE /api/admin/student-groups
// Тело: { "student_id": 123, "group_id": 456 }
func handleRemoveStudentFromGroup(w http.ResponseWriter, r *http.Request) {
	var p studentGroupPayload
	if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
		http.Error(w, "Invalid JSON payload: "+err.Error(), http.StatusBadRequest)
		return
	}
	if p.StudentID == 0 || p.GroupID == nil {
		http.Error(w, "student_id and group_id are required", http.StatusBadRequest)
		return
	}

	res, err := db.Exec(`
		UPDATE student_groups
		SET removed_at = NOW()
		WHERE student_id = $1 AND group_id = $2 AND removed_at IS NULL
	`, p.StudentID, *p.GroupID)
	if err != nil {
		http.Error(w, "Failed to remove from group: "+err.Error(), http.StatusInternalServerError)
		return
	}
	rowsAffected, _ := res.RowsAffected()
	if rowsAffected == 0 {
		http.Error(w, "No active assignment found for given student and group", http.StatusBadRequest)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// teacherGroupsHandler отдаёт список групп преподавателя и позволяет редактировать их
//
// Маршруты:
//
//	GET  /api/teacher/groups         — список групп, где teacher_id = текущий userID
//	GET  /api/teacher/groups/{id}    — детали группы и её студенты
//	PUT  /api/teacher/groups/{id}    — обновить только поле name
func teacherGroupsHandler(w http.ResponseWriter, r *http.Request) {
	// Достаём JWT claims из куки
	tokenCookie, err := r.Cookie("token")
	if err != nil {
		http.Error(w, "Unauthorized: no token", http.StatusUnauthorized)
		return
	}

	claims := &Claims{}
	if _, err := jwt.ParseWithClaims(tokenCookie.Value, claims, func(t *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	}); err != nil {
		http.Error(w, "Unauthorized: invalid token", http.StatusUnauthorized)
		return
	}

	// Получаем ID преподавателя по email из claims
	var teacherID int
	err = db.QueryRow(`SELECT id FROM users WHERE email = $1 AND role = 'teacher'`, claims.Email).Scan(&teacherID)
	if err == sql.ErrNoRows {
		http.Error(w, "Преподаватель не найден", http.StatusForbidden)
		return
	} else if err != nil {
		http.Error(w, "Ошибка при получении ID преподавателя: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Разбор пути
	base := "/api/teacher/groups"
	path := strings.Trim(strings.TrimPrefix(r.URL.Path, base), "/")

	switch r.Method {
	case http.MethodGet:
		if path == "" {
			getTeacherGroups(w, teacherID)
		} else {
			id, err := strconv.Atoi(path)
			if err != nil {
				http.Error(w, "Неверный ID группы", http.StatusBadRequest)
				return
			}
			getTeacherGroupDetail(w, teacherID, id)
		}
	case http.MethodPut:
		if path == "" {
			http.Error(w, "ID группы обязателен", http.StatusBadRequest)
			return
		}
		id, err := strconv.Atoi(path)
		if err != nil {
			http.Error(w, "Неверный ID группы", http.StatusBadRequest)
			return
		}
		updateTeacherGroup(w, r, teacherID, id)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// GET /api/teacher/groups
func getTeacherGroups(w http.ResponseWriter, teacherID int) {
	rows, err := db.Query(`
        SELECT id, name, teacher_id, created_at, updated_at
        FROM groups
        WHERE teacher_id = $1
        ORDER BY name
    `, teacherID)
	if err != nil {
		http.Error(w, "Не удалось загрузить группы: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var list []Group
	for rows.Next() {
		var g Group
		if err := rows.Scan(&g.ID, &g.Name, &g.TeacherID, &g.CreatedAt, &g.UpdatedAt); err != nil {
			http.Error(w, "Ошибка чтения группы: "+err.Error(), http.StatusInternalServerError)
			return
		}
		list = append(list, g)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(list)
}

// GET /api/teacher/groups/{id}
func getTeacherGroupDetail(w http.ResponseWriter, teacherID, groupID int) {
	// Проверяем право
	var g Group
	err := db.QueryRow(`
        SELECT id, name, teacher_id, created_at, updated_at
        FROM groups
        WHERE id = $1 AND teacher_id = $2
    `, groupID, teacherID).Scan(&g.ID, &g.Name, &g.TeacherID, &g.CreatedAt, &g.UpdatedAt)
	if err == sql.ErrNoRows {
		http.Error(w, "Группа не найдена или нет доступа", http.StatusNotFound)
		return
	} else if err != nil {
		http.Error(w, "Ошибка загрузки группы: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Собираем студентов
	rows, err := db.Query(`
        SELECT u.id, u.full_name, u.email
        FROM users u
        JOIN student_groups sg ON sg.student_id = u.id
        WHERE sg.group_id = $1 AND sg.removed_at IS NULL
    `, groupID)
	if err != nil {
		http.Error(w, "Не удалось загрузить студентов: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var students []StudentBrief
	for rows.Next() {
		var s StudentBrief
		if err := rows.Scan(&s.ID, &s.FullName, &s.Email); err != nil {
			http.Error(w, "Ошибка чтения студентов: "+err.Error(), http.StatusInternalServerError)
			return
		}
		students = append(students, s)
	}

	detail := GroupDetail{
		ID:        g.ID,
		Name:      g.Name,
		TeacherID: g.TeacherID,
		Students:  students,
		CreatedAt: g.CreatedAt,
		UpdatedAt: g.UpdatedAt,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(detail)
}

// PUT /api/teacher/groups/{id}
func updateTeacherGroup(w http.ResponseWriter, r *http.Request, teacherID, groupID int) {
	var payload struct {
		Name string `json:"name"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, "Некорректный JSON: "+err.Error(), http.StatusBadRequest)
		return
	}
	if payload.Name == "" {
		http.Error(w, "Название обязательно", http.StatusBadRequest)
		return
	}

	res, err := db.Exec(`
        UPDATE groups
        SET name = $1, updated_at = NOW()
        WHERE id = $2 AND teacher_id = $3
    `, payload.Name, groupID, teacherID)
	if err != nil {
		http.Error(w, "Ошибка обновления: "+err.Error(), http.StatusInternalServerError)
		return
	}
	if n, _ := res.RowsAffected(); n == 0 {
		http.Error(w, "Нет доступа или группа не найдена", http.StatusNotFound)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// teacherStudentGroupsHandler позволяет преподавателю назначать и удалять студентов в своих группах
// Маршруты:
//
//	PUT    /api/teacher/student-groups   — назначить или сменить группу (student_id + group_id)
//	DELETE /api/teacher/student-groups   — удалить студента из группы (student_id + group_id)
func teacherStudentGroupsHandler(w http.ResponseWriter, r *http.Request) {
	// 1) Достаем Claims
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Не авторизован", http.StatusUnauthorized)
		return
	}

	// 2) Берем teacherID: из claims.UserID, или по Email, если UserID==0
	teacherID := claims.UserID
	if teacherID == 0 {
		// дополнительный запрос к БД
		err := db.QueryRow(
			`SELECT id FROM users WHERE email = $1 AND role = 'teacher'`,
			claims.Email,
		).Scan(&teacherID)
		if err != nil {
			http.Error(w, "Не удалось определить ID преподавателя", http.StatusInternalServerError)
			return
		}
	}
	// log.Printf("teacherStudentGroupsHandler: teacherID(claims)=%d", teacherID)

	// 2) Декодируем payload
	var p studentGroupPayload
	if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
		http.Error(w, "Некорректный JSON: "+err.Error(), http.StatusBadRequest)
		return
	}
	if p.GroupID == nil {
		http.Error(w, "group_id обязателен", http.StatusBadRequest)
		return
	}
	if p.StudentID == 0 && p.StudentEmail == "" {
		http.Error(w, "Надо указать student_id или student_email", http.StatusBadRequest)
		return
	}

	// 3) Проверка прав на группу
	var owner int
	err := db.QueryRow(
		`SELECT teacher_id FROM groups WHERE id = $1`,
		*p.GroupID,
	).Scan(&owner)
	if err == sql.ErrNoRows {
		http.Error(w, "Группа не найдена", http.StatusNotFound)
		return
	} else if err != nil {
		http.Error(w, "Ошибка проверки группы: "+err.Error(), http.StatusInternalServerError)
		return
	}
	// log.Printf("teacherStudentGroupsHandler: teacherID(claims)=%d, group.owner=%d\n", teacherID, owner)

	if owner != teacherID {
		http.Error(w, "Нет прав", http.StatusForbidden)
		return
	}

	// 4) Выполняем действие
	switch r.Method {
	case http.MethodPut:
		handleTeacherAssign(w, r.Context(), p)
	case http.MethodDelete:
		handleTeacherRemove(w, p)
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// Назначение или смена группы (PUT)
func handleTeacherAssign(w http.ResponseWriter, ctx context.Context, p studentGroupPayload) {
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		http.Error(w, "Ошибка транзакции: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer tx.Rollback()

	// lookup by email если нужно
	if p.StudentID == 0 && p.StudentEmail != "" {
		if err := tx.QueryRowContext(ctx, `
            SELECT id FROM users WHERE email = $1 AND role = 'student'
        `, p.StudentEmail).Scan(&p.StudentID); err != nil {
			if err == sql.ErrNoRows {
				http.Error(w, "Студент не найден", http.StatusBadRequest)
			} else {
				http.Error(w, "Ошибка поиска студента: "+err.Error(), http.StatusInternalServerError)
			}
			return
		}
	}

	// закрываем старые
	if _, err := tx.ExecContext(ctx, `
        UPDATE student_groups
        SET removed_at = NOW()
        WHERE student_id = $1 AND removed_at IS NULL
    `, p.StudentID); err != nil {
		http.Error(w, "Ошибка закрытия старых: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// вставляем новое
	if _, err := tx.ExecContext(ctx, `
        INSERT INTO student_groups(student_id, group_id, assigned_at)
        VALUES($1, $2, NOW())
    `, p.StudentID, *p.GroupID); err != nil {
		http.Error(w, "Ошибка назначения: "+err.Error(), http.StatusInternalServerError)
		return
	}

	if err := tx.Commit(); err != nil {
		http.Error(w, "Ошибка коммита: "+err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// Удаление студента из группы (DELETE)
func handleTeacherRemove(w http.ResponseWriter, p studentGroupPayload) {
	res, err := db.Exec(`
        UPDATE student_groups
        SET removed_at = NOW()
        WHERE student_id = $1 AND group_id = $2 AND removed_at IS NULL
    `, p.StudentID, *p.GroupID)
	if err != nil {
		http.Error(w, "Ошибка удаления: "+err.Error(), http.StatusInternalServerError)
		return
	}
	if n, _ := res.RowsAffected(); n == 0 {
		http.Error(w, "Активная запись не найдена", http.StatusBadRequest)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// adminCoursesHandler — GET/POST/PUT/DELETE для /api/admin/courses
func adminCoursesHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		handleGetCourses(w, r)
	case http.MethodPost:
		handleCreateCourse(w, r)
	case http.MethodPut:
		handleUpdateCourse(w, r)
	case http.MethodDelete:
		handleDeleteCourse(w, r)
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

// Обработчик GET запроса
func handleGetCourses(w http.ResponseWriter, r *http.Request) {
	rows, err := db.Query(`
		SELECT id, title, description, teacher_id, created_at 
		FROM courses 
		ORDER BY created_at DESC
	`)
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, "DB error: "+err.Error())
		return
	}
	defer rows.Close()

	var courses []CourseInfo
	for rows.Next() {
		var c CourseInfo
		var teacherID sql.NullInt64 // Для работы с NULL в БД

		err := rows.Scan(
			&c.ID,
			&c.Title,
			&c.Description,
			&teacherID,
			&c.CreatedAt,
		)

		if err != nil {
			respondWithError(w, http.StatusInternalServerError, "Scan error: "+err.Error())
			return
		}

		// Конвертируем sql.NullInt64 в *int
		if teacherID.Valid {
			id := int(teacherID.Int64)
			c.TeacherID = &id
		}

		courses = append(courses, c)
	}

	respondWithJSON(w, http.StatusOK, courses)
}

// Обработчик POST запроса (создание)
func handleCreateCourse(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Title       string `json:"title"`
		Description string `json:"description"`
		TeacherID   *int   `json:"teacher_id"` // Может быть nil
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid input: "+err.Error())
		return
	}

	var newID int
	err := db.QueryRow(`
		INSERT INTO courses (title, description, teacher_id)
		VALUES ($1, $2, $3)
		RETURNING id
	`, req.Title, req.Description, convertToNullInt(req.TeacherID)).Scan(&newID)

	if err != nil {
		handleDBError(w, "Create course error: ", err)
		return
	}

	respondWithJSON(w, http.StatusCreated, map[string]int{"id": newID})
}

// Обработчик PUT запроса (обновление)
func handleUpdateCourse(w http.ResponseWriter, r *http.Request) {
	var req CourseInfo
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid input: "+err.Error())
		return
	}

	res, err := db.Exec(`
		UPDATE courses
		SET 
			title = $1,
			description = $2,
			teacher_id = $3
		WHERE id = $4
	`, req.Title, req.Description, convertToNullInt(req.TeacherID), req.ID)

	if err != nil {
		handleDBError(w, "Update course error: ", err)
		return
	}

	if rowsAffected, _ := res.RowsAffected(); rowsAffected == 0 {
		respondWithError(w, http.StatusNotFound, "Course not found")
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// Обработчик DELETE запроса
func handleDeleteCourse(w http.ResponseWriter, r *http.Request) {
	var req struct {
		ID int `json:"id"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid input: "+err.Error())
		return
	}

	res, err := db.Exec("DELETE FROM courses WHERE id = $1", req.ID)
	if err != nil {
		handleDBError(w, "Delete course error: ", err)
		return
	}

	if rowsAffected, _ := res.RowsAffected(); rowsAffected == 0 {
		respondWithError(w, http.StatusNotFound, "Course not found")
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// Вспомогательные функции

func convertToNullInt(id *int) interface{} {
	if id == nil {
		return nil
	}
	return *id
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(payload)
}

func respondWithError(w http.ResponseWriter, code int, message string) {
	respondWithJSON(w, code, map[string]string{"error": message})
}

func handleDBError(w http.ResponseWriter, prefix string, err error) {
	if strings.Contains(err.Error(), "foreign key constraint") {
		respondWithError(w, http.StatusBadRequest, "Invalid teacher ID: teacher does not exist")
		return
	}

	respondWithError(w, http.StatusInternalServerError, prefix+err.Error())
}

// teacherCoursesHandler — CRUD курсов для текущего учителя
func teacherCoursesHandler(w http.ResponseWriter, r *http.Request) {
	// 1) Извлекаем claims из контекста
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}

	// 2) Находим ID учителя по email из токена
	var teacherID int
	err := db.QueryRow(
		"SELECT id FROM users WHERE email = $1",
		claims.Email,
	).Scan(&teacherID)
	if err != nil {
		http.Error(w, "User not found", http.StatusInternalServerError)
		return
	}

	switch r.Method {

	// GET /api/teacher/courses — список своих курсов
	case http.MethodGet:
		rows, err := db.Query(`
            SELECT id, title, description, teacher_id, created_at
            FROM courses
            WHERE teacher_id = $1
            ORDER BY created_at DESC
        `, teacherID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var list []CourseInfo
		for rows.Next() {
			var c CourseInfo
			if err := rows.Scan(&c.ID, &c.Title, &c.Description, &c.TeacherID, &c.CreatedAt); err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			list = append(list, c)
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(list)

	// POST /api/teacher/courses — создать новый курс
	case http.MethodPost:
		var req struct {
			Title       string `json:"title"`
			Description string `json:"description"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		var newID int
		err := db.QueryRow(
			`INSERT INTO courses (title, description, teacher_id)
             VALUES ($1,$2,$3) RETURNING id`,
			req.Title, req.Description, teacherID,
		).Scan(&newID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(map[string]int{"id": newID})

	// PUT /api/teacher/courses — обновить свой курс
	case http.MethodPut:
		var req CourseInfo
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем, что этот курс действительно принадлежит учителю
		var owner int
		err := db.QueryRow(
			"SELECT teacher_id FROM courses WHERE id = $1",
			req.ID,
		).Scan(&owner)
		if err != nil || owner != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		_, err = db.Exec(
			`UPDATE courses
             SET title=$1, description=$2
             WHERE id=$3`,
			req.Title, req.Description, req.ID,
		)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	// DELETE /api/teacher/courses — удалить свой курс
	case http.MethodDelete:
		var req struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем, что курс принадлежит учителю
		var ownerID int
		err := db.QueryRow(
			"SELECT teacher_id FROM courses WHERE id = $1",
			req.ID,
		).Scan(&ownerID)
		if err != nil || ownerID != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		_, err = db.Exec("DELETE FROM courses WHERE id = $1", req.ID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

// teacherTestsHandler — CRUD для тестов текущего учителя
func teacherTestsHandler(w http.ResponseWriter, r *http.Request) {
	// 1) Получаем claims из контекста
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}
	// 2) Определяем ID учителя по email
	var teacherID int
	if err := db.QueryRow(
		"SELECT id FROM users WHERE email = $1",
		claims.Email,
	).Scan(&teacherID); err != nil {
		http.Error(w, "User not found", http.StatusInternalServerError)
		return
	}

	switch r.Method {
	// GET /api/teacher/tests — список тестов
	case http.MethodGet:
		rows, err := db.Query(`
			SELECT t.id, t.title, t.description, t.course_id, t.created_at
			FROM tests t
			JOIN courses c ON c.id = t.course_id
			WHERE c.teacher_id = $1
			ORDER BY t.created_at DESC
		`, teacherID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var list []TestInfo
		for rows.Next() {
			var t TestInfo
			if err := rows.Scan(
				&t.ID, &t.Title, &t.Description, &t.CourseID, &t.CreatedAt,
			); err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			list = append(list, t)
		}
		if rows.Err() != nil {
			http.Error(w, rows.Err().Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(list)

	// POST /api/teacher/tests — создать новый тест
	case http.MethodPost:
		var req struct {
			Title       string `json:"title"`
			Description string `json:"description"`
			CourseID    int    `json:"course_id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем, что курс принадлежит учителю
		var owner int
		if err := db.QueryRow(
			"SELECT teacher_id FROM courses WHERE id = $1",
			req.CourseID,
		).Scan(&owner); err != nil || owner != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		var newID int
		err := db.QueryRow(
			`INSERT INTO tests (title, description, course_id)
			 VALUES ($1,$2,$3) RETURNING id`,
			req.Title, req.Description, req.CourseID,
		).Scan(&newID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(map[string]int{"id": newID})

	// PUT /api/teacher/tests — обновить тест
	case http.MethodPut:
		var req TestInfo
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем владение
		var ownerID int
		if err := db.QueryRow(
			`SELECT c.teacher_id
			 FROM tests t
			 JOIN courses c ON c.id = t.course_id
			 WHERE t.id = $1`,
			req.ID,
		).Scan(&ownerID); err != nil || ownerID != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		res, err := db.Exec(
			`UPDATE tests
			 SET title=$1, description=$2
			 WHERE id=$3`,
			req.Title, req.Description, req.ID,
		)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		if cnt, _ := res.RowsAffected(); cnt == 0 {
			http.Error(w, "Test not found", http.StatusNotFound)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	// DELETE /api/teacher/tests — удалить тест
	case http.MethodDelete:
		var req struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем владение
		var ownerID2 int
		if err := db.QueryRow(
			`SELECT c.teacher_id
			 FROM tests t
			 JOIN courses c ON c.id = t.course_id
			 WHERE t.id = $1`,
			req.ID,
		).Scan(&ownerID2); err != nil || ownerID2 != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		res2, err := db.Exec("DELETE FROM tests WHERE id = $1", req.ID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		if cnt, _ := res2.RowsAffected(); cnt == 0 {
			http.Error(w, "Test not found", http.StatusNotFound)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func teacherQuestionsHandler(w http.ResponseWriter, r *http.Request) {
	// 1) Проверка авторизации и получение teacherID из токена
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}
	var teacherID int
	if err := db.QueryRow(
		"SELECT id FROM users WHERE email = $1",
		claims.Email,
	).Scan(&teacherID); err != nil {
		http.Error(w, "User not found", http.StatusInternalServerError)
		return
	}

	switch r.Method {
	// GET /api/teacher/questions?test_id={id}
	case http.MethodGet:
		// 2) Получаем test_id из query
		testIDStr := r.URL.Query().Get("test_id")
		testID, err := strconv.Atoi(testIDStr)
		if err != nil {
			http.Error(w, "Invalid test_id", http.StatusBadRequest)
			return
		}
		// 3) Проверяем, что тест принадлежит учителю
		var owner int
		err = db.QueryRow(
			"SELECT c.teacher_id FROM tests t JOIN courses c ON c.id = t.course_id WHERE t.id = $1",
			testID,
		).Scan(&owner)
		if err != nil || owner != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		// 4) Запрашиваем вопросы вместе с correct_answer_text и difficulty
		rows, err := db.Query(`
            SELECT id,
                   test_id,
                   question_text,
                   question_type,
                   multiple_choice,
                   correct_answer_text,
                   difficulty,
                   created_at
            FROM questions
            WHERE test_id = $1
            ORDER BY created_at
        `, testID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var out []QuestionInfoOut
		for rows.Next() {
			var q QuestionInfo
			if err := rows.Scan(
				&q.ID,
				&q.TestID,
				&q.QuestionText,
				&q.QuestionType,
				&q.MultipleChoice,
				&q.CorrectAnswerText,
				&q.Difficulty,
				&q.CreatedAt,
			); err != nil {
				log.Println("Scan question error:", err)
				continue
			}
			out = append(out, QuestionInfoOut{
				QuestionInfo:      q,
				CorrectAnswerText: q.CorrectAnswerText.String,
			})
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(out)

	// POST /api/teacher/questions
	case http.MethodPost:
		var req teacherQuestionRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}

		// подтверждаем, что тест принадлежит учителю
		var owner2 int
		err := db.QueryRow(
			"SELECT c.teacher_id FROM tests t JOIN courses c ON c.id = t.course_id WHERE t.id = $1",
			req.TestID,
		).Scan(&owner2)
		if err != nil || owner2 != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}

		// Предсказание сложности
		diff, err := predictDifficulty(req.QuestionText)
		if err != nil {
			log.Println("ML predict error:", err)
			http.Error(w, "Failed to predict difficulty", http.StatusInternalServerError)
			return
		}

		// вставляем вместе с correct_answer_text и difficulty
		var newID int
		err = db.QueryRow(`
            INSERT INTO questions
                (test_id, question_text, question_type, multiple_choice, correct_answer_text, difficulty)
            VALUES
                ($1,      $2,            $3,            $4,              $5,                  $6)
            RETURNING id
        `,
			req.TestID,
			req.QuestionText,
			req.QuestionType,
			req.MultipleChoice,
			req.CorrectAnswerText,
			diff,
		).Scan(&newID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(map[string]int{"id": newID})

		// PUT /api/teacher/questions
	case http.MethodPut:
		var req teacherQuestionRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем право на обновление
		var owner3 int
		err := db.QueryRow(`
        SELECT c.teacher_id
        FROM questions q
        JOIN tests t ON t.id = q.test_id
        JOIN courses c ON c.id = t.course_id
        WHERE q.id = $1
    `, req.ID).Scan(&owner3)
		if err != nil || owner3 != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}

		// используем сложность из запроса (если поле осталось пустым — можно дефолтировать)
		newDiff := req.Difficulty
		if newDiff == "" {
			// при отсутствии client-side значения — fall back к ML
			var errPredict error
			newDiff, errPredict = predictDifficulty(req.QuestionText)
			if errPredict != nil {
				log.Println("ML predict error:", errPredict)
				http.Error(w, "Failed to predict difficulty", http.StatusInternalServerError)
				return
			}
		}

		// обновляем question_text, correct_answer_text и difficulty
		res, err := db.Exec(`
        UPDATE questions
        SET question_text       = $1,
            question_type       = $2,
            multiple_choice     = $3,
            correct_answer_text = $4,
            difficulty          = $5
        WHERE id = $6
    `,
			req.QuestionText,
			req.QuestionType,
			req.MultipleChoice,
			req.CorrectAnswerText,
			newDiff,
			req.ID,
		)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		if cnt, _ := res.RowsAffected(); cnt == 0 {
			http.Error(w, "Question not found", http.StatusNotFound)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	// DELETE /api/teacher/questions
	case http.MethodDelete:
		var req struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем права на удаление
		var owner4 int
		err := db.QueryRow(`
            SELECT c.teacher_id
            FROM questions q
            JOIN tests t ON t.id = q.test_id
            JOIN courses c ON c.id = t.course_id
            WHERE q.id = $1
        `, req.ID).Scan(&owner4)
		if err != nil || owner4 != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		_, err = db.Exec("DELETE FROM questions WHERE id = $1", req.ID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func teacherOptionsHandler(w http.ResponseWriter, r *http.Request) {
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}
	// находим teacherID
	var teacherID int
	if err := db.QueryRow("SELECT id FROM users WHERE email=$1", claims.Email).
		Scan(&teacherID); err != nil {
		http.Error(w, "User not found", http.StatusInternalServerError)
		return
	}

	switch r.Method {
	// GET /api/teacher/options?question_id=...
	case http.MethodGet:
		qidStr := r.URL.Query().Get("question_id")
		qid, err := strconv.Atoi(qidStr)
		if err != nil {
			http.Error(w, "Invalid question_id", http.StatusBadRequest)
			return
		}
		// проверяем владение вопросом через JOIN
		var owner int
		err = db.QueryRow(`
            SELECT c.teacher_id
            FROM questions q
            JOIN tests t ON t.id=q.test_id
            JOIN courses c ON c.id=t.course_id
            WHERE q.id=$1
        `, qid).Scan(&owner)
		if err != nil || owner != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		rows, err := db.Query(`
            SELECT id, question_id, option_text, is_correct, created_at
            FROM options WHERE question_id=$1 ORDER BY id
        `, qid)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		defer rows.Close()
		var opts []OptionInfo
		for rows.Next() {
			var o OptionInfo
			rows.Scan(&o.ID, &o.QuestionID, &o.OptionText, &o.IsCorrect, &o.CreatedAt)
			opts = append(opts, o)
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(opts)

	// POST /api/teacher/options
	case http.MethodPost:
		var req struct {
			QuestionID int    `json:"question_id"`
			OptionText string `json:"option_text"`
			IsCorrect  bool   `json:"is_correct"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем владение вопросом (тот же JOIN)
		var owner2 int
		err := db.QueryRow(`
            SELECT c.teacher_id
            FROM questions q
            JOIN tests t ON t.id=q.test_id
            JOIN courses c ON c.id=t.course_id
            WHERE q.id=$1
        `, req.QuestionID).Scan(&owner2)
		if err != nil || owner2 != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		var newID int
		err = db.QueryRow(
			`INSERT INTO options (question_id, option_text, is_correct)
             VALUES ($1,$2,$3) RETURNING id`,
			req.QuestionID, req.OptionText, req.IsCorrect,
		).Scan(&newID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(map[string]int{"id": newID})

	// PUT /api/teacher/options
	case http.MethodPut:
		var req OptionInfo
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid input", http.StatusBadRequest)
			return
		}
		// проверяем владение через JOIN точно так же
		var owner3 int
		err := db.QueryRow(`
            SELECT c.teacher_id
            FROM options o
            JOIN questions q ON q.id=o.question_id
            JOIN tests t ON t.id=q.test_id
            JOIN courses c ON c.id=t.course_id
            WHERE o.id=$1
        `, req.ID).Scan(&owner3)
		if err != nil || owner3 != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		_, err = db.Exec(
			`UPDATE options
             SET option_text=$1, is_correct=$2
             WHERE id=$3`,
			req.OptionText, req.IsCorrect, req.ID,
		)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	// DELETE /api/teacher/options
	case http.MethodDelete:
		var req struct {
			ID int `json:"id"`
		}
		json.NewDecoder(r.Body).Decode(&req)
		// проверяем владение (аналогично)
		var owner4 int
		err := db.QueryRow(`
            SELECT c.teacher_id
            FROM options o
            JOIN questions q ON q.id=o.question_id
            JOIN tests t ON t.id=q.test_id
            JOIN courses c ON c.id=t.course_id
            WHERE o.id=$1
        `, req.ID).Scan(&owner4)
		if err != nil || owner4 != teacherID {
			http.Error(w, "Forbidden", http.StatusForbidden)
			return
		}
		_, err = db.Exec("DELETE FROM options WHERE id=$1", req.ID)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusNoContent)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func GetCourses(w http.ResponseWriter, r *http.Request) {
	// Получаем список курсов
	rows, err := db.Query("SELECT id, title, description FROM courses")
	if err != nil {
		log.Println("GetCourses query error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	// Слайс результата
	var courses []map[string]interface{}

	for rows.Next() {
		var id int
		var title, description string
		if err := rows.Scan(&id, &title, &description); err != nil {
			log.Println("GetCourses scan error:", err)
			continue
		}

		// Подсчёт числа тестов, связанных с этим курсом
		var testCount int
		if err := db.QueryRow(
			"SELECT COUNT(*) FROM tests WHERE course_id = $1",
			id,
		).Scan(&testCount); err != nil {
			log.Println("GetCourses testCount error:", err)
			testCount = 0
		}

		// Формируем JSON-объект курса
		course := map[string]interface{}{
			"id":          id,
			"title":       title,
			"description": description,
			"test_count":  testCount,
		}
		courses = append(courses, course)
	}

	// Возвращаем JSON
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(courses); err != nil {
		log.Println("GetCourses encode error:", err)
	}
}

// тестовый код
func GetCourseByID(w http.ResponseWriter, r *http.Request) {
	// log.Println("===> GetCourseByID called")

	// ожидаем URL вида /api/courses/{id}
	idStr := strings.TrimPrefix(r.URL.Path, "/api/courses/")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		log.Println("Invalid course ID:", idStr, err)
		http.Error(w, "Invalid course ID", http.StatusBadRequest)
		return
	}
	// log.Println("Parsed course ID:", id)

	// 1. Основная информация о курсе
	var course struct {
		ID          int    `json:"id"`
		Title       string `json:"title"`
		Description string `json:"description"`
	}
	err = db.QueryRow("SELECT id, title, description FROM courses WHERE id = $1", id).
		Scan(&course.ID, &course.Title, &course.Description)
	if err != nil {
		log.Println("Course not found or DB error:", err)
		http.Error(w, "Course not found", http.StatusNotFound)
		return
	}

	// 2. Теория
	rowsT, err := db.Query("SELECT id, title, content FROM theory WHERE course_id = $1", id)
	if err != nil {
		log.Println("Error loading theory:", err)
		http.Error(w, "Error loading theory", http.StatusInternalServerError)
		return
	}
	defer rowsT.Close()

	var theory []map[string]interface{}
	for rowsT.Next() {
		var tID int
		var tTitle, tSum, tContent string
		err = rowsT.Scan(&tID, &tTitle, &tSum, &tContent)
		if err != nil {
			http.Error(w, "Error reading theory row", http.StatusInternalServerError)
			return
		}
		theory = append(theory, map[string]interface{}{
			"id":      tID,
			"title":   tTitle,
			"content": tContent, // можно опустить, если не нужен на этом этапе
		})

	}

	// 3. Тесты
	rowsQ, err := db.Query(`
        SELECT t.id, t.title, COUNT(q.*)
        FROM tests t
        LEFT JOIN questions q ON q.test_id = t.id
        WHERE t.course_id = $1
        GROUP BY t.id, t.title`, id)
	if err != nil {
		log.Println("Error loading tests:", err)
		http.Error(w, "Error loading tests", http.StatusInternalServerError)
		return
	}
	defer rowsQ.Close()

	var tests []map[string]interface{}
	for rowsQ.Next() {
		var testID, qCount int
		var testTitle string
		if err := rowsQ.Scan(&testID, &testTitle, &qCount); err != nil {
			log.Println("Error scanning test row:", err)
			continue
		}
		tests = append(tests, map[string]interface{}{
			"id":             testID,
			"title":          testTitle,
			"question_count": qCount,
		})
	}

	// Собираем всё в JSON
	resp := map[string]interface{}{
		"id":          course.ID,
		"title":       course.Title,
		"description": course.Description,
		"theory":      theory,
		"tests":       tests,
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(resp); err != nil {
		log.Println("JSON encoding error:", err)
		http.Error(w, "Failed to encode JSON", http.StatusInternalServerError)
	}
}

// GetTheory возвращает список теоретических тем для заданного курса,
// упорядоченных по полю sort_order.
func GetTheory(w http.ResponseWriter, r *http.Request) {
	// Разбор пути: /api/courses/{courseId}/theory
	p := strings.TrimPrefix(r.URL.Path, "/api/courses/")
	parts := strings.Split(p, "/") // ["4","theory"]
	if len(parts) != 2 || parts[1] != "theory" {
		http.NotFound(w, r)
		return
	}

	// Конвертируем courseID в int
	courseID, err := strconv.Atoi(parts[0])
	if err != nil {
		log.Println("GetTheory: invalid courseID:", parts[0])
		http.Error(w, "Bad Request", http.StatusBadRequest)
		return
	}

	// Структура для отдачи в JSON
	type TheoryItem struct {
		ID        int    `json:"id"`
		Title     string `json:"title"`
		Content   string `json:"content"`
		SortOrder int    `json:"sort_order"`
	}

	// Запрос с учетом sort_order
	rows, err := db.Query(`
        SELECT id, title, content, sort_order
        FROM theory
        WHERE course_id = $1
        ORDER BY sort_order
    `, courseID)
	if err != nil {
		log.Println("GetTheory query error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	// Чтение строк
	var items []TheoryItem
	for rows.Next() {
		var it TheoryItem
		if err := rows.Scan(&it.ID, &it.Title, &it.Content, &it.SortOrder); err != nil {
			log.Println("GetTheory scan error:", err)
			continue
		}
		items = append(items, it)
	}
	if err := rows.Err(); err != nil {
		log.Println("GetTheory rows error:", err)
	}

	// Отдаём JSON
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(items); err != nil {
		log.Println("GetTheory encode error:", err)
	}
}

// GET /api/courses/{courseID}/tests
func GetTests(w http.ResponseWriter, r *http.Request) {
	parts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
	if len(parts) != 4 {
		http.Error(w, "invalid path", http.StatusBadRequest)
		return
	}
	courseID := parts[2]

	rows, err := db.Query(`
        SELECT t.id, t.title,
            (SELECT COUNT(*) FROM questions q WHERE q.test_id = t.id) as question_count
        FROM tests t
        WHERE t.course_id = $1
        ORDER BY t.id
    `, courseID)
	if err != nil {
		http.Error(w, "db error", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	type Test struct {
		ID            int    `json:"id"`
		Title         string `json:"title"`
		QuestionCount int    `json:"question_count"`
	}

	var tests []Test
	for rows.Next() {
		var t Test
		if err := rows.Scan(&t.ID, &t.Title, &t.QuestionCount); err != nil {
			continue
		}
		tests = append(tests, t)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tests)
}

// GET /api/theory/{id}
func GetTheoryItem(w http.ResponseWriter, r *http.Request) {
	// ожидаем путь вида /api/theory/123
	idStr := strings.TrimPrefix(r.URL.Path, "/api/theory/")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		http.Error(w, "Invalid ID", http.StatusBadRequest)
		return
	}

	var item struct {
		ID      int    `json:"id"`
		Title   string `json:"title"`
		Content string `json:"content"`
	}
	err = db.QueryRow(
		"SELECT id, title, content FROM theory WHERE id = $1",
		id,
	).Scan(&item.ID, &item.Title, &item.Content)
	if err != nil {
		http.Error(w, "Not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(item)
}

// GET /api/tests/{testID}/questions
func GetTestQuestions(w http.ResponseWriter, r *http.Request) {
	// 1) Парсим testID из URL "/api/tests/123/questions"
	parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/tests/"), "/")
	if len(parts) != 2 || parts[1] != "questions" {
		http.NotFound(w, r)
		return
	}
	testID, err := strconv.Atoi(parts[0])
	if err != nil {
		http.Error(w, "Invalid testID", http.StatusBadRequest)
		return
	}

	// 2) Запрашиваем все вопросы этого теста
	rows, err := db.Query(`SELECT id, test_id, question_text, question_type, multiple_choice, correct_answer_text, created_at, difficulty
		FROM questions
		WHERE test_id = $1
		ORDER BY id`, testID)
	if err != nil {
		http.Error(w, "DB error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var questions []QuestionInfo
	for rows.Next() {
		var q QuestionInfo
		if err := rows.Scan(
			&q.ID,
			&q.TestID,
			&q.QuestionText,
			&q.QuestionType,
			&q.MultipleChoice,
			&q.CorrectAnswerText,
			&q.CreatedAt,
			&q.Difficulty,
		); err != nil {
			log.Println("Scan question error:", err)
			continue
		}

		// 3) Для закрытых вопросов подгружаем опции
		if q.QuestionType == "closed" {
			optRows, err := db.Query(`SELECT id, question_id, option_text, is_correct, created_at
				FROM options
				WHERE question_id = $1
				ORDER BY id`, q.ID)
			if err != nil {
				log.Println("Options query error:", err)
			} else {
				for optRows.Next() {
					var o OptionInfo
					if err := optRows.Scan(
						&o.ID,
						&o.QuestionID,
						&o.OptionText,
						&o.IsCorrect,
						&o.CreatedAt,
					); err != nil {
						log.Println("Scan option error:", err)
						continue
					}
					q.Options = append(q.Options, o)
				}
				optRows.Close()
			}
		}

		questions = append(questions, q)
	}

	// 4) Формируем выходную структуру
	var result []QuestionInfoOut
	for _, q := range questions {
		result = append(result, QuestionInfoOut{
			QuestionInfo:      q,
			CorrectAnswerText: q.CorrectAnswerText.String,
		})
	}

	// 5) Отдаём JSON
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(result); err != nil {
		log.Println("Encode questions error:", err)
	}
}

func GetTheoryWithTests(w http.ResponseWriter, r *http.Request) {
	idStr := strings.TrimPrefix(r.URL.Path, "/api/theory/")
	idStr = strings.TrimSuffix(idStr, "/with-tests")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		http.Error(w, "Invalid theory ID", http.StatusBadRequest)
		return
	}

	// Загружаем саму теорию
	var theory TheoryWithTests
	err = db.QueryRow(`SELECT id, title, content, course_id, created_at FROM theory WHERE id = $1`, id).
		Scan(&theory.ID, &theory.Title, &theory.Content, &theory.CourseID, &theory.CreatedAt)
	if err != nil {
		http.Error(w, "Theory not found", http.StatusNotFound)
		return
	}

	// Загружаем тесты по course_id
	testsRows, err := db.Query(`SELECT id, title, description, created_at FROM tests WHERE course_id = $1`, theory.CourseID)
	if err != nil {
		http.Error(w, "Tests query failed", http.StatusInternalServerError)
		return
	}
	defer testsRows.Close()

	for testsRows.Next() {
		var test Test
		if err := testsRows.Scan(&test.ID, &test.Title, &test.Description, &test.CreatedAt); err != nil {
			continue
		}

		// Загружаем вопросы для теста
		qRows, err := db.Query(`SELECT id, question_text, question_type, multiple_choice, created_at FROM questions WHERE test_id = $1`, test.ID)
		if err != nil {
			continue
		}

		for qRows.Next() {
			var question Question
			if err := qRows.Scan(&question.ID, &question.Text, &question.Type, &question.MultipleChoice, &question.CreatedAt); err != nil {
				continue
			}

			// Загружаем варианты для вопроса
			oRows, err := db.Query(`SELECT id, option_text, is_correct, created_at FROM options WHERE question_id = $1`, question.ID)
			if err != nil {
				continue
			}
			for oRows.Next() {
				var option Option
				if err := oRows.Scan(&option.ID, &option.Text, &option.IsCorrect, &option.CreatedAt); err != nil {
					continue
				}
				question.Options = append(question.Options, option)
			}
			oRows.Close()

			test.Questions = append(test.Questions, question)
		}
		qRows.Close()

		theory.Tests = append(theory.Tests, test)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(theory)
}

// POST /api/teacher/questions/set_open_answer
// POST /api/teacher/questions/set_open_answer
func teacherSetOpenAnswerHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}
	// Авторизация
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}
	var teacherID int
	if err := db.QueryRow(
		"SELECT id FROM users WHERE email=$1",
		claims.Email,
	).Scan(&teacherID); err != nil {
		http.Error(w, "User not found", http.StatusInternalServerError)
		return
	}

	// Парсим JSON тело
	var data struct {
		ID     int    `json:"id"`
		Answer string `json:"answer"`
	}
	if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}
	qid := data.ID
	answer := data.Answer

	// Проверяем владельца вопроса
	var owner int
	err := db.QueryRow(`
        SELECT c.teacher_id
        FROM questions q
        JOIN tests t ON t.id = q.test_id
        JOIN courses c ON c.id = t.course_id
        WHERE q.id = $1
    `, qid).Scan(&owner)
	if err != nil {
		http.Error(w, "Question not found", http.StatusNotFound)
		return
	}
	if owner != teacherID {
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}

	// Обновляем ответ
	if _, err := db.Exec(
		`UPDATE questions
           SET correct_answer_text = $1
         WHERE id = $2`,
		answer, qid,
	); err != nil {
		http.Error(w, "DB error: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Возвращаем 200 OK (или 204 No Content)
	w.WriteHeader(http.StatusOK)
}

// POST /api/teacher/courses/{courseId}/theory
func CreateTheoryHandler(w http.ResponseWriter, r *http.Request) {
	// 1) парсим courseId
	p := strings.TrimPrefix(r.URL.Path, "/api/teacher/courses/")
	courseStr := strings.Split(p, "/")[0]
	courseID, err := strconv.Atoi(courseStr)
	if err != nil {
		http.Error(w, "Bad Request: invalid course ID", http.StatusBadRequest)
		return
	}

	// 2) декодим тело
	var req struct {
		Title   string `json:"title"`
		Content string `json:"content"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Bad Request: "+err.Error(), http.StatusBadRequest)
		return
	}

	// 3) валидация заголовка
	req.Title = strings.TrimSpace(req.Title)
	if req.Title == "" {
		http.Error(w, "Bad Request: title cannot be empty", http.StatusBadRequest)
		return
	}

	// 4) вычисляем следующий sort_order
	var maxOrder int
	err = db.QueryRow(`
	  SELECT COALESCE(MAX(sort_order), 0)
	  FROM theory
	  WHERE course_id = $1
	`, courseID).Scan(&maxOrder)
	if err != nil {
		log.Println("CreateTheory max order query error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
	newOrder := maxOrder + 1

	// 5) вставляем новую тему
	var newID int
	err = db.QueryRow(`
	  INSERT INTO theory (course_id, title, content, sort_order, created_at, updated_at)
	  VALUES ($1, $2, $3, $4, NOW(), NOW())
	  RETURNING id
	`, courseID, req.Title, req.Content, newOrder).Scan(&newID)
	if err != nil {
		log.Println("CreateTheory query error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	// 6) отдаем клиенту созданный объект
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"id":         newID,
		"course_id":  courseID,
		"title":      req.Title,
		"content":    req.Content,
		"sort_order": newOrder,
	})
}

// PUT /api/teacher/theory/{id}
func UpdateTheoryHandler(w http.ResponseWriter, r *http.Request, id int) {
	var req map[string]interface{}
	err := json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	fields := []string{}
	args := []interface{}{}
	i := 1

	if title, ok := req["title"].(string); ok {
		fields = append(fields, fmt.Sprintf("title = $%d", i))
		args = append(args, title)
		i++
	}

	if content, ok := req["content"].(string); ok {
		fields = append(fields, fmt.Sprintf("content = $%d", i))
		args = append(args, content)
		i++
	}

	if sortOrder, ok := req["sort_order"].(float64); ok { // JSON numbers -> float64
		fields = append(fields, fmt.Sprintf("sort_order = $%d", i))
		args = append(args, int(sortOrder))
		i++
	}

	if len(fields) == 0 {
		http.Error(w, "No fields to update", http.StatusBadRequest)
		return
	}

	args = append(args, id)
	query := fmt.Sprintf("UPDATE theory SET %s WHERE id = $%d", strings.Join(fields, ", "), i)

	_, err = db.Exec(query, args...)
	if err != nil {
		http.Error(w, "DB update error", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// DELETE /api/teacher/theory/{id}
func DeleteTheoryHandler(w http.ResponseWriter, r *http.Request, id int) {
	res, err := db.Exec(`DELETE FROM theory WHERE id = $1`, id)
	if err != nil {
		log.Println("DeleteTheory query error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
	if cnt, _ := res.RowsAffected(); cnt == 0 {
		http.Error(w, "Not Found", http.StatusNotFound)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// PUT /api/teacher/courses/{courseId}/theory/order
func ReorderTheoryHandler(w http.ResponseWriter, r *http.Request) {
	// Декодируем список {id, sort_order}
	var list []struct {
		ID        int `json:"id"`
		SortOrder int `json:"sort_order"`
	}
	if err := json.NewDecoder(r.Body).Decode(&list); err != nil {
		http.Error(w, "Bad Request: "+err.Error(), http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		log.Println("ReorderTheory begin tx error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare(`UPDATE theory SET sort_order = $1, updated_at = NOW() WHERE id = $2`)
	if err != nil {
		log.Println("ReorderTheory prepare error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
	defer stmt.Close()

	for _, it := range list {
		if _, err := stmt.Exec(it.SortOrder, it.ID); err != nil {
			log.Println("ReorderTheory exec error for id", it.ID, ":", err)
			http.Error(w, "Internal Server Error", http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		log.Println("ReorderTheory commit error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// GET /api/teacher/theory/{id}
func GetTheoryHandler(w http.ResponseWriter, r *http.Request, id int) {
	var theory struct {
		ID        int       `json:"id"`
		CourseID  int       `json:"course_id"`
		Title     string    `json:"title"`
		Content   string    `json:"content"`
		SortOrder int       `json:"sort_order"`
		CreatedAt time.Time `json:"created_at"`
		UpdatedAt time.Time `json:"updated_at"`
	}

	err := db.QueryRow(`
		SELECT id, course_id, title, content, sort_order, created_at, updated_at
		FROM theory
		WHERE id = $1
	`, id).Scan(
		&theory.ID, &theory.CourseID, &theory.Title, &theory.Content,
		&theory.SortOrder, &theory.CreatedAt, &theory.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			http.Error(w, "Not Found", http.StatusNotFound)
			return
		}
		log.Println("GetTheory query error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(theory)
}

// SubmitAnswerHandler — сохраняет историю ответа и обновляет попытку
func SubmitAnswerHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	// Получаем user_id из JWT-claims
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Не авторизован", http.StatusUnauthorized)
		return
	}
	userID := claims.UserID
	if userID == 0 {
		// дополнительный запрос к БД
		err := db.QueryRow(
			`SELECT id FROM users WHERE email = $1`,
			claims.Email,
		).Scan(&userID)
		if err != nil {
			http.Error(w, "Не удалось определить ID", http.StatusInternalServerError)
			return
		}
	}

	// Парсим тело
	var req struct {
		QuestionID int  `json:"question_id"`
		IsCorrect  bool `json:"is_correct"`
		AttemptID  int  `json:"attempt_id"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	// Начинаем транзакцию
	tx, err := db.Begin()
	if err != nil {
		log.Println("Begin tx error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
	defer tx.Rollback()

	// 1) Вставляем историю ответа
	_, err = tx.Exec(
		`INSERT INTO user_question_answers (user_id, question_id, is_correct, attempt_id)
         VALUES ($1, $2, $3, $4)`,
		userID, req.QuestionID, req.IsCorrect, req.AttemptID,
	)
	if err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	// 2) Обновляем счётчики в активной попытке
	res, err := tx.Exec(
		`UPDATE user_test_attempts
            SET correct_answers = correct_answers + CASE WHEN $3 THEN 1 ELSE 0 END,
                wrong_answers   = wrong_answers   + CASE WHEN $3 THEN 0 ELSE 1 END
          WHERE user_id = $1
            AND    finished_at IS NULL
            AND    test_id IN (
                   SELECT test_id FROM questions WHERE id = $2
                )`,
		userID, req.QuestionID, req.IsCorrect,
	)
	if err != nil {
		log.Println("Update user_test_attempts error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
	// Optional: проверить, что строка действительно обновилась
	if count, _ := res.RowsAffected(); count == 0 {
		log.Println("No active user_test_attempts row to update")
	}

	// 3) Коммитим
	if err := tx.Commit(); err != nil {
		log.Println("Commit tx error:", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	// 4) Возвращаем подтверждение с краткой статистикой (по желанию)
	resp := struct {
		Message string `json:"message"`
	}{"Answer recorded"}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(resp)
}

func GetAttemptsCount(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	p := strings.TrimPrefix(r.URL.Path, "/api/tests/")
	parts := strings.Split(p, "/")
	if len(parts) != 3 || parts[1] != "attempts" || parts[2] != "count" {
		http.NotFound(w, r)
		return
	}

	testID, err := strconv.Atoi(parts[0])
	if err != nil {
		http.Error(w, "Invalid test ID", http.StatusBadRequest)
		return
	}

	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Не авторизован", http.StatusUnauthorized)
		return
	}

	var cnt int
	err = db.QueryRow(
		`SELECT COUNT(*) FROM user_test_attempts WHERE user_id=$1 AND test_id=$2`,
		claims.UserID, testID,
	).Scan(&cnt)
	if err != nil {
		http.Error(w, "DB error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]int{"attemptsDone": cnt})
}

func CreateTestAttempt(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	p := strings.TrimPrefix(r.URL.Path, "/api/tests/")
	parts := strings.Split(p, "/")
	if len(parts) != 2 || parts[1] != "attempts" {
		http.NotFound(w, r)
		return
	}

	testID, err := strconv.Atoi(parts[0])
	if err != nil {
		http.Error(w, "Invalid test ID", http.StatusBadRequest)
		return
	}

	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Не авторизован", http.StatusUnauthorized)
		return
	}

	userID := claims.UserID
	if userID == 0 {
		// дополнительный запрос к БД
		err := db.QueryRow(
			`SELECT id FROM users WHERE email = $1`,
			claims.Email,
		).Scan(&userID)
		if err != nil {
			http.Error(w, "Не удалось определить ID преподавателя", http.StatusInternalServerError)
			return
		}
	}
	// fmt.Printf("CreateTestAttempt: user %d, test %d\n", userID, testID)

	var attemptID, attemptNumber int
	err = db.QueryRow(`
        INSERT INTO user_test_attempts
            (user_id, test_id,
             started_at, finished_at,
             score, correct_answers,
             wrong_answers, attempt_number)
        VALUES
            ($1, $2,
             NOW(), NULL,
             0, 0,
             0,
             (SELECT COALESCE(MAX(attempt_number),0)+1
                FROM user_test_attempts
               WHERE user_id = $1 AND test_id = $2))
        RETURNING id, attempt_number
    `, userID, testID).Scan(&attemptID, &attemptNumber)
	if err != nil {
		fmt.Printf("CreateTestAttempt DB insert error: %v\n", err)
		http.Error(w, "DB insert error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]int{
		"attemptId":     attemptID,
		"attemptNumber": attemptNumber,
	})
}

func FinishTestAttempt(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPatch {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	p := strings.TrimPrefix(r.URL.Path, "/api/attempts/")
	parts := strings.Split(p, "/")
	if len(parts) != 2 || parts[1] != "finish" {
		http.NotFound(w, r)
		return
	}
	attemptID, err := strconv.Atoi(parts[0])
	if err != nil {
		http.Error(w, "Invalid attempt ID", http.StatusBadRequest)
		return
	}

	var payload struct {
		Score          int `json:"score"`
		CorrectAnswers int `json:"correct_answers"`
		WrongAnswers   int `json:"wrong_answers"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Не авторизован", http.StatusUnauthorized)
		return
	}

	userID := claims.UserID
	if userID == 0 {
		// дополнительный запрос к БД
		err := db.QueryRow(
			`SELECT id FROM users WHERE email = $1`,
			claims.Email,
		).Scan(&userID)
		if err != nil {
			http.Error(w, "Не удалось определить ID преподавателя", http.StatusInternalServerError)
			return
		}
	}

	res, err := db.Exec(`
        UPDATE user_test_attempts
           SET finished_at     = NOW(),
               score           = $1,
               correct_answers = $2,
               wrong_answers   = $3
         WHERE id = $4 AND user_id = $5
    `, payload.Score, payload.CorrectAnswers, payload.WrongAnswers, attemptID, userID)
	if err != nil {
		http.Error(w, "DB update error", http.StatusInternalServerError)
		return
	}
	if rows, _ := res.RowsAffected(); rows == 0 {
		http.Error(w, "Not found or forbidden", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]bool{"ok": true})
}

func GetLatestAttempt(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	// Извлечь testId из URL
	p := strings.TrimPrefix(r.URL.Path, "/api/tests/")
	parts := strings.Split(p, "/")
	testID, err := strconv.Atoi(parts[0])
	if err != nil {
		http.Error(w, "Invalid test ID", http.StatusBadRequest)
		return
	}

	// Извлечь userID из JWT-куки
	claims := getClaims(r.Context())
	if claims == nil {
		http.Error(w, "Не авторизован", http.StatusUnauthorized)
		return
	}
	userID := claims.UserID
	if userID == 0 {
		// дополнительный запрос к БД
		err := db.QueryRow(
			`SELECT id FROM users WHERE email = $1`,
			claims.Email,
		).Scan(&userID)
		if err != nil {
			http.Error(w, "Не удалось определить ID", http.StatusInternalServerError)
			return
		}
	}

	// Запрос к БД — последняя завершённая попытка
	var score, attemptNumber int
	err = db.QueryRow(`
	  SELECT score, attempt_number
	    FROM user_test_attempts
	   WHERE user_id = $1
	     AND test_id = $2
	     AND finished_at IS NOT NULL
	   ORDER BY started_at DESC
	   LIMIT 1
	`, userID, testID).Scan(&score, &attemptNumber)

	if err == sql.ErrNoRows {
		// нет завершённых попыток — возвращаем 204 No Content
		w.WriteHeader(http.StatusNoContent)
		return
	}
	if err != nil {
		// какая-то другая ошибка — логируем
		log.Printf("GetLatestAttempt DB error (test %d, user %d): %v", testID, userID, err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	// Логируем на всякий случай полученные данные
	log.Printf("GetLatestAttempt: test=%d user=%d -> score=%d attemptNumber=%d",
		testID, userID, score, attemptNumber,
	)

	// Отдать JSON
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]int{
		"score":          score,
		"attempt_number": attemptNumber,
	})
}

Файл: C:\dev\projects\html\Курсовая работа\main.go
package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"mime"
	"net/http"
	"strconv"
	"strings"
	"time"

	_ "github.com/lib/pq"
	"github.com/robfig/cron/v3"
	"golang.org/x/crypto/bcrypt"
)

// DB connection data
const (
	host     = "localhost"
	port     = 5432
	user     = "garun"
	password = "origami"
	dbname   = "KursachDB"
)

var (
	db              *sql.DB
	jwtKey          = []byte("my_secret_key")
	welcomePagePath = "./static/welcomeMainPage"
	mainPagePath    = "./static/mainPage"
	profilePath     = "./static/profile"
)

// predictDifficulty запрашивает сложность вопроса у ML-сервиса.
func predictDifficulty(text string) (string, error) {
	payload, _ := json.Marshal(map[string]string{"question_text": text})
	resp, err := http.Post("http://localhost:5000/predict",
		"application/json",
		bytes.NewBuffer(payload),
	)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	var out struct {
		Difficulty string `json:"difficulty"`
		Error      string `json:"error,omitempty"`
	}
	if err := json.Unmarshal(body, &out); err != nil {
		return "", err
	}
	if out.Error != "" {
		return "", fmt.Errorf("ml error: %s", out.Error)
	}
	return out.Difficulty, nil
}

func main() {
	// Подключаемся к БД
	psqlInfo := fmt.Sprintf(
		"host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname,
	)
	var err error
	db, err = sql.Open("postgres", psqlInfo)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
	if err = db.Ping(); err != nil {
		log.Fatal(err)
	}

	// Создаём начального администратора, если нет
	createAdminUser()

	// MIME-типы для статики
	mime.AddExtensionType(".css", "text/css")
	mime.AddExtensionType(".js", "application/javascript")
	mime.AddExtensionType(".svg", "image/svg+xml")

	// Основной мультиплексор
	mux := http.NewServeMux()
	// Статика и публичные страницы
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static"))))
	mux.HandleFunc("/", rootHandler)
	mux.HandleFunc("/register", registerHandler)
	mux.HandleFunc("/login", loginHandler)
	mux.HandleFunc("/profile", profilePageHandler)
	mux.HandleFunc("/logout", logoutHandler)

	// API-mux для авторизованных
	apiMux := http.NewServeMux()

	// === общие для всех ролей ===
	apiMux.HandleFunc("/api/ping", pingHandler)
	apiMux.HandleFunc("/api/profile", profileAPIHandler)
	apiMux.HandleFunc("/api/upload-avatar", uploadAvatarHandler)
	apiMux.HandleFunc("/api/remove-avatar", removeAvatarHandler)

	// POST /api/student/answer — запись одиночного ответа
	apiMux.Handle(
		"/api/student/answer",
		RequireAnyRole([]string{"student", "teacher", "admin"}, http.HandlerFunc(SubmitAnswerHandler)),
	)

	// === только admin ===
	apiMux.Handle(
		"/api/admin/users",
		RequireRole("admin", http.HandlerFunc(adminUsersHandler)),
	)
	apiMux.Handle(
		"/api/admin/courses",
		RequireRole("admin", http.HandlerFunc(adminCoursesHandler)),
	)

	// === только admin для работы с группами ===
	apiMux.Handle(
		"/api/admin/groups",
		RequireRole("admin", http.HandlerFunc(adminGroupsHandler)),
	)
	apiMux.Handle(
		"/api/admin/student-groups",
		RequireRole("admin", http.HandlerFunc(adminStudentGroupsHandler)),
	)

	// === teacher для своих групп ===
	apiMux.Handle(
		"/api/teacher/groups/",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(teacherGroupsHandler)),
	)
	apiMux.Handle(
		"/api/teacher/groups",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(teacherGroupsHandler)),
	)

	apiMux.Handle(
		"/api/teacher/student-groups",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(teacherStudentGroupsHandler)),
	)

	// === teacher & admin ===
	apiMux.Handle(
		"/api/teacher/courses",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(teacherCoursesHandler)),
	)
	apiMux.Handle(
		"/api/teacher/upload-theory-asset",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(uploadTheoryAssetHandler)),
	)
	apiMux.Handle(
		"/api/teacher/tests",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(teacherTestsHandler)),
	)
	apiMux.Handle(
		"/api/teacher/questions",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(teacherQuestionsHandler)),
	)
	apiMux.Handle(
		"/api/teacher/options",
		RequireAnyRole([]string{"admin", "teacher"}, http.HandlerFunc(teacherOptionsHandler)),
	)

	// === курсы для всех авторизованных ролей ===
	apiMux.Handle(
		"/api/courses",
		RequireAnyRole([]string{"admin", "teacher", "student"}, http.HandlerFunc(GetCourses)),
	)

	// === CRUD для теории ===

	// 1) Получение/тесты/детали курса или теории
	apiMux.Handle("/api/courses/", RequireAnyRole(
		[]string{"admin", "teacher", "student"},
		http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			p := strings.TrimPrefix(r.URL.Path, "/api/courses/")
			parts := strings.Split(p, "/")

			switch {
			// GET /api/courses/{id}/theory
			case len(parts) == 2 && parts[1] == "theory":
				GetTheory(w, r)
			// GET /api/courses/{id}/tests
			case len(parts) == 2 && parts[1] == "tests":
				GetTests(w, r)
			// GET /api/courses/{id}
			case len(parts) == 1 && parts[0] != "":
				GetCourseByID(w, r)
			default:
				http.NotFound(w, r)
			}
		}),
	))

	// 2) Получение конкретной темы и темы с тестами
	apiMux.Handle("/api/theory/", RequireAnyRole(
		[]string{"admin", "teacher", "student"},
		http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			path := strings.TrimPrefix(r.URL.Path, "/api/theory/")
			if strings.HasSuffix(path, "/with-tests") {
				GetTheoryWithTests(w, r)
			} else {
				GetTheoryItem(w, r)
			}
		}),
	))

	// 3) Получение вопросов теста
	// apiMux.Handle(
	// 	"/api/tests/",
	// 	RequireAnyRole([]string{"admin", "teacher", "student"}, http.HandlerFunc(GetTestQuestions)),
	// )
	// 4) Установка открытого ответа
	apiMux.Handle(
		"/api/teacher/questions/set_open_answer",
		RequireAnyRole([]string{"admin", "teacher", "student"}, http.HandlerFunc(teacherSetOpenAnswerHandler)),
	)

	// 5) Создание темы + bulk-изменение порядка
	apiMux.Handle("/api/teacher/courses/", RequireAnyRole(
		[]string{"admin", "teacher"},
		http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			p := strings.TrimPrefix(r.URL.Path, "/api/teacher/courses/")
			parts := strings.Split(p, "/")
			if len(parts) == 2 && parts[1] == "theory" {
				switch r.Method {
				case http.MethodPost:
					CreateTheoryHandler(w, r)
					return
				case http.MethodPut:
					ReorderTheoryHandler(w, r)
					return
				}
			}
			http.NotFound(w, r)
		}),
	))

	// 6) Обновление и удаление темы
	apiMux.Handle("/api/teacher/theory/", RequireAnyRole(
		[]string{"admin", "teacher"},
		http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			idStr := strings.TrimPrefix(r.URL.Path, "/api/teacher/theory/")
			id, err := strconv.Atoi(idStr)
			if err != nil {
				http.NotFound(w, r)
				return
			}
			switch r.Method {
			case http.MethodPut:
				UpdateTheoryHandler(w, r, id)
			case http.MethodDelete:
				DeleteTheoryHandler(w, r, id)
			case http.MethodGet:
				GetTheoryHandler(w, r, id)
			default:
				http.NotFound(w, r)
			}
		}),
	))

	// === эндпойнты для попыток теста ===

	apiMux.Handle(
		"/api/tests/",
		JWTAuthMiddleware(
			RequireAnyRole([]string{"admin", "teacher", "student"},
				http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					// Убираем префикс и разбиваем путь
					path := strings.TrimPrefix(r.URL.Path, "/api/tests/")
					parts := strings.Split(path, "/")

					switch {
					// 1) Получение вопросов: GET /api/tests/{testId}/questions
					case len(parts) == 2 && parts[1] == "questions" && r.Method == http.MethodGet:
						GetTestQuestions(w, r)
						return

					// 2) Создание попытки:  POST /api/tests/{testId}/attempts
					case len(parts) == 2 && parts[1] == "attempts" && r.Method == http.MethodPost:
						// В логах видно, какой userID делает запрос
						// fmt.Printf("CreateTestAttempt: user %v, test %d\n", getClaims(r.Context()).UserID, testID)
						CreateTestAttempt(w, r)
						return

					// 3) Подсчёт попыток:  GET /api/tests/{testId}/attempts/count
					case len(parts) == 3 && parts[1] == "attempts" && parts[2] == "count" && r.Method == http.MethodGet:
						GetAttemptsCount(w, r)
						return

					// GET /api/tests/{testId}/attempts/latest ===
					case len(parts) == 3 && parts[1] == "attempts" && parts[2] == "latest" && r.Method == http.MethodGet:
						GetLatestAttempt(w, r)
						return

					default:
						http.NotFound(w, r)
						return
					}
				}),
			),
		),
	)

	// PATCH /api/attempts/{attemptId}/finish
	apiMux.Handle(
		"/api/attempts/",
		JWTAuthMiddleware(
			RequireAnyRole([]string{"admin", "teacher", "student"},
				http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					path := strings.TrimPrefix(r.URL.Path, "/api/attempts/")
					parts := strings.Split(path, "/")
					if len(parts) == 2 && parts[1] == "finish" && r.Method == http.MethodPatch {
						FinishTestAttempt(w, r)
						return
					}
					http.NotFound(w, r)
				}),
			),
		),
	)

	// Вешаем JWT-мидлвэир на все /api/
	mux.Handle("/api/", JWTAuthMiddleware(apiMux))

	// === ПЛАНИРОВЩИК автоматического пересчёта сложности ===
	c := cron.New()

	// Запускаем пересчёт каждый день в 3:00 ночи
	_, err = c.AddFunc("0 3 * * *", func() {
		log.Println("Автоматический пересчёт сложности вопросов...")
		if err := RecalcDifficulty(db); err != nil {
			log.Println("Ошибка при автоматическом пересчёте:", err)
		} else {
			log.Println("Пересчёт сложности завершён успешно.")
		}
	})
	if err != nil {
		log.Fatal("Не удалось запланировать задачу пересчёта:", err)
	}

	// Запускаем cron-планировщик
	c.Start()
	defer c.Stop()

	// запуск этой функции производит мгновенный пересчет сложности всех вопросов из БД
	// if err := RecalcDifficultyML(db); err != nil {
	// 	log.Println("Ошибка начального пересчёта сложности:", err)
	// }

	// Запуск сервера с CORS
	fmt.Println("Server started on :8080")
	log.Fatal(http.ListenAndServe(":8080", CORSMiddleware(mux)))
}

// createAdminUser: создаёт админа, если нет
func createAdminUser() {
	hashed, _ := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
	admin := User{
		Email:        "admin@example.com",
		PasswordHash: string(hashed),
		Role:         "admin",
		FullName:     "Admin1",
		IsActive:     true,
		CreatedAt:    time.Now(),
	}

	var exists bool
	err := db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE email=$1)", admin.Email).Scan(&exists)
	if err != nil {
		log.Fatal(err)
	}
	if !exists {
		_, err = db.Exec(`
			INSERT INTO users(email,password_hash,role,full_name,is_active,created_at)
			VALUES($1,$2,$3,$4,$5,$6,$7)`,
			admin.Email, admin.PasswordHash, admin.Role, admin.FullName, admin.IsActive, admin.CreatedAt,
		)
		if err != nil {
			log.Fatal(err)
		}
	}
}

Файл: C:\dev\projects\html\Курсовая работа\middleware.go
package main

import (
	"context"
	"net/http"

	"github.com/golang-jwt/jwt"
)

// ключ для контекста
type ctxKey string

const (
	ctxKeyClaims ctxKey = "claims"
)

// Извлечение Claims из контекста
func getClaims(ctx context.Context) *Claims {
	if c, ok := ctx.Value(ctxKeyClaims).(*Claims); ok {
		return c
	}
	return nil
}

// JWTAuthMiddleware проверяет JWT и кладёт Claims в контекст
func JWTAuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Проверяем наличие токена
		cookie, err := r.Cookie("token")
		if err != nil {
			http.Error(w, "Unauthorized: no token", http.StatusUnauthorized)
			return
		}

		// Парсим токен
		claims := &Claims{}
		token, err := jwt.ParseWithClaims(cookie.Value, claims, func(t *jwt.Token) (interface{}, error) {
			return jwtKey, nil
		})
		if err != nil || !token.Valid {
			http.Error(w, "Unauthorized: invalid token", http.StatusUnauthorized)
			return
		}

		// Сохраняем claims в контексте
		ctx := context.WithValue(r.Context(), ctxKeyClaims, claims)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// RequireRole — позволяет только одной роли
func RequireRole(roleAllowed string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		claims := getClaims(r.Context())
		if claims == nil || claims.Role != roleAllowed {
			http.Error(w, "Unauthorized: insufficient role", http.StatusUnauthorized)
			return
		}
		next.ServeHTTP(w, r)
	})
}

// RequireAnyRole — позволяет любым из списка ролей
func RequireAnyRole(allowed []string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		claims := getClaims(r.Context())
		if claims == nil {
			http.Error(w, "Unauthorized: no claims", http.StatusUnauthorized)
			return
		}
		for _, role := range allowed {
			if claims.Role == role {
				next.ServeHTTP(w, r)
				return
			}
		}
		http.Error(w, "Unauthorized: insufficient role", http.StatusUnauthorized)
	})
}

// CORSMiddleware разрешает запросы с 3000 и 8080 и обрабатывает preflight
func CORSMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin == "http://localhost:3000" || origin == "http://localhost:8080" {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Access-Control-Allow-Credentials", "true")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Accept, Authorization, X-Requested-With")
			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		}

		// На preflight-запрос (OPTIONS) сразу отвечаем 200
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

Файл: C:\dev\projects\html\Курсовая работа\server.js
// server.js
const express = require('express')
const path = require('path')
const { createProxyMiddleware } = require('http-proxy-middleware')

const app = express()
const staticDir = path.join(__dirname, 'static')

// 1) Все запросы на Go-бэкенд
app.use(
	createProxyMiddleware({
		target: 'http://localhost:8080',
		changeOrigin: true,
		ws: true,
		// здесь мы указываем, какие пути проксировать на Go
		context: [
			'/api/**',
			'/login',
			'/register',
			'/logout',
			'/profile',
			'/api/*',
			'/predict',
		],
	})
)

// 2) Раздача фронтенда
app.use(express.static(staticDir))

// 3) Редирект / -> страница приветствия
app.get('/', (req, res) => {
	res.redirect('/welcomeMainPage/index.html')
})

const PORT = process.env.PORT || 3000
app.listen(PORT, () => console.log(`Frontend → http://localhost:${PORT}`))

Файл: C:\dev\projects\html\Курсовая работа\structures.go
package main

import (
	"database/sql"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
)

// User model
type User struct {
	ID           int       `json:"id"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"-"`
	Role         string    `json:"role"`
	FullName     string    `json:"full_name"`
	IsActive     bool      `json:"is_active"`
	CreatedAt    time.Time `json:"created_at"`
	LastLogin    time.Time `json:"last_login"`
	AvatarPath   string    `json:"avatar_path"`
}

// Claims для JWT
type Claims struct {
	UserID int    `json:"user_id"`
	Email  string `json:"email"`
	Role   string `json:"role"`
	jwt.StandardClaims
}

type Option struct {
	ID        int       `json:"id"`
	Text      string    `json:"text"`
	IsCorrect bool      `json:"is_correct"`
	CreatedAt time.Time `json:"created_at"`
}

type Question struct {
	ID             int       `json:"id"`
	Text           string    `json:"text"`
	Type           string    `json:"type"`
	MultipleChoice bool      `json:"multiple_choice"`
	Difficulty     string    `json:"difficulty"`
	CreatedAt      time.Time `json:"created_at"`
	Options        []Option  `json:"options"`
}

type Test struct {
	ID          int        `json:"id"`
	Title       string     `json:"title"`
	Description string     `json:"description"`
	CreatedAt   time.Time  `json:"created_at"`
	Questions   []Question `json:"questions"`
}

type TheoryWithTests struct {
	ID        int       `json:"id"`
	Title     string    `json:"title"`
	Content   string    `json:"content"`
	CourseID  int       `json:"course_id"`
	CreatedAt time.Time `json:"created_at"`
	Tests     []Test    `json:"tests"`
}

// UserInfo — модель для вывода в админке
type UserInfo struct {
	ID        int       `json:"id"`
	Email     string    `json:"email"`
	FullName  string    `json:"full_name"`
	Role      string    `json:"role"`
	IsActive  bool      `json:"is_active"`
	LastLogin time.Time `json:"last_login"`
	GroupID   *int      `json:"group_id,omitempty"` // новое поле "id группы"
}

type Group struct {
	ID        int       `json:"id"`
	Name      string    `json:"name"`
	TeacherID *int      `json:"teacher_id,omitempty"` // стало *int
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// CourseInfo — структура для админ‑панели
type CourseInfo struct {
	ID          int       `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	TeacherID   *int      `json:"teacher_id,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
}

// TestInfo — структура для панели учителя
type TestInfo struct {
	ID          int       `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	CourseID    int       `json:"course_id"`
	CreatedAt   time.Time `json:"created_at"`
}

type QuestionInfo struct {
	ID                int            `json:"id"`
	TestID            int            `json:"test_id"`
	QuestionText      string         `json:"question_text"`
	QuestionType      string         `json:"question_type"`
	MultipleChoice    bool           `json:"multiple_choice"`
	CorrectAnswerText sql.NullString `json:"-"` // временно скрываем
	Difficulty        string         `json:"difficulty"`
	CreatedAt         time.Time      `json:"created_at"`
	Options           []OptionInfo   `json:"options,omitempty"`
}

type QuestionInfoOut struct {
	QuestionInfo
	CorrectAnswerText string `json:"correct_answer_text,omitempty"`
}

type OptionInfo struct {
	ID         int       `json:"id"`
	QuestionID int       `json:"question_id"`
	OptionText string    `json:"option_text"`
	IsCorrect  bool      `json:"is_correct"`
	CreatedAt  time.Time `json:"created_at"`
}

type teacherQuestionRequest struct {
	ID                int    `json:"id,omitempty"`
	TestID            int    `json:"test_id"`
	QuestionText      string `json:"question_text"`
	QuestionType      string `json:"question_type"`
	MultipleChoice    bool   `json:"multiple_choice"`
	CorrectAnswerText string `json:"correct_answer_text"`
	Difficulty        string `json:"difficulty"`
}

// GroupDetail включает информацию о группе и её студентах
type GroupDetail struct {
	ID        int            `json:"id"`
	Name      string         `json:"name"`
	TeacherID *int           `json:"teacher_id,omitempty"` // тоже *int
	Students  []StudentBrief `json:"students"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
}

// StudentBrief — краткая информация по студенту
type StudentBrief struct {
	ID       int    `json:"id"`
	FullName string `json:"full_name"`
	Email    string `json:"email"`
}

// studentGroupPayload — входной JSON для PUT/DELETE /api/teacher/student-groups
type studentGroupPayload struct {
	StudentID    int    `json:"student_id"`
	StudentEmail string `json:"student_email"`
	GroupID      *int   `json:"group_id"`
}

type UserQuestionAnswer struct {
	ID         int       `json:"id"`
	UserID     int       `json:"user_id"`
	QuestionID int       `json:"question_id"`
	IsCorrect  bool      `json:"is_correct"`
	AnsweredAt time.Time `json:"answered_at"`
}

